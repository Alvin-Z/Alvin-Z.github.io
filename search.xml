<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2019/03/26/Markdown/"/>
      <url>/2019/03/26/Markdown/</url>
      
        <content type="html"><![CDATA[<h2 id="标题设置（让字体变大，和word的标题意思一样）"><a href="#标题设置（让字体变大，和word的标题意思一样）" class="headerlink" title="标题设置（让字体变大，和word的标题意思一样）"></a>标题设置（让字体变大，和word的标题意思一样）</h2><p>在Markdown当中设置标题，有两种方式：<br>第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。<br>第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）</p><h2 id="块注释（blockquote）"><a href="#块注释（blockquote）" class="headerlink" title="块注释（blockquote）"></a>块注释（blockquote）</h2><p>通过在文字开头添加“&gt;”表示块注释。（当&gt;和文字之间添加五个blank时，块注释的文字会有变化。）</p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><p>将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来</p><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h2><p>将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>在文字开头添加(<code>*</code>, <code>+</code>, and <code>-</code>)实现无序列表。但是要注意在(<code>*</code>, <code>+</code>, and <code>-</code>)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）</p><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>使用数字后面加上英语句号。（还要有空格）</p><h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>Markdown中有两种方式，实现链接，分别为内联方式和引用方式。<br>内联方式：<code>This is an [example link](http://example.com/).</code></p><p>引用方式：<code>I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].  [1]: http://google.com/        &quot;Google&quot; [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot; [3]: http://search.msn.com/    &quot;MSN Search&quot;</code></p><h2 id="图片（Images）"><a href="#图片（Images）" class="headerlink" title="图片（Images）"></a>图片（Images）</h2><p>图片的处理方式和链接的处理方式，非常的类似。<br>内联方式：<code>![alt text](/path/to/img.jpg &quot;Title&quot;)</code></p><p>引用方式：<code>![alt text][id] [id]: /path/to/img.jpg &quot;Title&quot;9.</code></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>（HTML中所谓的Code）实现方式有两种：</p><p>第一种：简单文字出现一个代码框，使用<code></code>。（不是单引号而是左上角的ESC下面~中的）</p><p>第二种：大片文字需要实现代码框。使用Tab和四个空格。</p><h2 id="脚注（footnote）"><a href="#脚注（footnote）" class="headerlink" title="脚注（footnote）"></a>脚注（footnote）</h2><p>实现方式如下：hello[^hello][^hello]: hi11. </p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>在空白行下方添加三条“-”横线。 </p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建静态博客</title>
      <link href="/2019/03/26/HEXO/"/>
      <url>/2019/03/26/HEXO/</url>
      
        <content type="html"><![CDATA[<h3 id="按照以下步骤，搭建了Github-Hexo的博客，过程记录如下："><a href="#按照以下步骤，搭建了Github-Hexo的博客，过程记录如下：" class="headerlink" title="按照以下步骤，搭建了Github+Hexo的博客，过程记录如下："></a>按照以下步骤，搭建了Github+Hexo的博客，过程记录如下：</h3><ol><li><p>安装hexo<br>2.使用Hexo生成静态页面<br>3.拷贝静态页面到本地github文件夹下，之后上传并发布<br>4.Hexo的使用</p><h3 id="1-安装hexo"><a href="#1-安装hexo" class="headerlink" title="1.安装hexo"></a>1.安装hexo</h3><p>在使用Hexo之前，需要下载并安装：<br>GitBash<br>Node.js</p></li></ol><p>之后，在电脑某个地方创建一个文件夹「HEXO」,然后双击进去。进去之后，鼠标点击右键，会出现 Git Bash ，出现 「黑窗口」。安装Hexo，在黑窗口下输入如下命令：</p><pre><code>$ npm install -g hexo-cli</code></pre><p>安装完成之后，继续依次输入如下命令，注意顺序</p><pre><code>$ hexo init  $ npm install</code></pre><h3 id="2-使用Hexo生成静态页面"><a href="#2-使用Hexo生成静态页面" class="headerlink" title="2.    使用Hexo生成静态页面"></a>2.    使用Hexo生成静态页面</h3><p>回到「HEXO」文件夹下，多了好多东西，继续依次输入如下命令：</p><pre><code>$ hexo g  $ hexo s</code></pre><p>在浏览器里输入<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a><br>如果能打开，那么恭喜你！你的博客搭建完成了！</p><h3 id="3-拷贝静态页面到本地github文件夹下，之后上传并发布"><a href="#3-拷贝静态页面到本地github文件夹下，之后上传并发布" class="headerlink" title="3.    拷贝静态页面到本地github文件夹下，之后上传并发布"></a>3.    拷贝静态页面到本地github文件夹下，之后上传并发布</h3><p>创建好账号之后，你需要创建一个仓库repository。如果你要用这个仓库来存放你的博客，那么仓库的名字不是你想改，想改就能改的，仓库的名称必须是这样的</p><blockquote><p>仓库的名称 = 你注册的昵称 + github.io</p></blockquote><p>接下来，你需要下载一个GitHub Windows客户端。安装好之后，登录，然后Clone下来你刚创建的仓库，像这样（我的是hedge-hog.githu.io）。Clone的时候，会让你选择Clone的地方，记住这个地方，比如，我的「HEXO」和GitHub Clone的目标文件夹「GitHub_page」都在D盘的根目录下</p><p>接下来，到「HEXO」文件夹下，找到public文件夹，将public文件夹下的所有东西，全部粘贴到你刚刚Clone下来的仓库中，也就是：你的GitHub昵称+github.io 中。</p><p>粘贴好之后，打开GitHub Windows客户端，你本地的代码已经有了改变，所以客户端会提醒你，让你 Commit to master,把该填的一填，然后Commit，Commit完成之后，别忘了点击右上角的 publish 上述一切完成之后，请在浏览器里输入你注册的昵称 + github.io，好了，你的博客到此为止，已经搭建完成。</p><h3 id="4-Hexo的使用"><a href="#4-Hexo的使用" class="headerlink" title="4. Hexo的使用"></a>4. Hexo的使用</h3><p>下载好一套hexo的模板之后，放到HEXO目录themes目录下，再将根目录下_config.yml文件中的theme选项改成模板文件夹的名字，就可以使用该模板来生成静态页面了。</p><p>模板的字体设置在mixins.styl<br>文章字体大小在base.styl<br>body<br>  @extend .serif<br>  font-size 16px<br>原图片在theme\img文件夹下，经hexo g生成后会复制一份到public文件夹下。</p><h2 id="5-部署步骤"><a href="#5-部署步骤" class="headerlink" title="5.部署步骤"></a>5.部署步骤</h2><p>每次部署的步骤，可按以下三步来进行。</p><p><strong>    hexo clean</strong></p><p><strong>    hexo generate</strong></p><p><strong>    hexo deploy</strong></p><h2 id="6-一些常用命令："><a href="#6-一些常用命令：" class="headerlink" title="6. 一些常用命令："></a>6. 一些常用命令：</h2><p>hexo new”postName” #新建文章</p><p>hexo new page”pageName” #新建页面</p><p>hexo generate #生成静态页面至public目录</p><p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p><p>hexo deploy #将.deploy目录部署到GitHub</p><p>hexo help # 查看帮助</p><p>hexo version #查看Hexo的版本</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Font Awesome 文字图标</title>
      <link href="/2019/03/26/Font%20Awesome/"/>
      <url>/2019/03/26/Font%20Awesome/</url>
      
        <content type="html"><![CDATA[<p>图标站： <a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">http://fontawesome.io/icons/</a></p><h1 id="Animated-Icons"><a href="#Animated-Icons" class="headerlink" title="Animated Icons"></a>Animated Icons</h1><p><span style="color:orangered "><i class="fa fa-tripadvisor  fa-spin fa-3x fa-fw"></i>Loading…</span></p><p><span style="color:midnightblue"><i class="fa fa-asterisk  fa-spin fa-3x fa-fw"></i>Loading…</span></p><p><i class="fa fa-spinner fa-spin fa-3x fa-fw"></i><span class="sr-only">Loading…</span></p><p><i class="fa fa-circle-o-notch fa-spin fa-3x fa-fw"></i><span class="sr-only">Loading…</span></p><p><i class="fa fa-refresh fa-spin fa-3x fa-fw"></i><span class="sr-only">Loading…</span></p><p><i class="fa fa-cog fa-spin fa-3x fa-fw"></i><span class="sr-only">Loading…</span></p><p><i class="fa fa-spinner fa-pulse fa-3x fa-fw"></i><span class="sr-only">Loading…</span></p><h1 id="Basic-Icons"><a href="#Basic-Icons" class="headerlink" title="Basic Icons"></a>Basic Icons</h1><p><i class="fa fa-camera-retro"></i> fa-camera-retro<br><span style="color:orange"><i class="fa fa-tripadvisor" fa-5x></i> 链接</span></p><p><i class="fa fa-camera-retro fa-lg"></i> fa-lg<br><i class="fa fa-camera-retro fa-2x"></i> fa-2x<br><i class="fa fa-camera-retro fa-3x"></i> fa-3x<br><i class="fa fa-camera-retro fa-4x"></i> fa-4x<br><i class="fa fa-camera-retro fa-5x"></i> fa-5x</p><h1 id="List-Icons"><a href="#List-Icons" class="headerlink" title="List Icons"></a>List Icons</h1><ul class="fa-ul"><br>  <li><i class="fa-li fa fa-check-square"></i>List icons</li><br>  <li><i class="fa-li fa fa-check-square"></i>can be used</li><br>  <li><i class="fa-li fa fa-spinner fa-spin"></i>as bullets</li><br>  <li><i class="fa-li fa fa-square"></i>in lists</li><br></ul><h1 id="Fixed-Width-Icons"><a href="#Fixed-Width-Icons" class="headerlink" title="Fixed Width Icons"></a>Fixed Width Icons</h1><div class="list-group"><br>  <a class="list-group-item" href="#"><i class="fa fa-home fa-fw" aria-hidden="true"></i>&nbsp; Home</a><br>  <a class="list-group-item" href="#"><i class="fa fa-book fa-fw" aria-hidden="true"></i>&nbsp; Library</a><br>  <a class="list-group-item" href="#"><i class="fa fa-pencil fa-fw" aria-hidden="true"></i>&nbsp; Applications</a><br>  <a class="list-group-item" href="#"><i class="fa fa-cog fa-fw" aria-hidden="true"></i>&nbsp; Settings</a><br></div>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/25/hello-world/"/>
      <url>/2019/03/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> aaa </tag>
            
            <tag> bbb </tag>
            
            <tag> ccc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年记da</title>
      <link href="/2017/12/31/2017%E8%AE%B0/"/>
      <url>/2017/12/31/2017%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>不管想不想承认，想不想面对，这一年都是以一段失败的感情开始的。有些人注定要出现在你的世界里，教会你一些东西，然后转身离开。那时汹涌的心情早已平复。虽然这辈子已经不会再有任何联系和牵扯，现在想想，还是很感谢她的。感情里没什么对错可说，惟愿你我都会过的好。</p><p>3月份报名参加马拉松比赛，日期却撞上了5月份<code>上海图灵奖大会</code>。 马拉松比赛，魔都，都是我一直向往的，最后我选择了熊掌。保持锻炼，下次也许会去外地参加比赛也说不定。</p><p>4月22日，有了自己的第一台单反Nikon。24日，医生告诉我长了个脂肪瘤。对身体没什么影响，所以留着它吧。</p>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 年记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全世界谁倾听你</title>
      <link href="/2017/05/09/%E5%85%A8%E4%B8%96%E7%95%8C%E8%B0%81%E5%80%BE%E5%90%AC%E4%BD%A0/"/>
      <url>/2017/05/09/%E5%85%A8%E4%B8%96%E7%95%8C%E8%B0%81%E5%80%BE%E5%90%AC%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<center>全世界谁倾听你<br><br>多希望有一个像你的人<br><br>但黄昏跟清晨无法相认<br><br>雨停了 歌停了 风继续<br>雨伞又遗落原地<br><br>多希望你就是最后的人<br><br>但年轮和青春不忍相认<br>一盏灯 一座城 找一人<br>一路的颠沛流离<br><br>从你的全世界路过<br>把全盛的我都活过<br>请往前走 不必回头<br><br>在终点等你的人会是我<br><br>多希望你就是最后的人<br><br>但年轮和青春不忍相认<br><br>一盏灯 一座城 找一人<br>一路的颠沛流离<br><br>从你的全世界路过<br>把全盛的爱都活过<br>我始终没说 不增加你负荷<br>最后等你的人是我<br>从你的全世界路过<br>把全盛的我都活过<br><br>请往前走 不必回头<br>在终点等你的人会是我<br><br>你爱默默倾听全世界<br>全世界谁倾听你<br>一朵一朵一首一首的 曾经<br><br>从你的全世界路过<br>把全盛的爱都活过<br><br>我始终没说 不增加你负荷<br>最后等你的人是我<br>从你的全世界路过<br>把全盛的我都活过<br>请往前走 不必回头<br><br>在终点等你的人会是我<br><br>请往前走 不必回头<br><br>在终点等你的人会是我</center>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侣行第三季</title>
      <link href="/2017/04/21/%E4%BE%A3%E8%A1%8C3/"/>
      <url>/2017/04/21/%E4%BE%A3%E8%A1%8C3/</url>
      
        <content type="html"><![CDATA[<h1 id="穿越罗布泊，途经楼兰古国"><a href="#穿越罗布泊，途经楼兰古国" class="headerlink" title="穿越罗布泊，途经楼兰古国"></a>穿越罗布泊，途经楼兰古国</h1><p>雅丹地貌</p><p>胡杨，一千年不死，死后一千年不倒，倒后一千年不朽。</p><h1 id="巴基斯坦"><a href="#巴基斯坦" class="headerlink" title="巴基斯坦"></a>巴基斯坦</h1><p>喀什出发，经帕米尔高原，红其拉甫，首都伊斯兰堡，白沙瓦</p><!--印度和巴基斯坦原来是一个国家。就是印度。是由于长期的历史发展和英国的殖民统治而形成的。印度独立的时候，国内信仰伊斯兰教的少数派不愿意接受多数派印度教的统治，提出分治。就是信仰伊斯兰教的占多数的地方另外建立巴基斯坦国，就是清真国。于是有印度和巴基斯坦分治。--><!--原来印度信仰伊斯兰教的占多数的地方分居西北和东南部。于是新生的巴基斯坦国的领土也分成东西两部分。东西两部分相距1600公里，中间隔着印度。就是今天的巴基斯坦（西巴基斯坦）和孟加拉国（东巴基斯坦）。--><!--象这样根据宗教原则划分两个国家是史无前例的。印度和巴基斯坦许多是同一个民族，就是由于宗教信仰不同而互相仇视。而且由于各种原因，许多信仰印度教的留在了巴基斯坦，信仰教的留在了印度。印度和巴基斯坦分治遗留的最难解决的问题就是克什米尔问题。克什米尔的统治者信仰印度教，而许多群众信仰教。根据统治者的意志克什米尔加入了印度，但是当地许多人要求加入巴基斯坦。印度和巴基斯坦刚刚独立的时候就因为克什米尔问题爆发战争。以后又进行了两次，问题始终没有解决。--><!--1971年，东巴基斯坦脱离巴基斯坦建立孟加拉国。巴基斯坦国土分成东西两部搜索分的历史正式结束。--><p>巴基斯坦并不安全，塔利班武装，需要安保人员。</p><p><code>慕士塔格雪山</code></p><p>塔什库尔干，中国最西的县城。</p><p><code>降旗仪式</code>：1947年，印度和法基斯坦分治，两国每个傍晚，在瓦格赫边防哨卡举行闭关降旗仪式，成为互相挑衅蔑视的过程。该仪式已持续50多年。</p><h1 id="阿富汗"><a href="#阿富汗" class="headerlink" title="阿富汗"></a>阿富汗</h1><p>首都：喀布尔</p><p>女人的一切行为都被禁止，要穿布卡才能出门，社会地位很低。</p><p>巴米扬大佛，55米，世界第一高立佛。</p><h1 id="伊拉克"><a href="#伊拉克" class="headerlink" title="伊拉克"></a>伊拉克</h1><p>巴格达</p><p>伊斯兰国：宗教组织</p><p><code>乌尔古城</code>：全世界第一座城市</p><p>军刀门</p><p>DHL快递</p><h1 id="土耳其"><a href="#土耳其" class="headerlink" title="土耳其"></a>土耳其</h1><p>爱情海</p><h1 id="迪拜"><a href="#迪拜" class="headerlink" title="迪拜"></a>迪拜</h1><p>棕榈岛</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 侣行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人的一生要去的55个地方</title>
      <link href="/2017/04/20/%E4%BA%BA%E7%9A%84%E4%B8%80%E7%94%9F%E8%A6%81%E5%8E%BB%E7%9A%8455%E4%B8%AA%E5%9C%B0%E6%96%B9/"/>
      <url>/2017/04/20/%E4%BA%BA%E7%9A%84%E4%B8%80%E7%94%9F%E8%A6%81%E5%8E%BB%E7%9A%8455%E4%B8%AA%E5%9C%B0%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p>千年城池：<br>西安——千年古都<br>南京——六朝金粉地，金陵帝王州<br>北京——举世无双的皇家建筑<br>苏州——苏州园林甲天下<br>大理——风花雪月地，山光水色城<br>澳门——东方的拉斯维加斯<br>文化名镇：<br>丽江——有一段时光叫丽江<br>腾冲——极边第一城<br>喀什——丝路明珠<br>伊犁——塞外江南<br>徽州——风雅山水田园，徽派古建长廊<br>凤凰——沈从文笔下的边城<br>日喀则——最如意美好的庄园<br>绍兴——水乡、桥乡、酒乡、……<br>曲阜三孔——儒学之源、儒教之根<br>野外探险：<br>喀纳斯——云间部落<br>阿里——千山之巅、万川之源<br>塔克拉玛乾沙漠——神秘瀚海<br>海螺沟——冰川森林公园泡温泉<br>三江源——母亲河的“母亲”<br>雅鲁藏布江大峡谷——人类最后的秘境<br>怒江——神秘的东方大峡谷<br>德天瀑布——中国最美的瀑布<br>黔东南——真人、真水、真情<br>神农架——野人出没的地方<br>壶口瀑布——黄河之水天上来，奔流到海不复回<br>人间天堂：</p><p>香格里拉——世外桃园<br>西湖——东方明珠<br>塔什库尔乾——冰山上的来客<br>丹巴——美人谷<br>林芝——西藏江南胜过江南<br>稻城亚丁——天堂的颜色<br>黄姚——诗境家园<br>蜀南竹海——蜀南竹海翠天下<br>阳朔——天上人间旅游乡<br>甘南——洗涤人心灵的地方<br>客家土楼——中国南方山中的传奇<br>婺源——江南曲阜，山里书乡<br>巧夺天工：</p><p>山南——藏族的发祥地<br>九寨沟——美丽的童话世界<br>青海湖——地球上的一滴眼泪<br>辉腾锡勒草原——风吹草低见牛羊<br>长白山——关东第一山<br>泸沽湖——东方女儿国<br>华山——奇险天下第一山<br>黄山——五岳归来不看山，黄山归来不看岳<br>四姑娘山——东方的阿尔卑斯山<br>三峡——曾经沧海难为水，除却巫山不是云<br>亚龙湾——三亚归来不看海，除却亚龙不是湾</p><p>文明奇迹：<br>德格——藏族地区璀璨的文化明珠<br>都江堰——“天府”富庶之源<br>拉萨——西藏的象征<br>西夏王陵——东方金字塔<br>云岗石窟——东方艺术宝库<br>敦煌——东方艺术明珠<br>《人一生要去的55个地方》，这让我实足梦游了一通，原来，生活可以这样进行的，简约而不简单。我就像一个虔诚的记录者，将美梦一点一点地移植，然后一遍一遍地流连忘返。<br><strong>千年城池</strong><br>西安——千年古都<br>西安与雅典、罗马、开罗并称为世界四大古都，可堪称一座天然的“立体历史博物馆”。大慈恩寺——华清池——兵马俑——碑林——骊山——半坡遗址——古城墙，这些地方就是“西安的象征”（大雁塔），让你感受“给我一天，还你千年”（陕西历史博物馆）的古都魅力。<br>南京——六朝金粉地，金陵帝王州<br>有着6000多年历史和2400多年建城史的南京，与北京、西安、洛阳并称为“中国四大古都”。历史上先后有十个朝代在此建都，故有“十朝都会”之称。古老的秦淮河玉带般蜿蜒舒展，站立桥头，眼前宛然是历史在悠悠流过；点缀两旁的玄武湖和莫愁湖静如处子，似在幽然倾诉；钟山、栖霞山迤逦悠长，神龙般延续着千年的守卫；金陵古城默然而立，城内的沧桑繁华刻写着它的年轮。<br>北京——举世无双的皇家建筑<br>从高空俯瞰，规模宏大的帝王宫殿、园林、庙坛、陵墓及其他古代建筑井然有序，错落有致，俨然可见昔日皇城的威严。 最大的宫殿建筑群故宫、中国的“心脏”天安门广场 、集江南水乡的玲珑精致和北方园林的豪迈大气于一身的颐和园、我国现存最大的古代祭祀建筑群天坛、人类建筑史上罕见的古代军事防御系统工程万里长城 ，此外，还有现代科技的结晶中关村，着名学府清华北大等，都将是每一个人 神往的理由。<br>苏州——苏州园林甲天下<br>苏州园林已被列入世界文化遗产名录，在中国四大名园中，苏州就占有拙政园、留园两席；“吴中第一名胜”虎丘深厚的文化积淀，使其成为游客来苏州的必游之地；而唐朝诗人张继的一首《枫桥夜泊》使得枫桥、寒山寺成为大家争相来访的地方。苏州既有园林之美，又有山水之胜，自然、人文景观交相辉映，加之文人墨客题咏吟唱，使苏州成为名副其实的“人间天堂”。<br>大理——风花雪月地，山光水色城<br>悠久的的历史和璀璨的文化，留下了丰富的文物古迹。玉洱银沧之间，自然风光绮丽多姿，苍山如屏，洱海如镜，蝴蝶泉深幽，兼有“风、花、雪、月”四大奇观（下关风、上关花、苍山雪、洱海月）。<br>澳门——东方的“拉斯维加斯”<br>妈祖阁、大三巴牌坊花、澳门赛马会都是这里着名的风景。<br><strong>文化名镇</strong><br>丽江——有一段时光叫丽江<br>不在晒太阳，就在酒吧，不在酒吧，就在去酒吧的路上。。。。。。这是驴友中流传的一句话。<br>有人说，丽江是上帝遗留在这个世界上唯一的一块人间仙境。那里瑞云缭绕、祥气笼罩，鸟儿在蓝天白云间鸣啭，牛羊在绿草红花中徜徉，人们在古桥流水边悠闲，阳光照耀着生命的年轮，雪山涧溪洗涤着灵魂的尘埃。在那里，只有聆听、只有感悟、只有凝视人与自然那种相处的和谐、那种柔情的倾诉、那种深深的依恋，把这些统统加在一起，告诉你，这，就是丽江。<br>腾冲——极边第一城<br>远山经雨翠重重，迭水声喧万树丰。路转双桥通胜地，春环一水似长虹。短堤杨柳会烟绿，隔岸荷花映日红。行过坡陀会受望，人家尽在画图中。——黄绮襄<br>腾冲 ，这座南方丝绸之路上的历史文化名城，历经沧桑，积淀了丰富深厚的历史文化，边陲古道的马铃声，记录着中、缅、印的商贸历史；春秋战国时期的铜案，铜鼓凝集着两千多年悠久灿烂的文明；石雕佛像，闪烁着中原与东南亚文化交流的光芒；第二次世界大战中，中国军民在这片热土上抗击日本侵略军，首创全歼侵略者的战例，捍卫了中华民族的尊严。 庄严肃穆的国殇园里安息着为国捐躯的抗日英烈，数千座墓碑向后人昭示着民族精英抵御外辱的浩然正气。<br>喀什——丝路明珠<br>不到喀什就不算到过新疆。（俗语）<br>伊犁——塞外江南<br>不到新疆，不知中国之大，不到伊犁，不知新疆之美。（俗语）<br>徽州——风雅山水田园 徽派古建长廊<br>一生痴绝处，无梦到徽州。（汤显祖）<br>凤凰——沉从文笔下的边城<br>中国有两座最美丽的小城，第一是湖南凤凰，第二是福建长汀。（新西兰着名作家路易艾黎）<br>日喀则——最如意美好的庄园<br>日喀则以其古老的文化，雄伟的寺庙建筑，壮丽的自然景观，优越的地理位置，成为西藏最有吸引力的旅游胜地之一。<br>绍兴——水乡、桥乡、酒乡、兰乡、书法之乡、名士之乡、山清水秀之乡，历史文化之邦，名人荟萃之地。<br>曲阜三孔——儒学之源，儒教之根<br>曲阜之所以享誉全球，被世人尊崇为世界三大圣城之一，因为这里是先秦时代着名思想家、教育家、儒学创始人孔子诞生、讲学、墓葬和后人祭祀之地，也是孔子的学生，中国另一位伟大的思想家、教育家孟子的出生地，是儒学的开山之地。<br><strong>野外探险<strong><em>**</em></strong></strong>喀纳斯——云间部落<br>阿里——千山之巅、万川之源<br>野生动物的乐园，艺术家的天堂，探险家的领地，旅行家的向往，朝圣者的圣地，投资者的处女地。（顺口溜）<br>塔克拉玛乾沙漠——神秘瀚海<br>海螺沟——冰川森林公园泡温泉<br>三江源——母亲河的“母亲”<br>青海的大美，因三江源方显气魄；大美的青海，因三江源更显独特。<br>雅鲁藏布江大峡谷——人类最后的秘境<br>想去西藏的雅鲁藏布江大峡谷旅行吗？去听轰鸣的水声，去看欲滴的绿色，去感悟真实的人生。<br>怒江——神秘的东方大峡谷<br>滩接一滩，一滩高千丈。水无不怒石，山有欲飞峰。（谚语）<br>德天瀑布——中国最美的瀑布<br>神农架——野人出没的地方<br>吃的洋芋果，烤的疙瘩火，烧酒配着腊肉喝，除了神仙就是我。（顺口溜）<br>壶口瀑布——黄河之水天上来，奔流到海不复回<br>秋风卷起千层浪，晚日迎来万丈红。（明 陈维藩）<br><strong>人间天堂<strong><strong><em>**</em></strong></strong></strong>香格里拉——世外桃源<br>太阳最早照耀的地方，是东方的建塘，人间最殊胜的地方，是奶子河畔的香格里拉。（英 詹姆士）<br>神奇的迪庆藏族自治州，景色朴质，仪态万方。金沙江，澜沧江流流贯全境；梅里、白茫、哈巴三大雪山雄踞迪庆。江峡奇险神工鬼斧，雪线风</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚印</title>
      <link href="/2017/04/20/%E8%84%9A%E5%8D%B0/"/>
      <url>/2017/04/20/%E8%84%9A%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<p>记录走过的路</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想去看的中国</title>
      <link href="/2017/04/20/%E6%83%B3%E5%8E%BB%E7%9C%8B%E7%9A%84%E4%B8%AD%E5%9B%BD/"/>
      <url>/2017/04/20/%E6%83%B3%E5%8E%BB%E7%9C%8B%E7%9A%84%E4%B8%AD%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="小城篇"><a href="#小城篇" class="headerlink" title="小城篇"></a>小城篇</h1><h2 id="1-人间天堂——丽江古城"><a href="#1-人间天堂——丽江古城" class="headerlink" title="1. 人间天堂——丽江古城"></a>1. 人间天堂——丽江古城</h2><p>丽江古城历史悠久，古朴如画，兼有水乡之容，山城之貌，城中有水，山中有城，城山相融，山水一体，道路自由，街巷幽深，道旁河畔，垂柳拂水……秋天是丽江最美的季节，秋高气爽的天空、色彩缤纷的树木和花朵，映衬着远处的玉龙雪山令人心旷神怡。小桥流水人家，潺潺溪水从雪山积雪融化而来，如此清澈，清凉。</p><h2 id="2-中国最美的地方——乌镇"><a href="#2-中国最美的地方——乌镇" class="headerlink" title="2. 中国最美的地方——乌镇"></a>2. 中国最美的地方——乌镇</h2><p>乌镇，中国华东，浙江省北部，桐乡市所辖，江南水乡，太湖南岸，古镇村落，具有六千余年悠久历史，古镇民居临河而建、傍桥而市，是江南水乡“小桥、流水、人家”的典范。乌镇具典型江南水乡特征，完整地保存着原有晚清和民国时期水乡古镇的风貌和格局。以河成街，街桥相连，依河筑屋，水镇一体，组织起水阁、桥梁、石板巷等独具江南韵味的建筑因素，体现了中国古典民居“以和为美”的人文思想，以其自然环境和人文环境和谐相处的整体美，呈现江南水乡古镇的空间魅力。</p><h2 id="3-中国画里乡村——黟县"><a href="#3-中国画里乡村——黟县" class="headerlink" title="3. 中国画里乡村——黟县"></a>3. 中国画里乡村——黟县</h2><p>安徽黟县因黟山(黄山的古称)而得名。由于历史上交通闭塞，黟县自古以来极少受到战争劫难，16世纪徽商鼎盛，为这里留下了大量的明清民居、祠堂、牌坊、园林，更有世界文化遗产西递、宏村古村落，素有“东方古代建筑艺术宝库”、“中国传统文化缩影”之美誉。黟县四季分明，气候温和，田园风光迷人。陶渊明游历于此，写下了不朽名篇《桃花源记》，李白题诗赞誉“黟县小桃源，烟霞百里间，地多灵草木，人尚古衣冠”。因此，黟县又被称为“中国画里乡村”、“桃花源里人家”。</p><h2 id="4-中国最美的乡村——婺源"><a href="#4-中国最美的乡村——婺源" class="headerlink" title="4. 中国最美的乡村——婺源"></a>4. 中国最美的乡村——婺源</h2><p>婺源县位于江西省东北部，皖赣浙三省交界处。婺源是古徽州府六县之一，徽州文化的发祥地之一。婺源东西分别与两座国家历史文化名城——衢州、景德镇毗邻，南隔铜都上饶德兴市与世界自然遗产“江南第一仙山”——三清山相望，北枕国家级旅游胜地黄山和国家历史名城古徽州首府歙县。婺源素有“书乡”、“茶乡”之称，是全国著名的文化与生态旅游县，被外界誉为“中国最美的乡村”、“一颗镶嵌在赣、浙、皖三省交界处的绿色明珠。</p><h2 id="5-天下第一江山——阆中古城"><a href="#5-天下第一江山——阆中古城" class="headerlink" title="5. 天下第一江山——阆中古城"></a>5. 天下第一江山——阆中古城</h2><p>阆中古城位于四川盆地东北缘、嘉陵江中游，已有2300多年的建城历史，向为古代巴国蜀国军事重镇。阆中土肥水美、气候适宜、物产丰富。古城阆中的建筑风格体现了我国古代的居住风水观，棋盘式的古城格局，融南北风格于一体的建筑群，形成“半珠式”、“品”字型、“多”字型等风格迥异的建筑群体，是中国古代建城选址“天人合一”完备的典型范例。</p><h2 id="6-东方威尼斯——镇远"><a href="#6-东方威尼斯——镇远" class="headerlink" title="6. 东方威尼斯——镇远"></a>6. 东方威尼斯——镇远</h2><p>贵州镇远古镇位于舞阳河畔，四周皆山。舞阳河水蜿蜒,以“S”形穿城而过，城形成了九山抱一水，一水分两城、山水城浑然一体、天人合一的独特的太极图古城风貌，这里群山耸翠，诸水流青，两座大石拱桥像两条纽带横架河上，连结两城。被中外游客誉为东方威尼斯。位于镇远的青龙洞是我国古建筑洞窟群落中离城最近而又最能保持山水园林本色的一处得天独厚、引人入胜的观光游览胜地。</p><h2 id="7-湘西明珠——凤凰古城"><a href="#7-湘西明珠——凤凰古城" class="headerlink" title="7. 湘西明珠——凤凰古城"></a>7. 湘西明珠——凤凰古城</h2><p>凤凰古城是中国历史文化名城，首批中国旅游强县，国家4A级景区，曾被新西兰著名作家路易艾黎称赞为中国最美丽的小城。地理位置可概括为：“西托云贵，东控辰沅，北制川鄂，南扼桂边”。这里与吉首的德夯苗寨，永顺的猛洞河，贵州的梵净山相毗邻，是怀化、吉首、贵州铜仁三地之间的必经之路。作为一座国家历史文化名城，凤凰的风景将自然的、人文的特质有机融合到一处，透视后的沉重感也许正是其吸引八方游人的魅力之精髓。古城建于清康熙年间，这颗“湘西明珠”是名副其实的“小”,小到仅有一条像样的东西大街，可它却是一条绿色长廊。</p><h2 id="8-世界长寿之乡——巴马"><a href="#8-世界长寿之乡——巴马" class="headerlink" title="8. 世界长寿之乡——巴马"></a>8. 世界长寿之乡——巴马</h2><p>广西巴马是“世界第五大长寿之乡”，在这块神秘的土地上，独特的旅游资源十分丰富。巴马属亚热带季风气候区，人居自然环境和气候条件十分宜人，风秀、谷幽、气香、水甘是对这里绿色大自然恰到好处的概括。特别是这里的空气十分的清新，被誉为天然氧吧，世外桃源。巴马寿乡探秘游已列为广西十大旅游精品线路之一，境内有桃花源般令人难以忘怀的盘阳河秀丽风光，有被英国探险队称之为天下第一洞的百么洞等旅游资源。</p><h2 id="9-保存最完整的古县城——平遥"><a href="#9-保存最完整的古县城——平遥" class="headerlink" title="9. 保存最完整的古县城——平遥"></a>9. 保存最完整的古县城——平遥</h2><p>平遥古城位于山西中部的晋中平遥，是一座具有2700多年历史的文化名城，与同为第二批国家历史文化名城的四川阆中、云南丽江、安徽歙县并称为“保存最为完好的四大古城”，也是目前我国唯一以整座古城申报世界文化遗产获得成功的古县城。平遥古城是中国汉民族城市在明清时期的杰出范例，它是由完整的城墙、街道、店铺、寺庙、民居等组成的一组庞大古建筑群。</p><h2 id="10-东方艺术之都——敦煌"><a href="#10-东方艺术之都——敦煌" class="headerlink" title="10.   东方艺术之都——敦煌"></a>10.   东方艺术之都——敦煌</h2><p>敦煌是甘肃省酒泉市辖的一个县级市，中国的国家历史文化名城。敦煌位于古代中国通往西域、中亚和欧洲的交通要道——丝绸之路上，曾经拥有繁荣的商贸活动。以“敦煌石窟”、“敦煌壁画”闻名天下，是世界遗产莫高窟和汉长城边陲玉门关、阳关的所在地。悠久历史孕育的敦煌灿烂古代文化，使敦煌依然辉煌；那遍地的文物遗迹、浩繁的典籍文献、精美的石窟艺术、神秘的奇山异水……使这座古城流光溢彩，使戈壁绿洲越发郁郁葱葱、生机勃勃。</p><hr><h1 id="风景篇"><a href="#风景篇" class="headerlink" title="风景篇"></a>风景篇</h1><h2 id="1-宁夏沙湖——中国观鸟的首选之地"><a href="#1-宁夏沙湖——中国观鸟的首选之地" class="headerlink" title="1. 宁夏沙湖——中国观鸟的首选之地"></a>1. 宁夏沙湖——中国观鸟的首选之地</h2><p>每年有各种各样的迁徙鸟类在宁夏这片湿地栖息，数量多达100万只。鸟类栖息的时间段分布为4-5月和9-10月。在这片80平方千米的广阔地域上，沙漠，湖水和芦苇荡相互交织，形成了独特的自然景观——沙湖。</p><p> <img src="\images\宁夏沙湖.jpg" alt="宁夏沙湖"></p><h2 id="2-四川九寨沟——中国最美湖泊"><a href="#2-四川九寨沟——中国最美湖泊" class="headerlink" title="2. 四川九寨沟——中国最美湖泊"></a>2. 四川九寨沟——中国最美湖泊</h2><p>湖水的颜色来源于湖边风景的倒影，还有湖底的藻类和钙化的岩石。秋季是游览九寨沟的最佳时间，此时，湖面颜色纷繁绚丽，堪与画家色彩丰富的调色板相媲美。</p><p><img src="\images\四川九寨沟.jpg" alt="四川九寨沟"></p><h2 id="3-黄河壶口瀑布——中国最为壮观的瀑布"><a href="#3-黄河壶口瀑布——中国最为壮观的瀑布" class="headerlink" title="3. 黄河壶口瀑布——中国最为壮观的瀑布"></a>3. 黄河壶口瀑布——中国最为壮观的瀑布</h2><p>壶口瀑布是黄河上最大的瀑布，也是中国第二大瀑布。它以其在50元人民币上的优雅形象在中国享有盛誉。瀑布高20米，宽30米，位于山西省和陕西省的交界处。最佳游览时间为5——10月的汛期。此时，水量增大，流速激增，有时瀑布甚至拓宽至50米，尤为壮观。</p><p><img src="\images\黄河壶口瀑布.jpg" alt="黄河壶口瀑布"></p><h2 id="4-湖南凤凰古城——尽情享受原生态自然"><a href="#4-湖南凤凰古城——尽情享受原生态自然" class="headerlink" title="4. 湖南凤凰古城——尽情享受原生态自然"></a>4. 湖南凤凰古城——尽情享受原生态自然</h2><p>凤凰吊脚楼式的房屋是中国文艺爱好者的理想居所。古城还有着丰富的苗族和土家族文化，每年都有成群结队的背包客慕名而至。也有许多人是前来拜访中国作家沈从文的故里。他的小说《边城》，让大家首次认识了这个具有1300年历史的小镇。</p><p><img src="\images\湖南凤凰古城.jpg" alt="湖南凤凰古城"></p><h2 id="5-湖南武陵源——现实版的漂浮山"><a href="#5-湖南武陵源——现实版的漂浮山" class="headerlink" title="5. 湖南武陵源——现实版的漂浮山"></a>5. 湖南武陵源——现实版的漂浮山</h2><p>　　詹姆斯·卡梅隆导演就是受到武陵源石灰岩柱的启发，才有了奥斯卡获奖作品《阿凡达》里潘多拉星球上的漂浮山。事实上，湖南省张家界的武陵源石林里孕育着3000多根这样的石柱，其中最高的高达400米。据说武陵源当局已经根据潘多拉浮山主峰的名字把其中一根石柱命名为“哈利路亚山”。</p><p> <img src="\images\湖南武陵源.jpg" alt="湖南武陵源"></p><h2 id="6-湖北神农架——大脚怪信徒的营地"><a href="#6-湖北神农架——大脚怪信徒的营地" class="headerlink" title="6. 湖北神农架——大脚怪信徒的营地"></a>6. 湖北神农架——大脚怪信徒的营地</h2><p>　　过去的100多年里，400多人声称在神农架的丛林里见过大脚怪，但是至今仍未找到确凿证据。养育着着5000多种动植物，占地3200平方千米的自然保护区，有着中纬度地区保存最为完整的亚热带森林生态系统。这里也是中国珍稀保护动物金丝猴的家园。</p><p> <img src="\images\33312528_6.jpg" alt="33312528_6"></p><h2 id="7-云南省大理崇圣寺三塔"><a href="#7-云南省大理崇圣寺三塔" class="headerlink" title="7. 云南省大理崇圣寺三塔"></a>7. 云南省大理崇圣寺三塔</h2><p>　　崇圣寺三塔的主塔是在公元九世纪中叶首次建立的，当时是为了缓解周期性的水患。塔高69米，共有16层，在唐朝算得上是“摩天大厦”了，即使现在它也是中国最高的宝塔。塔的每一层都饰有栩栩如生的佛像。另两座塔高42米，建立时间比主塔晚约100多年。</p><p> <img src="\images\33312528_7.jpg" alt="33312528_7"></p><h2 id="8-安徽黄山——黄山传奇"><a href="#8-安徽黄山——黄山传奇" class="headerlink" title="8. 安徽黄山——黄山传奇"></a>8. 安徽黄山——黄山传奇</h2><p>　　黄山被联合国教科文组织世界文化遗产评为“中国最美的山”，它也是许多中国人一生不渝的向往。海拔1863米的黄山以其“奇松，怪石，云海，温泉”闻名于世。(中国古语说)黄山归来不看岳，足见对其推崇之至。</p><p><img src="\images\33312528_8.jpg" alt="33312528_8"></p><h2 id="9-广西阳朔——阳朔堪称甲桂林"><a href="#9-广西阳朔——阳朔堪称甲桂林" class="headerlink" title="9. 广西阳朔——阳朔堪称甲桂林"></a>9. 广西阳朔——阳朔堪称甲桂林</h2><p>　　阳朔的自然风光在世界上所占有的重要位置。“山青、水秀、洞奇、石美”，为天下四绝。阳朔百里山川，处处奇山秀水，自然景观与人文景观交相辉映，故有诗人在诗中由衷地感叹：“桂林山水甲天下，阳朔堪称甲桂林”。</p><p> <img src="\images\33312528_9.jpg" alt="33312528_9"></p><h2 id="10-云南石林——天下第一奇观"><a href="#10-云南石林——天下第一奇观" class="headerlink" title="10.云南石林——天下第一奇观"></a>10.云南石林——天下第一奇观</h2><p>　　天造奇观的云南石林，位于云南省昆明市石林彝族自治县境内，海拔1500m—1900m之间，属亚热带低纬度高原山地季风气候，年平均温度约16度，距省会昆明78公里，“冬无严寒、夏无酷暑、四季如春”，是世界唯一位于亚热带高原地区的喀斯特地貌风景区，素有“天下第一奇观”“石林博物馆”的美誉。</p><p> <img src="\images\33312528_10.jpg" alt="33312528_10"></p><h2 id="11-青海省青海湖——中国内陆最大的咸水湖"><a href="#11-青海省青海湖——中国内陆最大的咸水湖" class="headerlink" title="11.青海省青海湖——中国内陆最大的咸水湖"></a>11.青海省青海湖——中国内陆最大的咸水湖</h2><p>　　青海湖海拔3205米，距周边最近的交通枢纽西宁约三小时车程。青海湖在不同的季节里，景色迥然不同。夏秋季节，当四周巍巍的群山和西岸辽阔的草原披上绿装时，青海湖畔山清水秀，天高气爽，景色十分绮丽。除了前来参加环青海湖国际自行车赛的疯狂选手外，鲜有游客来此欣赏油画般美丽的风景。</p><p> <img src="\images\33312528_11.jpg" alt="33312528_11"></p><h2 id="12-浙江乌镇——中国最美水乡古镇"><a href="#12-浙江乌镇——中国最美水乡古镇" class="headerlink" title="12.浙江乌镇——中国最美水乡古镇"></a>12.浙江乌镇——中国最美水乡古镇</h2><p>　　乌镇是典型的江南水乡古镇，素有“鱼米之乡，丝绸之府”之称。乌镇完整地保存着原有晚清和民国时期水乡古镇的风貌和格局。以河成街，街桥相连，依河筑屋，水镇一体，组织起水阁、桥梁、石板巷、茅盾故居等独具江南韵味的建筑因素，体现了中国古典民居“以和为美”的人文思想，以其自然环境和人文环境和谐相处的整体美，呈现江南水乡古镇的空间魅力。</p><p> <img src="\images\33312528_12.jpg" alt="33312528_12"></p><h2 id="13-浙江千岛湖——天下第一秀水"><a href="#13-浙江千岛湖——天下第一秀水" class="headerlink" title="13.浙江千岛湖——天下第一秀水"></a>13.浙江千岛湖——天下第一秀水</h2><p>　　千岛湖位于浙江淳安境内，因湖内拥有星罗棋布的1078个岛屿而得名，是世界上岛屿最多的湖。千岛湖中大小岛屿形态各异，群岛分布有疏有密，罗列有致。群集处形成众岛似连非连，湖面被分隔得宽窄不同、曲折多变、方向难辨，形成湖上迷宫的特色景观，更有百湖岛、百岛湖、珍珠岛等千姿百态的群岛、列岛景观；岛屿稀疏处，湖面开阔、深远、浩渺，宛如海面。湖湾幽深多姿，景色绚丽多彩。</p><p> <img src="\images\33312528_13.jpg" alt="33312528_13"></p><h2 id="14-新疆喀纳斯湖——美丽富饶、神秘莫测"><a href="#14-新疆喀纳斯湖——美丽富饶、神秘莫测" class="headerlink" title="14.新疆喀纳斯湖——美丽富饶、神秘莫测"></a>14.新疆喀纳斯湖——美丽富饶、神秘莫测</h2><p>　　喀纳斯是蒙古语，意为“美丽富饶、神秘莫测”，喀纳斯湖位于布尔津县境北部，是一个坐落在阿尔泰深山密林中的高山湖泊。湖面碧波万顷，群峰倒影，湖面还会随着季节和天气的变化而时时变换颜色，是有名的“变色湖”。北端的入湖三角洲地带，大片沼泽湿地与河湾小滩共存，地形平坦开阔，各种草类与林木共生，一派生机勃勃的景象。喀纳斯湖上端，有湖心岛浮于水面，四周皆森林茂密，湖水碧绿纯净。</p><p> <img src="\images\33312528_14.jpg" alt="33312528_14"></p><h2 id="15-内蒙古呼伦贝尔草原——中国最美的大草原"><a href="#15-内蒙古呼伦贝尔草原——中国最美的大草原" class="headerlink" title="15.内蒙古呼伦贝尔草原——中国最美的大草原"></a>15.内蒙古呼伦贝尔草原——中国最美的大草原</h2><p>　　呼伦贝尔是造化神奇编制的一方净土，是幻想中的天上人间，是现代人不经意撒手失去而又千方百计觅回的理想家园。该草原被《中国国家地理》“选美中国”活动评选为“中国最美的六大草原”第一名。<br>　　说她辽阔宽广，因为她望不到边际，能装下全中国的牛羊；说她美丽，因为她有许多传说，而每一个传说都能让人百听不厌。呼伦贝尔是一个充满云水柔情的名字。呼伦贝尔，是中国人为之骄傲的地方。她以辽阔、宽广、美丽、动人而令人向往。</p><h2 id="16-江苏苏州园林——人间天堂好景致"><a href="#16-江苏苏州园林——人间天堂好景致" class="headerlink" title="16.江苏苏州园林——人间天堂好景致"></a>16.江苏苏州园林——人间天堂好景致</h2><p>　　苏州是中国著名的国家级历史文化名城，有“人间天堂，园林之城”的美誉。这里素来以山水秀丽，园林典雅而闻名天下，有“江南园林甲天下，苏州园林甲江南”的美称。苏州古典园林“不出城郭而获山水之怡，身居闹市而有灵泉之致”。</p><p> <img src="\images\33312528_16.jpg" alt="33312528_16"></p><h2 id="17-江西婺源——时光静止的地方"><a href="#17-江西婺源——时光静止的地方" class="headerlink" title="17.江西婺源——时光静止的地方"></a>17.江西婺源——时光静止的地方</h2><p>　　婺源位于江西省上饶市北部，为徽州文化的发祥地之一。婺源素有“书乡”、“茶乡”之称，是全国著名的文化与生态旅游县，涵盖了“名山、名水、名镇、名村”四大看点，被外界誉为“中国最美的乡村”。婺源温和湿润，四季分明，雾日较多。一年四季都可以去玩。但春天是婺源旅游最好的季节，漫山的红杜鹃，满坡的绿茶，金黄的油菜花，加上白墙黛瓦，五种颜色，和谐搭配，胜过世上一切的图画。</p><p> <img src="\images\33312528_17.jpg" alt="33312528_17"></p><h2 id="18-河北承德避暑山庄——中国皇帝的四星级寓所"><a href="#18-河北承德避暑山庄——中国皇帝的四星级寓所" class="headerlink" title="18.河北承德避暑山庄——中国皇帝的四星级寓所"></a>18.河北承德避暑山庄——中国皇帝的四星级寓所</h2><p>　　被列入世界文化遗产名录的承德避暑山庄曾是清代皇帝们消暑度假的夏宫。现在山庄内仍然保留着精致优雅的皇家园林和一座高达70米的宝塔。苍翠繁茂的草地漫山遍野，莽莽群山巍峨伫立以及峡谷风光的宁静悠闲，这一切使得山庄至今仍不失为避暑胜地。</p><p> <img src="\images\33312528_18.jpg" alt="33312528_18"></p><h2 id="19-贵州黄果树瀑布——中华第一瀑"><a href="#19-贵州黄果树瀑布——中华第一瀑" class="headerlink" title="19.贵州黄果树瀑布——中华第一瀑"></a>19.贵州黄果树瀑布——中华第一瀑</h2><p>　　黄果树瀑布位于贵州省安顺市镇宁布依族苗族自治县境内的白水河上。周围岩溶广布，河宽水急，山峦叠起。白水河流经当地时河床断落成九级瀑布，黄果树为其中最大一级。以水势浩大著称，也是世界著名大瀑布之一。瀑布对面建有观瀑亭，游人可在亭中观赏汹涌澎湃的河水奔腾直洩犀牛潭。腾起水珠高90多米，在附近形成水帘，盛夏到此，暑气全消。</p><p> <img src="\images\33312528_19.jpg" alt="33312528_19"></p><h2 id="20-广东丹霞山——中国红石公园"><a href="#20-广东丹霞山——中国红石公园" class="headerlink" title="20.广东丹霞山——中国红石公园"></a>20.广东丹霞山——中国红石公园</h2><p>　　丹霞山为世界地质公园、国家级自然保护区，位于广东省韶关市仁化县和浈江区境内，是世界“丹霞地貌”命名地。丹霞山由680多座顶平、身陡、麓缓的红色砂砾岩石构成，“色如渥丹，灿若明霞”，以赤壁丹崖为特色。据地质学家研究表明：在世界已发现1200多处丹霞地貌中，丹霞山是发育最典型、类型最齐全、造型最丰富、景色最优美的丹霞地貌集中分布区。</p><p><img src="\images\33312528_20.jpg" alt="33312528_20"></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界最美25座城</title>
      <link href="/2017/04/19/%E4%B8%96%E7%95%8C%E6%9C%80%E7%BE%8E25%E5%BA%A7%E5%9F%8E/"/>
      <url>/2017/04/19/%E4%B8%96%E7%95%8C%E6%9C%80%E7%BE%8E25%E5%BA%A7%E5%9F%8E/</url>
      
        <content type="html"><![CDATA[<p>法国巴黎</p><p>西班牙巴塞罗那</p><p>黎巴嫩贝鲁特</p><p>匈牙利布达佩斯</p><p>捷克布拉格</p><p>比利时布鲁日</p><p>南卡罗来纳州查尔斯顿</p><p>意大利佛罗伦萨</p><p>日本京都</p><p>南非开普敦</p><p>波兰克拉科夫</p><p>加拿大魁北克</p><p>意大利罗马</p><p>澳大利亚墨尔本</p><p>奥地利萨尔茨堡</p><p>西班牙塞维利亚</p><p>新墨西哥州圣达菲</p><p>墨西哥圣米格尔德阿连德</p><p>西班牙圣塞瓦斯蒂安</p><p>意大利威尼斯</p><p>加拿大维多利亚</p><p>奥地利维也纳</p><p>加拿大温哥华</p><p>澳大利亚悉尼</p><p>意大利锡耶纳</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想去的地方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一点点感悟</title>
      <link href="/2017/04/19/%E4%B8%80%E7%82%B9%E7%82%B9%E6%84%9F%E6%82%9F/"/>
      <url>/2017/04/19/%E4%B8%80%E7%82%B9%E7%82%B9%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<p>原来在爱情里，我一直是个乞丐。对一个不喜欢你的人来说，任何的示好，其实都只是乞讨。磨着膝盖求来的感情，应该也是一股馊味儿。</p><p>我本将心照沟渠，奈何沟渠映明月。</p><p>对你的好，你若不珍惜，我就会离开，虽然我喜欢你。</p><p>Life is the art of drawing without an eraser.  人生如画，落笔无悔。</p>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VI</title>
      <link href="/2017/04/19/VI/"/>
      <url>/2017/04/19/VI/</url>
      
        <content type="html"><![CDATA[<p>1、vi的基本概念 </p><p>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</p><p>1) 命令行模式command mode）</p><p>控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</p><p>2) 插入模式（Insert mode）</p><p>只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。</p><p>3) 底行模式（last line mode）</p><p>将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。</p><p>不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。</p><p>2、vi的基本操作 </p><p>a)进入vi</p><p>在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：</p><p>$vi myfile</p><p>不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！</p><p>b)切换至插入模式（Insert mode）编辑文件</p><p>在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时你就可以开始输入文字了。</p><p>c)Insert 的切换</p><p>您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。</p><p>d)退出vi及保存文件</p><p>在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：</p><p>: w filename （输入 「w filename」将文章以指定的文件名filename保存）</p><p>: wq (输入「wq」，存盘并退出vi)</p><p>: q! (输入q!， 不存盘强制退出vi)</p><p>3、命令行模式（command mode）功能键 </p><p>1）. 插入模式</p><p>按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件；</p><p>按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；</p><p>按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。</p><p>2）. 从插入模式切换为命令行模式</p><p>按「ESC」键。</p><p>3）. 移动光标</p><p>vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。</p><p>按「ctrl」+「b」：屏幕往“后”移动一页。</p><p>按「ctrl」+「f」：屏幕往“前”移动一页。</p><p>按「ctrl」+「u」：屏幕往“后”移动半页。</p><p>按「ctrl」+「d」：屏幕往“前”移动半页。</p><p>按数字「0」：移到文章的开头。</p><p>按「G」：移动到文章的最后。</p><p>按「$」：移动到光标所在行的“行尾”。</p><p>按「^」：移动到光标所在行的“行首”</p><p>按「w」：光标跳到下个字的开头</p><p>按「e」：光标跳到下个字的字尾</p><p>按「b」：光标回到上个字的开头</p><p>按「#l」：光标移到该行的第#个位置，如：5l,56l。</p><p>4）. 删除文字</p><p>「x」：每按一次，删除光标所在位置的“后面”一个字符。</p><p>「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符。</p><p>「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符。</p><p>「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符。</p><p>「dd」：删除光标所在行。</p><p>「#dd」：从光标所在行开始删除#行</p><p>5）. 复制</p><p>「yw」：将光标所在之处到字尾的字符复制到缓冲区中。</p><p>「#yw」：复制#个字到缓冲区</p><p>「yy」：复制光标所在行到缓冲区。</p><p>「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。</p><p>「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。</p><p>6）. 替换</p><p>「r」：替换光标所在处的字符。</p><p>「R」：替换光标所到之处的字符，直到按下「ESC」键为止。</p><p>7）. 回复上一次操作</p><p>「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回复。</p><p>8）. 更改</p><p>「cw」：更改光标所在处的字到字尾处</p><p>「c#w」：例如，「c3w」表示更改3个字</p><p>9）. 跳至指定的行</p><p>「ctrl」+「g」列出光标所在行的行号。</p><p>「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</p><p>4、Last line mode下命令简介 </p><p>在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。</p><p>A)列出行号</p><p>「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。</p><p>B)跳到文件中的某一行</p><p>「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。</p><p>C)查找字符</p><p>「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。</p><p>「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。</p><p>D)保存文件</p><p>「w」：在冒号输入字母「w」就可以将文件保存起来。</p><p>E)离开vi</p><p>「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。</p><p>「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。</p><p>5、vi命令列表 </p><p>h </p><p>左移光标一个字符</p><p>l </p><p>右移光标一个字符</p><p>k </p><p>光标上移一行</p><p>j </p><p>光标下移一行</p><p>^ </p><p>光标移动至行首</p><p>0 </p><p>数字“0”，光标移至文章的开头</p><p>G </p><p>光标移至文章的最后</p><p>$ </p><p>光标移动至行尾</p><p>Ctrl+f </p><p>向前翻屏</p><p>Ctrl+b </p><p>向后翻屏</p><p>Ctrl+d </p><p>向前翻半屏</p><p>Ctrl+u </p><p>向后翻半屏</p><p>i </p><p>在光标位置前插入字符</p><p>a </p><p>在光标所在位的后一个字符开始增加</p><p>o </p><p>插入新的一行，从行首开始输入</p><p>ESC </p><p>从输入状态退至命令状态</p><p>x </p><p>删除光标后面的字符</p><p>#x </p><p>删除光标后的＃个字符</p><p>X </p><p>(大写X)，删除光标前面的字符</p><p>#X </p><p>删除光标前面的#个字符</p><p>dd </p><p>删除光标所在的行</p><p>#dd </p><p>删除从光标所在行数的#行</p><p>yw </p><p>复制光标所在位置的一个字</p><p>#yw </p><p>复制光标所在位置的#个字</p><p>yy </p><p>复制光标所在位置的一行</p><p>#yy </p><p>复制从光标所在行数的#行</p><p>p </p><p>粘贴</p><p>u </p><p>取消操作</p><p>cw </p><p>更改光标所在位置的一个字</p><p>#cw </p><p>更改光标所在位置的#个字</p><p>下表列出行命令模式下的一些指令 </p><p>wfilename </p><p>储存正在编辑的文件为filename</p><p>wqfilename </p><p>储存文件并退出vi</p><p>q! </p><p>放弃所有修改，退出vi</p><p>setnu </p><p>显示行号</p><p>/或? </p><p>查找，在/后输入要查找的内容</p><p>n </p><p>与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机基础</title>
      <link href="/2017/04/17/%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/04/17/%E7%9B%B8%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="单反"><a href="#单反" class="headerlink" title="单反"></a>单反</h1><p>单反的全称是<code>单镜头反光相机</code>。实际上单反相机的特征包括有一枚可更换的镜头，有一个反光镜为核心的光路。使用相机摄影都得要有记录影像的感光材料，传统相机的感光材料是胶片，数码相机的感光材料是感光元件（CCD或CMOS），感光器面积的大小与35mm胶片面积相比，如果接近或相等，就是全幅规格，采用该规格尺寸的单反相机就是<code>全幅单反相机</code>。</p><p>传统135相机底片尺寸为<code>36×24mm</code>，佳能EOS-5D数码单反机采用的CMOS尺寸为35.8×23.9mm，接近36×24mm的尺寸。所以，佳能EOS-5D就属于全幅数码单反机。全幅单反机的感光器面积由于与35mm胶片相等或相近，因此所配置的各种镜头的焦距也和传统相机一样。</p><p>基于现有的制造技术和工艺水平，大尺寸全幅感光元件制造困难，价格昂贵，因此目前大多数数码相机采用的感光元件都不是全幅的，其尺寸介于135相机底片和家用数码感光元件之间，最常见的就是“<code>APS-C</code>”规格。<br>因为35mm胶卷的广泛使用，让36×24mm成为一种规格。在这个规格之下，35mm就成为了我们判定镜头视角的一个标准。例如<code>28mm镜头就可以实现广角，35mm为标准视角而50mm是比较接近人眼的视角</code>等等。不过到了数码时代，数码单反相机上采用的感光器目前更多的是采用非36×24mm尺寸，于是就有了倍率问题。例如，<code>APS-C尺寸，倍率1.5（佳能为1.6）；4/3系统，倍率2；适马X3系统，倍率1.7；佳能APS-H尺寸，倍率1.3</code>等。</p><p>以佳能EOS400D（APS-C画幅）及一支18-55mm镜头为例，乘以1.6倍率后，相机上镜头等效焦距将会变为28.8-88mm，但如果是全画幅单反搭配18-55mm镜头，其焦距将保持不变。因此，全画幅的优势显而易见，不仅可以让老镜头物尽其用，还因为感光元件CCD/CMOS面积大，这样一来捕获的光子越多，感光性能越好、信噪比越低。说全画幅单反是未来数码单反发展的一个大趋势，原因也就在此。</p><h1 id="无反相机"><a href="#无反相机" class="headerlink" title="无反相机"></a>无反相机</h1><p>无反相机就是咱们通常说的单电或者微单。操作上有特别像单反的，有特别像小DC的，良莠不齐，但是整体来说还是好的。性能方面，对焦有堪比单反甚至更快的，也有慢到你想杀人的，连拍却往往比单反更强。画质方面的话，有卡片级的一般般画质，也有比单反还好的画质。体积上来说，再大的无反相机也不会特别大。</p><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>焦距：焦距可分为定焦和变焦。30MM-50MM的焦段为定焦镜头。18MM-135MM的焦段为变焦镜头。定焦镜头成的像要比变焦镜头好。<br>光圈：光圈越大，进光就会越多；光圈越小，进光就会越少。光圈的数值越小，光圈就越大；光圈的数值越大，光圈就越小。</p><p>镜头的EF代表Electro Focus（电子对焦）</p><h1 id="价格"><a href="#价格" class="headerlink" title="价格"></a>价格</h1><table><thead><tr><th>尼康D7200</th><th>规格</th><th>淘宝</th><th>京东</th></tr></thead><tbody><tr><td></td><td>机身</td><td>4800</td><td>5100</td></tr><tr><td></td><td>18-140</td><td>6600</td><td>7000</td></tr><tr><td></td><td>18-200（二代）</td><td>7600</td><td>750</td></tr></tbody></table><p>镜头推荐：35 1.8g (1000元)， 50 1.8g（1500）, 85 1.8g（2000），16-85 （4200）</p><table><thead><tr><th>佳能80D</th><th>规格</th><th>淘宝</th><th>京东</th></tr></thead><tbody><tr><td></td><td>机身</td><td>6000</td><td>6300</td></tr><tr><td></td><td>18-135</td><td>7900</td><td>8500</td></tr><tr><td></td><td>18-200</td><td>8000</td><td>8700</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>661座城</title>
      <link href="/2017/04/14/661%E5%BA%A7%E5%9F%8E/"/>
      <url>/2017/04/14/661%E5%BA%A7%E5%9F%8E/</url>
      
        <content type="html"><![CDATA[<p>中国大陆（含港澳）目前有4个直辖市，2个特别行政区（两个城市），283个地级市和374个县级市，一共有661个城市。台湾地区有2个院辖市，5个省辖市和31个县辖市，共计38个城市。</p><p>中国城市具体名录如下：<br>北京市<br>天津市<br>上海市（上述三个城市无县级市）<br>重庆市–下辖4个县级市：合川市 永川市 江津市 南川市</p><h1 id="河北省（每行的第一个城市是地级市，–后面的是县级市，下同）"><a href="#河北省（每行的第一个城市是地级市，–后面的是县级市，下同）" class="headerlink" title="河北省（每行的第一个城市是地级市，–后面的是县级市，下同）"></a>河北省（每行的第一个城市是地级市，–后面的是县级市，下同）</h1><p>石家庄市–辛集市 藁城市 晋州市 新乐市 鹿泉市<br>张家口市<br>承德市<br>秦皇岛市<br>唐山市–遵化市 迁安市<br>廊坊市–霸州市 三河市<br>保定市–定州市 涿州市 安国市 高碑店市<br>衡水市–冀州市 深州市<br>沧州市–泊头市 任丘市 黄骅市 河间市<br>邢台市–南宫市 沙河市<br>邯郸市–武安市</p><h1 id="山西省"><a href="#山西省" class="headerlink" title="山西省"></a>山西省</h1><p>太原市–古交市<br>朔州市<br>大同市<br>阳泉市<br>长治市–潞城市<br>晋城市–高平市<br>忻州市–原平市<br>晋中市–介休市<br>临汾市–侯马市 霍州市<br>吕梁市–孝义市 汾阳市<br>运城市–永济市 河津市</p><p>内蒙古自治区<br>呼和浩特市<br>包头市<br>乌海市<br>赤峰市<br>通辽市–霍林郭勒市<br>呼伦贝尔市–满洲里市 扎兰屯市 牙克石市 根河市 额尔古纳市<br>鄂尔多斯市<br>乌兰察布市–丰镇市<br>巴彦淖尔市<br>（兴安盟）–乌兰浩特市 阿尔山市（前面的括号表示低级非市行政区，下同）<br>（锡林郭勒盟）–锡林浩特市 二连浩特市</p><h1 id="辽宁省"><a href="#辽宁省" class="headerlink" title="辽宁省"></a>辽宁省</h1><p>沈阳市–新民市<br>朝阳市–北票市 凌源市<br>阜新市<br>铁岭市–调兵山市 开原市<br>抚顺市<br>本溪市<br>辽阳市–灯塔市<br>鞍山市–海城市<br>丹东市–凤城市 东港市<br>大连市–瓦房店市 普兰店市 庄河市<br>营口市–大石桥市 盖州市<br>盘锦市<br>锦州市–凌海市 北宁市<br>葫芦岛市–兴城市</p><h1 id="吉林省"><a href="#吉林省" class="headerlink" title="吉林省"></a>吉林省</h1><p>长春市–德惠市 九台市 榆树市<br>白城市–大安市 洮南市<br>松原市<br>吉林市–磐石市 蛟河市 桦甸市 舒兰市<br>四平市–双辽市 公主岭市<br>辽源市<br>通化市–梅河口市 集安市<br>白山市–临江市<br>（延边朝鲜族自治州）–延吉市 图们市 敦化市 珲春市 龙井市 和龙市</p><h1 id="黑龙江省"><a href="#黑龙江省" class="headerlink" title="黑龙江省"></a>黑龙江省</h1><p>哈尔滨市–双城市 尚志市 五常市 阿城市<br>七台河市<br>齐齐哈尔市–讷河市<br>黑河市–北安市 五大连池市<br>大庆市<br>鹤岗市<br>伊春市–铁力市<br>佳木斯市–同江市 富锦市<br>双鸭山市<br>鸡西市–虎林市 密山市<br>牡丹江市–穆棱市 绥芬河市 海林市 宁安市<br>绥化市–安达市 肇东市 海伦市</p><h1 id="江苏省"><a href="#江苏省" class="headerlink" title="江苏省"></a>江苏省</h1><p>南京市<br>徐州市–邳州市 新沂市<br>连云港市<br>宿迁市<br>淮安市<br>盐城市–东台市 大丰市<br>扬州市–仪征市 江都市 高邮市<br>泰州市–靖江市 泰兴市 姜堰市 兴化市<br>南通市–海门市 启东市 通州市 如皋市<br>镇江市–扬中市 丹阳市 句容市<br>常州市–金坛市 溧阳市<br>无锡市–江阴市 宜兴市<br>苏州市–吴江市 昆山市 太仓市 常熟市张家港市</p><h1 id="浙江省"><a href="#浙江省" class="headerlink" title="浙江省"></a>浙江省</h1><p>杭州市–临安市 富阳市 建德市<br>湖州市<br>嘉兴市–平湖市 海宁市 桐乡市<br>舟山市<br>宁波市–慈溪市 余姚市 奉化市<br>绍兴市–诸暨市 上虞市 嵊州市<br>衢州市–江山市<br>金华市–兰溪市 永康市 义乌市 东阳市<br>台州市–临海市 温岭市<br>温州市–瑞安市 乐清市<br>丽水市–龙泉市</p><h1 id="安徽省"><a href="#安徽省" class="headerlink" title="安徽省"></a>安徽省</h1><p>合肥市<br>宿州市<br>淮北市<br>亳州市<br>阜阳市–界首市<br>蚌埠市<br>淮南市<br>滁州市–明光市 天长市<br>马鞍山市<br>芜湖市<br>铜陵市<br>安庆市–桐城市<br>黄山市<br>六安市<br>巢湖市<br>池州市<br>宣城市–宁国市</p><h1 id="福建省"><a href="#福建省" class="headerlink" title="福建省"></a>福建省</h1><p>福州市–福清市 长乐市<br>南平市–邵武市 武夷山市 建瓯市 建阳市<br>莆田市<br>三明市–永安市<br>泉州市–石狮市 晋江市 南安市<br>厦门市<br>漳州市–龙海市<br>龙岩市–漳平市<br>宁德市–福安市 福鼎市</p><h1 id="江西省"><a href="#江西省" class="headerlink" title="江西省"></a>江西省</h1><p>南昌市<br>九江市–瑞昌市<br>景德镇市–乐平市<br>鹰潭市-贵溪市<br>新余市<br>萍乡市<br>赣州市–瑞金市 南康市<br>上饶市–德兴市<br>抚州市<br>宜春市–丰城市 樟树市 高安市<br>吉安市</p><h1 id="山东省"><a href="#山东省" class="headerlink" title="山东省"></a>山东省</h1><p>济南市–章丘市<br>聊城市–临清市<br>德州市–乐陵市 禹城市<br>东营市<br>淄博市<br>潍坊市–安丘市 昌邑市 高密市 青州市 诸城市 寿光市<br>烟台市–栖霞市 海阳市 龙口市 莱阳市 莱州市 蓬莱市 招远市<br>威海市–荣成市 乳山市 文登市<br>青岛市–胶州市 即墨市 平度市 胶南市 莱西市<br>日照市<br>临沂市<br>枣庄市–滕州市<br>济宁市–曲阜市 兖州市 邹城市<br>泰安市–新泰市 肥城市<br>莱芜市<br>滨州市<br>菏泽市</p><h1 id="河南省–济源市-省名后面的–的城市为省直辖县级市，下同）"><a href="#河南省–济源市-省名后面的–的城市为省直辖县级市，下同）" class="headerlink" title="河南省–济源市(省名后面的–的城市为省直辖县级市，下同）"></a>河南省–济源市(省名后面的–的城市为省直辖县级市，下同）</h1><p>郑州市–新郑市 登封市 新密市 巩义市 荥阳市<br>三门峡市–义马市 灵宝市<br>洛阳市–偃师市<br>焦作市–孟州市 沁阳市<br>新乡市–卫辉市 辉县市<br>鹤壁市<br>安阳市–林州市<br>濮阳市<br>开封市<br>商丘市–永城市<br>许昌市–禹州市 长葛市<br>漯河市<br>平顶山市–舞钢市 汝州市<br>南阳市–邓州市<br>信阳市<br>周口市–项城市<br>驻马店市</p><h1 id="湖北省–仙桃市-天门市-潜江市"><a href="#湖北省–仙桃市-天门市-潜江市" class="headerlink" title="湖北省–仙桃市 天门市 潜江市"></a>湖北省–仙桃市 天门市 潜江市</h1><p>武汉市<br>十堰市–丹江口市<br>襄樊市–老河口市 枣阳市 宜城市<br>荆门市–钟祥市<br>孝感市–应城市 安陆市 汉川市<br>黄冈市–麻城市 武穴市<br>鄂州市<br>黄石市–大冶市<br>咸宁市–赤壁市<br>荆州市–石首市 洪湖市 松滋市<br>宜昌市–枝江市 宜都市 当阳市<br>随州市–广水市<br>（恩施土家族苗族自治州）–恩施市 利川市</p><h1 id="湖南省"><a href="#湖南省" class="headerlink" title="湖南省"></a>湖南省</h1><p>长沙市–浏阳市<br>张家界市<br>常德市–津市市<br>益阳市–沅江市<br>岳阳市–汨罗市 临湘市<br>株洲市–醴陵市<br>湘潭市–湘乡市 韶山市<br>衡阳市–常宁市 耒阳市<br>郴州市–资兴市<br>永州市<br>邵阳市–武冈市<br>怀化市–洪江市<br>娄底市–冷水江市 涟源市<br>（湘西土家族苗族自治州）–吉首市</p><h1 id="广东省"><a href="#广东省" class="headerlink" title="广东省"></a>广东省</h1><p>广州市–增城市 从化市<br>清远市–英德市 连州市<br>韶关市–乐昌市 南雄市<br>河源市<br>梅州市–兴宁市<br>潮州市<br>汕头市<br>揭阳市–普宁市<br>汕尾市–陆丰市<br>惠州市<br>东莞市<br>深圳市<br>珠海市<br>中山市<br>江门市–恩平市 台山市 开平市 鹤山市<br>佛山市<br>肇庆市–高要市 四会市<br>云浮市–罗定市<br>阳江市–阳春市<br>茂名市–化州市 信宜市 高州市<br>湛江市–吴川市 廉江市雷州市</p><h1 id="广西壮族自治区"><a href="#广西壮族自治区" class="headerlink" title="广西壮族自治区"></a>广西壮族自治区</h1><p>南宁市<br>桂林市<br>柳州市<br>梧州市–岑溪市<br>贵港市–桂平市<br>玉林市–北流市<br>钦州市<br>北海市<br>防城港市–东兴市<br>崇左市–凭祥市<br>百色市<br>河池市–宜州市<br>来宾市–合山市<br>贺州市</p><h1 id="海南省–文昌市-琼海市-万宁市-五指山市-东方市-儋州市"><a href="#海南省–文昌市-琼海市-万宁市-五指山市-东方市-儋州市" class="headerlink" title="海南省–文昌市 琼海市 万宁市 五指山市 东方市 儋州市"></a>海南省–文昌市 琼海市 万宁市 五指山市 东方市 儋州市</h1><p>海口市<br>三亚市</p><p>四川省<br>成都市–都江堰市 彭州市 邛崃市 崇州市<br>广元市<br>绵阳市–江油市<br>德阳市–什邡市 广汉市 绵竹市<br>南充市–阆中市<br>广安市–华蓥市<br>遂宁市<br>内江市<br>乐山市–峨眉山市<br>自贡市<br>泸州市<br>宜宾市<br>攀枝花市<br>巴中市<br>达州市–万源市<br>资阳市–简阳市<br>眉山市<br>雅安市<br>（凉山彝族自治州）–西昌市</p><h1 id="贵州省"><a href="#贵州省" class="headerlink" title="贵州省"></a>贵州省</h1><p>贵阳市–清镇市<br>六盘水市<br>遵义市–赤水市 仁怀市<br>安顺市<br>（毕节地区）–毕节市<br>（铜仁地区）–铜仁市<br>（黔东南苗族侗族自治州）–凯里市<br>（黔南布依族苗族自治州）–都匀市 福泉市<br>（黔西南布依族苗族自治州）–兴义市</p><h1 id="云南省"><a href="#云南省" class="headerlink" title="云南省"></a>云南省</h1><p>昆明市–安宁市<br>曲靖市–宣威市<br>玉溪市<br>保山市<br>昭通市<br>丽江市<br>思茅市<br>临沧市<br>（德宏傣族景颇族自治州）–潞西市 瑞丽市<br>（大理白族自治州）–大理市<br>（楚雄彝族自治州）–楚雄市<br>（红河哈尼族彝族自治州）–个旧市 开远市<br>（西双版纳傣族自治州）–景洪市</p><h1 id="西藏自治区"><a href="#西藏自治区" class="headerlink" title="西藏自治区"></a>西藏自治区</h1><p>拉萨市<br>（日喀则地区）–日喀则市</p><p>陕西省<br>西安市<br>延安市<br>铜川市<br>渭南市–华阴市 韩城市<br>咸阳市–兴平市<br>宝鸡市<br>汉中市<br>榆林市<br>安康市<br>商洛市</p><h1 id="甘肃省"><a href="#甘肃省" class="headerlink" title="甘肃省"></a>甘肃省</h1><p>兰州市<br>嘉峪关市<br>金昌市<br>白银市<br>天水市<br>武威市<br>酒泉市–玉门市 敦煌市<br>张掖市<br>庆阳市<br>平凉市<br>定西市<br>陇南市<br>（临夏回族自治州）–临夏市<br>（甘南藏族自治州）–合作市</p><h1 id="青海省"><a href="#青海省" class="headerlink" title="青海省"></a>青海省</h1><p>西宁市<br>（海西蒙古族藏族自治州）–德令哈市格尔木市</p><h1 id="宁夏回族自治区"><a href="#宁夏回族自治区" class="headerlink" title="宁夏回族自治区"></a>宁夏回族自治区</h1><p>银川市–灵武市<br>石嘴山市<br>吴忠市–青铜峡市<br>固原市<br>中卫市</p><h1 id="新疆维吾尔自治区–石河子市-阿拉尔市-图木舒克市-五家渠市"><a href="#新疆维吾尔自治区–石河子市-阿拉尔市-图木舒克市-五家渠市" class="headerlink" title="新疆维吾尔自治区–石河子市 阿拉尔市 图木舒克市 五家渠市"></a>新疆维吾尔自治区–石河子市 阿拉尔市 图木舒克市 五家渠市</h1><p>乌鲁木齐市<br>克拉玛依市<br>（喀什地区）–喀什市<br>（阿克苏地区）–阿克苏市<br>（和田地区）–和田市<br>（吐鲁番地区）–吐鲁番市<br>（哈密地区）–哈密市<br>（克孜勒苏柯尔克孜自治州）–阿图什市<br>（博尔塔拉蒙古自治州）–博乐市<br>（昌吉回族自治州）–昌吉市 阜康市 米泉市<br>（巴音郭楞蒙古自治州）–库尔勒市<br>（伊犁哈萨克自治州）–伊宁市 奎屯市<br>（塔城地区）–塔城市 乌苏市<br>（阿勒泰地区）–阿勒泰市</p><p>说要说明的是：1，上面所说的“地极市”中，有几个属于“副省级市”，包括：沈阳、大连、长春、哈尔滨、南京、杭州、宁波、厦门、济南、青岛、武汉、广州、深圳、成都、西安。2，另外，还有几个“计划单列市”：大连、宁波、厦门、青岛、深圳。3，地级市下列的县级市系由省、自治区直辖，地级市代管。</p><h1 id="香港特别行政区"><a href="#香港特别行政区" class="headerlink" title="香港特别行政区"></a>香港特别行政区</h1><p>香港市</p><h1 id="澳门特别行政区"><a href="#澳门特别行政区" class="headerlink" title="澳门特别行政区"></a>澳门特别行政区</h1><p>澳门市</p><h1 id="台湾省"><a href="#台湾省" class="headerlink" title="台湾省"></a>台湾省</h1><p>院辖市：2个：台北市 高雄市<br>省辖市：5个：基隆市 台中市 台南市 新竹市 嘉义市<br>县辖市：31个，包括：<br>台北县下辖8市：板桥市 三重市 中和市 永和市 新庄市 新店市 土城市 芦州市<br>宜兰县下辖1市：宜兰市<br>桃园县下辖4市：中坜市 桃园市 八德市 平镇市<br>新竹县下辖1市：竹北市<br>苗栗县下辖1市：苗栗市<br>台中县下辖2市：丰原市 大里市<br>彰化县下辖2市：彰化市 北斗市<br>南投县下辖1市：南投市<br>云林县下辖1市：斗六市<br>嘉义县下辖2市：朴子市 太保市<br>台南县下辖1市：新营市<br>高雄县下辖2市：凤山市 冈山市<br>屏东县下辖1市：屏东市<br>花莲县下设1市：花莲市<br>台东县下辖1市：台东市<br>澎湖县下辖1市：马公市</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>232个国</title>
      <link href="/2017/04/14/232%E4%B8%AA%E5%9B%BD/"/>
      <url>/2017/04/14/232%E4%B8%AA%E5%9B%BD/</url>
      
        <content type="html"><![CDATA[<p>截止2016年，世界上共有232个国家和地区，其中国家为195个，地区为37个。</p><h1 id="亚洲（Asia）共48个国家和地区。其中48个国家，0个其他地区。"><a href="#亚洲（Asia）共48个国家和地区。其中48个国家，0个其他地区。" class="headerlink" title="亚洲（Asia）共48个国家和地区。其中48个国家，0个其他地区。"></a>亚洲（Asia）共48个国家和地区。其中48个国家，0个其他地区。</h1><p>东亚：中国、蒙古、朝鲜、韩国、日本（5）<br>东南亚：菲律宾、越南、老挝、柬埔寨、缅甸、泰国、马来西亚、文莱、新加坡、印度尼西亚、东帝汶（11）<br>南亚：尼泊尔、不丹、孟加拉国、印度、巴基斯坦、斯里兰卡、马尔代夫（7）<br>中亚：哈萨克斯坦、吉尔吉斯斯坦、塔吉克斯坦、乌兹别克斯坦、土库曼斯坦（5）<br>西亚：阿富汗、伊拉克、伊朗、叙利亚、约旦、黎巴嫩、以色列、巴勒斯坦、沙特阿拉伯、巴林、卡塔尔、科威特、阿拉伯联合酋长国（阿联酋）、阿曼、也门、格鲁吉亚、亚美尼亚、阿塞拜疆、土耳其、塞浦路斯（20）</p><h1 id="欧洲共47个国家和地区。其中44个国家，3个其他地区。"><a href="#欧洲共47个国家和地区。其中44个国家，3个其他地区。" class="headerlink" title="欧洲共47个国家和地区。其中44个国家，3个其他地区。"></a>欧洲共47个国家和地区。其中44个国家，3个其他地区。</h1><p>北欧：芬兰、瑞典、挪威、冰岛、丹麦 、法罗群岛（丹）、海峡群岛（英）（7）<br>东欧：爱沙尼亚、拉脱维亚、立陶宛、白俄罗斯、俄罗斯、乌克兰、摩尔多瓦（7）<br>中欧：波兰、捷克、斯洛伐克、匈牙利、德国、奥地利、瑞士、列支敦士登（8）<br>西欧：英国、爱尔兰、荷兰、比利时、卢森堡、法国、摩纳哥（7）<br>南欧：罗马尼亚、保加利亚、塞尔维亚、马其顿、阿尔巴尼亚、希腊、斯洛文尼亚、克罗地亚、黑山、马耳他、波斯尼亚和黑塞哥维那 、意大利、梵蒂冈、圣马力诺、西班牙、葡萄牙、安道尔、直布罗陀（英、西争议，英国实际控制）、科索沃（19）</p><h1 id="非洲共60个国家和地区。其中54个国家，6个其他地区。"><a href="#非洲共60个国家和地区。其中54个国家，6个其他地区。" class="headerlink" title="非洲共60个国家和地区。其中54个国家，6个其他地区。"></a>非洲共60个国家和地区。其中54个国家，6个其他地区。</h1><p>北非：埃及、利比亚、突尼斯、阿尔及利亚、摩洛哥、亚速尔群岛（葡）、马德拉群岛（葡）、加那利群岛（西）（8）<br>东非：苏丹、南苏丹、埃塞俄比亚、厄立特里亚、索马里、吉布提、肯尼亚、坦桑尼亚、乌干达、卢旺达、布隆迪、塞舌尔（12）<br>中非：乍得、中非、喀麦隆、赤道几内亚、加蓬、刚果共和国（刚果（布））、刚果民主共和国 （刚果（金））、圣多美和普林西比（8）<br>西非：毛里塔尼亚、西撒哈拉（非独立国家）、塞内加尔、冈比亚、马里、布基纳法索、几内亚、几内亚比绍、佛得角、塞拉利昂、利比里亚、科特迪瓦、加纳、多哥、贝宁、尼日尔、尼日利亚（17）<br>南非：赞比亚、安哥拉、津巴布韦、马拉维、莫桑比克、博茨瓦纳、纳米比亚、南非、斯威士兰、莱索托、马达加斯加、科摩罗、毛里求斯、留尼汪岛（法）、圣赫勒拿岛（英）（15）</p><h1 id="北美洲共39个国家和地区。其中23个国家，16个其他地区。"><a href="#北美洲共39个国家和地区。其中23个国家，16个其他地区。" class="headerlink" title="北美洲共39个国家和地区。其中23个国家，16个其他地区。"></a>北美洲共39个国家和地区。其中23个国家，16个其他地区。</h1><p>北美：加拿大、美国、墨西哥、格陵兰（丹）、圣皮埃尔和密克隆（法）（5）<br>中美洲：危地马拉、伯利兹、萨尔瓦多、洪都拉斯、尼加拉瓜、哥斯达黎加、巴拿马（7）<br>加勒比海地区：巴哈马、古巴、牙买加、海地、多米尼加共和国、安提瓜和巴布达、圣基茨和尼维斯、多米尼克、圣卢西亚、圣文森特和格林纳丁斯、格林纳达、巴巴多斯、特立尼达和多巴哥、波多黎各（美）、英属维尔京群岛、美属维尔京群岛、安圭拉（英）、蒙特塞拉特（英）、瓜德罗普（法）、马提尼克（法）、阿鲁巴（荷）、库拉索（荷）、荷属圣马丁、特克斯和凯科斯群岛（英）、开曼群岛（英）、百慕大群岛（英）、法属圣马丁（27）</p><h1 id="南美洲共13个国家和地区。其中12个国家，1个其他地区。"><a href="#南美洲共13个国家和地区。其中12个国家，1个其他地区。" class="headerlink" title="南美洲共13个国家和地区。其中12个国家，1个其他地区。"></a>南美洲共13个国家和地区。其中12个国家，1个其他地区。</h1><p>北部：哥伦比亚、委内瑞拉、圭亚那、法属圭亚那、苏里南（5）<br>中西部：厄瓜多尔、秘鲁、玻利维亚（3）<br>东部：巴西（1）<br>南部：智利、阿根廷、乌拉圭、巴拉圭、马尔维纳斯群岛（福克兰群岛）（英、阿根争议，英国实际控制）（5）</p><h1 id="大洋洲共24个国家和地区。其中14个国家，10个其他地区。"><a href="#大洋洲共24个国家和地区。其中14个国家，10个其他地区。" class="headerlink" title="大洋洲共24个国家和地区。其中14个国家，10个其他地区。"></a>大洋洲共24个国家和地区。其中14个国家，10个其他地区。</h1><p>澳大利亚、新西兰<br>密克罗尼西亚：帕劳、密克罗尼西亚联邦、马绍尔群岛、基里巴斯、瑙鲁、北马里亚纳（美）、关岛（美） （7）<br>美拉尼西亚：巴布亚新几内亚、所罗门群岛、瓦努阿图、斐济群岛、新喀里多尼亚（法）（5）<br>波利尼西亚：图瓦卢、萨摩亚、汤加、库克群岛（新）、纽埃（新）、托克劳（新）、法属波利尼西亚、瓦利斯和富图纳（法）、皮特凯恩群岛（英）、美属萨摩亚（10）</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完全用Linux工作</title>
      <link href="/2016/08/22/%E5%AE%8C%E5%85%A8%E7%94%A8Linux%E5%B7%A5%E4%BD%9C/"/>
      <url>/2016/08/22/%E5%AE%8C%E5%85%A8%E7%94%A8Linux%E5%B7%A5%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>作者：王垠 </p><p>完全用Linux工作，抛弃windows </p><p>我已经半年没有使用 Windows 的方式工作了。Linux 高效的完成了我所有的工作。 </p><p>GNU/Linux 不是每个人都想用的。如果你只需要处理一般的事务，打游戏，那么你不需要了解下面这些了。 </p><p>我不是一个狂热的自由软件份子，虽然我很喜欢自由软件。这篇文章也不是用来推行自由软件运动的，虽然我觉得自由软件运动是非常好的。 </p><p>这篇文章也不是用来比较 Linux 和 Windows 内核效率，文件系统，网络服务的。我现在是作为一个用户而不是一个开发者来说话的，我们的讨论是基于操作，应用层面的。是为了告诉大学里还不了解，或者不理解 UNIX 的科学工作者和大学生，UNIX 比 Windows 更适合用于科学研究工作，请大家理解 UNIX 的工作方式，不要用 Windows 的标准来要求 Linux，而要用一个科学工作者的标准来要求自己，用UNIX 的思想来武装自己。 </p><p>我显然是反对在大学，特别是理工科专业推广 Windows 的。我也反对在对”娃娃”们的计算机启蒙教育中使用 Windows。因为 Windows 不论从技术上，经济上，思想风格上都是与我们培养高科技人才的目标格格不入的。Windows 的流行属于历史遗留问题，爷爷一级的人当然已经不可救药，但是我们不应该让下一代继续走上歧途。 </p><p>UNIX 不是计算机专家的专利 </p><p>当我建议一些非计算机专业的人用 Linux 的时候，很多人说：”UNIX 是计算机系的人用的，我们不能理解。” “UNIX 是男孩用的，我们女孩不用。” </p><p>但是其实世界上的大多数科学家和工程师几乎用的都是 UNIX 作为他们的电脑工具。就因为它简单，可靠，稳定，强大，有趣。甚至很多时候 UNIX 就是唯一的选择。 </p><p>你说：”我们都会用 UNIX 的话，你们计算机专业的人还用来干什么？” 很容幸的告诉你，计算机专业的有一部分人就是专门为你们提供这样强大而方便的计算机工具的。如果他们制造的工具只有自己会用的话，那这个工具还有什么用？ </p><p>理解 GNU/Linux 不要用 Windows 的标准来要求 Linux。 </p><p>由于GNU/Linux这个词太长，下面如果没有特别指明，”Linux”就是指GNU /Linux”。 </p><p>在这个年代，恐怕没有人需要我来介绍 Linux 是什么了吧？如果你觉得”Linux 只不过是跟 DOS 差不多的东西”，那请问问你旁边的 Linux 用户，Linux 到底是什么？ </p><p>那为什么我还要写一篇这样的文章？因为，我发现还有很多人不不理解 Linux 和 UNIX，虽然他们也在用它，但是他们有时会问：”为什么 Linux 不能像 Windows 那样 ……？”，”怎么Redhat Linux不能 mount NTFS 分区！”，”Linux 下用什么整理硬盘？”，”什么时候OpenOffice才能完全兼容Word文件啊？”，”现在还有什么Windows能干的事情Linux干不了的？”…… </p><p>他们有40G的硬盘，却只为 Linux 分配了2G空间，有时还抱怨”这个东西怎么占这么多硬盘！” 似乎 Windows 该占用大部分硬盘。他们把重要的数据装在Windows的分区，似乎信不过Linux。他们总是到处寻找新奇的，好看的GUI程序，对命令行的东西一概不屑一顾。他们对Drag&amp;Drop，菜单配置，自动升级非常感兴趣。他们如果找到一个很像 Windows 程序的 Linux 程序，一定会很高兴的说：”哈哈！Linux 也能……了！”如果Linux在某种测试中胜过Windows，他们会高兴得跳起来。他们没有办法用Linux 解决问题的时候，甚至用Wine来运行Windows程序。有时实在没办法，只好重起到Windows，或者干脆省得麻烦，在 Windows 下装一个 VMWare 虚拟一个 Linux 玩。 </p><p>你如果出现了上面的情况，说明你的思想受到了 Windows 的某种潜移默化的影响和误导。你没有能够从本质上理解存在于 Linux 身上的 UNIX 思想。你支持 Linux，你喜欢 Linux，你能从中感觉到快乐，这非常好。你现在只需要明白的是：Linux 从来就不是一个玩具，它是天才UNIX的后代。UNIX 是自晶体管发明以来最伟大的发明，它从诞生那一天开始就比 Windows 的设计出色。 </p><p>你要体会什么叫做”设计”，一个糟糕的设计并不是到后来缝缝补补就可以变好的，而一个出色的设计，不但可以以不变应万变，而且可以影响到后来者。一个出色的设计配上一个出色的实现，那就是非常出色的发明。Linux 就是这样的一个出色的发明。Linux 并不需要追赶 Windows，也不需要打垮微软。它的最终目标是改变整个计算机世界，还人们自由，给人们乐趣和方便。 </p><p>Unix 是简单的，你不需要成为一个天才也能理解这种简单。 </p><p>UNIX的设计者 Dennis Ritchie 说：”Unix is simple. It just takes a genius to understand its simplicity.” 但是我不这么认为，因为我不是一个天才，但是我却勇敢的把 Windows 完全删除掉，遇到不明白的事情的时候努力用 UNIX 的方式去解决，而不是寻求 Windows 的帮助。现在我体会到了 UNIX 的思想和好处，我可以用比 Windows 高效几倍的效率工作。因为我相信这样的信念：”Windows 能办到的事 Linux 一定能办到，而且办的更好。” </p><p>这小节开头的话应该改成：”Unix 是简单的，你不需要成为一个天才或是计算机专家。但是在这个冲斥着 Windows 错误观念的世界，你需要信念和勇气才能理解它的简单。” 我下面就告诉你一些我理解到的东西。首先，你要知道的是微软在国际科学领域是根本没有地位的。 </p><p>微软的地位 </p><p>微软的名声在欧洲和美国的大学里，特别是在计算机系里之坏，大家可能有所耳闻。我认识的 MIT，Stanford 的教授，贝尔实验室的专家，甚至一个欧洲小国的高中计算机老师都绝口不提微软的名字。在他们眼里，微软只是一个没有真技术，专靠在落后国家商业宣传和垄断经营的小公司。这个”小”并不是说它人少，钱少，而是说它先进技术少。 </p><p>我上次和王益合作写了一个算法演示程序，那个算法是贝尔实验室一位科学家Steven Fortune很天才的发明，为了程序能够被身边大多数人使用，我们选择了 VC+MFC 作为平台。我在分析算法时还得到 Fortune 很热情的鼓励，寄给我一份资料，还多次回信耐心的给我讲解了很多细节。但是程序完成之后，我把样品发给 Fortune，他回信说：”对不起。我机器上没有 MFC。” 话说的很客气，但是我已经感觉到了他对 Windows的不屑。然后我把 MFC 静态编译进程序再发给他，他就没有再回信了。他显然不是瞧不起我，而是确实有难处。 </p><p>你能感觉到这位科学家对微软和 Windows 是什么态度了吧？不是反感，而是他心里根本没有 Windows 这个东西！微软在高科技领域没有发展，那么它怎么生存呢？到发展中国家去发展一下，他们的人民还对电脑一无所知，我说不定甚至可以打入大学的计算机系呢。我送他们软件，我捐钱盖大楼，我出钱找图灵奖获得者来演讲，让他们觉得我们都是科学家！ </p><p>好了，现在全国的大学包括清华，几乎所有人机器必装盗版 Win2000，Office XP，学校的选课系统是非IE不能正确浏览，论文用 Word 编辑，演示用ppt做，email 的通知附件是 doc 文件，你不用 Word 打不开，连 863 项目都用 VC 写程序了。我很久以前就看到一份报纸说，”微软为什么不严厉打击盗版？” 这篇文章说，微软非但不打击中国的盗版行为，而且有放任之趋势。放长线吊大鱼，”以后我要你们加倍的来还我！” 确实如此，它的目的快实现了。 </p><p>Windows 笼罩下的中国计算机教育 </p><p>说句丢脸的话，比尔盖茨很久以前是我的偶像…… //blush </p><p>在中国，比尔盖茨被很多人奉为神圣，”少年电脑天才”，甚至有的人提到他的名字就做出”抱拳对天”的姿势。很多人谈到微软的”新技术”，”高科技” 都是眉飞色舞。各种”VC编程圣经”，”深入了解 Visual C++”之类的书，在开头几页都会出现非常肉麻的字眼，”在那团团的混沌中，一个开天辟地的精灵，Windows 1.0，诞生了……” </p><p>微软的软件被这么多人盗用，那么人们是怎样使用这些盗版程序的呢？先看看电脑培训班，教的都是一些 DOS 命令，打字，Windows 基本操作，Word 文档处理，PowerPoint，高级班可能有 Excel，Access…… 参加各种微软认证考试，MCSE，MSDE 的人络绎不绝。考试辅导班都贴出了”280元，考过为止”之类的字样。考试参考资料更是昂贵，有些电脑书店整整两书架都是”Microsoft Press”的东西。我有个同学参加认证考试，每门考试都要200多元。而且你一次考不过可以再考，又要交钱。他后来还津津乐道跟我说，看我，花了 XXXX(一个四位数)元考过了微软认证，得到一张比尔盖茨亲笔签名的证书和价值6000元的 Windows XP 内部发行版。 </p><p>“电脑要从娃娃抓起”，我们再来看看娃娃们学的是什么。大部分家长给孩子买了电脑之后，他们首先就会装一个盗版的 Windows，然后买来盗版的游戏开始玩。如果哪个孩子会用 Delphi 编程序，那可不得了。报社记者，电视台争相报导，说，某某学校的初中生某某，在别人都还在玩电脑游戏这种”初级阶段”的时候就已经用 Delphi 写程序了。镜头还瞄准了他显示器上面的像框中的比尔盖茨头像！ </p><p>我刚进入大学计算机系时还不懂得什么是操作系统，因为我以前只用过”中华学习机”。看到新入学的同学们各个谈论的都是 “Windows 95”，”VC”…… 我简直觉得我落后了好几十年一样，整个一土人，根本跟他们答不上话。好不容易找到一个比较熟的同学问了一下：”你们天天谈论的瘟95是什么啊？” 答：”win95就是一个操作系统，跟DOS是一类。””朵死是什么？” “你连DOS都不知道是什么？别在计算机系混了。” 学校上课当然不讲VC编程之类的东西，但是上 Pascal 的老师有一次就说：”嗨，我们学校真是落后。现在别人都用 C, C++，甚至 VC 了，我们还在讲 Pascal。不知道什么时候才能有VC课啊。你们出去也是要用VC的，只好自学了。” 于是，有些同学很多时候上课都捧着一本很重的”Windows 编程大全”之类的书，根本没有听课。吃饭时就念念有词的跟我说，”代码的优化是无止境的”，”匈牙利命名法真是伟大的发明” …… 这就是中国很多大学计算机系的情况。 </p><p>感觉到无知了？这不是偶然的，而是微软长久以来埋下的伏笔。它要让无知的大家都把它奉为神圣，它要让支持UNIX，Xwindow的人一旦说 UNIX 好，Xwindow 好的时候，都被一群人围着说教：”这个 Windows 也能做到”，”你对 Windows 有偏见”，”微软才是主流啊”，”你敢瞧不起 win2k？”，”.NET 就是世界潮流”，”微软的毕竟是新技术”，”有钱就是有技术”…… 甚至在一番论战比较后败下来还是要说：”Windows 性能差点，但是易用性强”，”Windows 是老百姓用的，要求别那么?quot;，”微软那么有钱，以后想超过 UNIX 还不容易吗？”…… </p><p>发达国家的计算机教育 </p><p>我前段时间在 USENET 发文问有关 Scheme 语言的问题时，认识了一位丹麦人。他解决了我所有的问题，并且建议我阅读一些很”深奥”的有关程序语言语法，文法的书，他告诉我很多网站可以学习 LISP，Scheme，人工智能，算法。他叫我看 Jonathan Rees 的论文 “Syntactic Closures”。他还打包给我寄过来一份 MIT 的 “How to Design Programs”。他说他在自己的 PC 机上装的是 Linux，他用 Emacs 编辑，运行Scheme 程序。他对 Emacs 的了解和爱好真是使人惊讶。他大学本科毕业时做的毕业设计是一个 Scheme 解释器。这对于我来说是望尘末及了。 </p><p>他是那么的不厌其烦，我的每一个问题他都详细的回答。我有时都觉得过于详细了，怎么这么耐心啊？我觉得他似乎是我的高中老师。他是什么样的人呢？我好奇的打听了他的情况。原来，他是丹麦一所普通高中的计算机老师。 </p><p>他说他在高中里讲授程序设计和算法，计算机语言文法。他说用 Scheme，他的学生不用再为内存泄漏等程序语言本身的问题而烦恼，而专注于问题和算法本身。有利于培养学生解决问题的能力，特别是用计算机解决数学问题的能力。 </p><p>天哪！为什么欧洲出现那么多数学家，几何学家？你看看别人重视的是什么！我们的计算机教育如果继续这样下去，只会沿着弯路越走越远！ </p><p>微软和它的朋友们的如意算盘 </p><p>下面来看看微软的收入是怎么来的。首先，Windows 98系列操作系统，一个就是 100多美元，每次升级又是几乎同样的价钱。Windows NT 还要贵几倍，而且有用户数目限制，5个用户的，10个用户的…… 以后如果要增加用户数目还要按比例付钱。 </p><p>花了如此多钱买来的操作系统就能用了吗？它竟然连压缩程序都没有提供！你装上Windows 之后一般第一件事就是去下载一个 WinZip 吧，”只要 29 美元”。Windows会中病毒啊，马上花 70 美元买一个 Norton AntiVirus 吧。还有黑客呢？再买一个Norton Internet Security 好了，100 美元。系统需要优化，磁盘需要整理，买一个Norton System Works 是你最佳的解决方案，100美元。 </p><p>可是你现在还是不能干正事啊！你想要一个 Word, PowerPoint？那就买一套 Office XP 吧，一起买便宜些，$459.90。 </p><p>那些程序不会用啊！那些菜单怎么设置，到底有什么功能啊？看”帮助”也学不会。买本书看看吧，我推荐”Special Edition Using Microsoft Office XP”，不贵，$27.99。这本书里面大部分是屏幕抓图，还是买一本旧的比较划算，$17.85。 </p><p>你如果只是当个秘书，上面的差不多还凑合了。可是你有更高的追求，你想成为 Windows程序员。首先买一个 Visual Studio.NET 吧，要不然怎么编译程序。$494.95。 </p><p>为了紧跟微软动向，世界潮流，不能不注册个 MSDN 什么的吧？这个贵一点，不过物有所值啊，$2,799。 </p><p>嗯，你现在已经是上层阶级，白领人士了。你现在可以像这样”自由”的，”安全”的生活了。 </p><p>为什么要反对使用 Windows </p><p>很多人都说不应该完全否定 Window，Windows 也有它的长处。不应该骂微软。 </p><p>对。Windows 容易操作，适合普通用户。如果微软把它自己定位在 P&amp;G，Philips 那样的地位，能够给我们的百姓提供周到的，完善的，价廉物美的服务。那我肯定是很喜欢它的。但是从上面的种种情况说明，微软是一个野心极大的国际垄断组织！它的产品没有一个是不出问题的：Windows 不稳定，容易中病毒，而微软不为大家免费提供杀毒软件。我就是要让你们花钱买我的朋友 Symantec 的杀毒软件，谁叫你们已经上了我的贼船？这叫什么售后服务啊！ </p><p>你买来微软的程序，安装的时候一般都有一个协议，说：”由于微软的程序造成你的数据损坏或丢失，微软概不负责。” 我想很多人肯定觉得这个不合理，不想按那个 “I accept”。但是你的软件买都买来了，钱都花了，现在一按 “I decline”，安装程序马上就会退出。你只好被迫点击了 “I accept”！这不是不平等条约吗？ </p><p>我已经目睹了好几个朋友的文档被 Microsoft Word 损坏，有的是编辑了十多天的30多页的论文，有的是费了很大工夫做出来的个人简历，那个朋友为此失去了到自己向往的P&amp;G 工作的机会。就在他要投简历的前一个晚上，就在那一瞬间…… 不知道他痛哭的时候有没有想起要投诉微软，可是谁叫我们用的都是盗版呢，况且你还点击了 “I accept”。 </p><p>微软仗势已经占有大部分PC市场，制定不符合国际标准的”微软的标准”，以不合理的方式压制其它公司的软件，这个问题已经在美国司法部闹了很久了。他甚至在 Windows系列操作系统中放置能够通过网络泄漏用户信息的代码，以至于 Windows 刚进入澳大利亚时被澳大利亚政府禁止使用。 </p><p>有些人说：”微软毕竟开创了一个历史，造就了今天的 IT 行业。” 但是，如果没有微软，我们今天早就用上非常稳定，非常可靠，非常方便，非常”傻瓜”的软件了！微软是阻挡信息技术发展的罪魁祸首。 </p><p>微软的程序的工作方式(注意，我只是说操作方式，病毒的事情另外算)确实适合于一般家庭，上上网，发发邮件，打打游戏都不错。可是微软却要把自己包装成什么”高科技”企业，要在世界各地设置”研究院”，在大学计算机系赠送不适合用于科研的 Windows产品，甚至出钱请图灵奖得主来中国畅谈”二十一世纪的计算”，还在大会上宣传自己的 .NET 技术。非要把别人认为自己是科学的，自己是领导世界高科技的。但是呢？它什么高科技也没有。欧洲，美国，哪一个关键部门在用微软的东西？NASA? DOE? CERN?你仔细想一想，微软的程序对人类到底有什么重大作用？ </p><p>什么是 Windows 能干而 Linux 干不了的事情？— </p><p>“Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。” </p><p>有个朋友看我半年没有用 Windows，有时就会问我：”你只用 Linux，有没有发现有些Windows 能处理的事情 Linux 干不了？”— </p><p>我回答说：”Windows 能干而 Linux 干不了的事情，那就是不需要干的事情。” </p><p>Windows 能做的有益的事情 Linux 都能做— </p><p>Windows 下的某些功能确实是我们需要的，那么 Linux 的开发者们和用户也需要这种功能，他们就会去实现这种功能，而且比 Windows 的方式好得多。由于大多数科学家，工程师用的都是 Linux 或者某种商业 UNIX, 所以几乎所有商业的科学工程程序，比如Matlab, Mathematica, AutoCAD, Candence的，Synopsys的，Avant! 的……全都是先有UNIX 的版本(包括Linux)，然后再考虑移植给 Windows，甚至根本不移植给Windows，因为 Windows 的机器一般没有足够的能力运行这样的程序。你不要以为只有 Windows 才有 PSpice, UNIX 的 HSpice 要好得多，而且可以运行在大型主机上。当然它们不是免费的，但是它们值那个价钱。 </p><p>但是 Windows 下有些东西在 Linux 下没有很相似的，或者你找到很多类似的，但是它们每一个比起 Windows 的那个程序都要差很多，那么原因有两种可能性： </p><p>有一个完全类似的程序，但是由于它乍一看不漂亮，被你忽略了。而其它程序虽然看起来很漂亮，但是它们是一些初学编程的人写的。现在由于 Gtk, Qt 的诞生，Linux 下开发图形界面程序极其简单，很多初中生甚至小学生都可以随手编出一些漂亮不中用的程序。如果你整天寻找这样的程序挑来挑去，永远也找不到你满意的。当然也有一流的程序用 Gtk 和 Qt，比如 GVIM 就可以用 Gtk 作为图形界面，我还知道 Synopsys 一些程序用了 Qt。 </p><p>我曾经也犯过这样的错误，从外表区分一切。结果优秀的 FVWM, lftp, Mutt, wget 都被我忽略过。当我找回它们的时候，我是那么的羞愧不已，它们现在都是我的朋友 我第一次看到 FVWM 觉得它只不过是一个有很厚很难看边框的东西。可是现在，我的同学看到 FVWM 都说：”哇！真漂亮。” </p><p>有另一种完全不同的方式可以达到相同的目的，甚至更好。 </p><p>很多人很关心 Open Office, Star Office, AbiWord, … 他们多么盼望有一天某一个Linux 程序能够完全兼容的打开一个复杂的 doc 文档。但是你永远也不可能有那一天。为什么呢？因为微软为了占有市场，必定不会让其它系统的程序能够完全兼容它的文档格式。它一定会不断变化 doc 文档的内部结构，隐藏一些秘密，让其它公司的程序打开 doc 文档时总是有某种问题，从而你必需购买 Microsoft Office 和 Windows。 </p><p>你应该想一下，那么多的高智商的大学教授，科学家，学生，他们用的都是 Linux 或者其它类型的 UNIX，他们没有 Word 可用，怎么处理文档呢？这么多年没有一个像Open Office 的程序出现，难道大家没有办法写文档吗？ </p><p>显然不是这样。你看看那些高水平的学术杂志，论文，那些大学教授的网页，那些漂亮的幻灯片，它们是什么做的？原来 UNIX 用户早就有非常方便的 troff, LaTeX, SGML等东西可以处理文档，而且它们比起 Word 都要高明的多。Word 显然被这些大拿忽略了，以至于很久以来没有人想在 Linux 下开发一个类似 Word 的程序，除非某些公司想抢微软的饭碗。 </p><p>很多人留着 Windows 在硬盘上的原因无非是为了用 Word 和 PowerPoint。我见过一个教授，他的 Windows 笔记本电脑上除了 PowerPoint 什么都没有。有一天演示的时候，他指着堆乱字符说：”对不起，这是一个公式……怎么每次都是这样……” 其实有比PowerPoint 好几百倍的东西可以制造幻灯片，你可以用最简单的方法制造世界一流效果的论文和幻灯片。你待会儿可以看看我的TeX网页，你就会知道为什么我可以完全离开 Windows。 </p><p>Windows 能做的那些没用的事情 Linux 永远做不好 </p><p>电脑游戏 </p><p>有些人说 Linux 下不能玩 Windows 下所能得到的所有游戏。的确，Linux 下虽然也有少量的游戏，比如 Quake。但是它没有 Counter Strike, 没有 Star Craft, …… </p><p>并不是说电脑游戏不该玩，但是应该适可而止。电脑是用来处理事务，帮助你学习，解决问题的工具，而不是一个玩具！整天沉迷于电脑游戏中，而不出去感觉外面的世界，你会变得越来越冷酷，越来越缺乏人情味。你与真实的世界越来越远。 </p><p>你可以在 CS 里杀人，你可以在 Tomb Raider 里探险，你甚至可以在 Tony Hawk’s Pro Skaters 里滑板…… 但是 It’s not real！你虽然有很高的”反恐技巧”，但是遇到歹徒的时候，你是那么的怯懦；你虽然控制 Laura 伸手敏捷，但是你打篮球的时候怎么总是被人断球？你虽然可以轻易的在 THPS 里作出一个 “360 kickflip to hangten grind to fakie”，但是你踩在自己的滑板上的时候还不会 ollie！ </p><p>说回来，如果你偶尔玩一下电脑游戏未尝不可。但是世界上有远比 Windows + PC 更好的游戏方式。Sony 的 PlayStation2, SEGA 的 DreamCast, Nintendo 的 N64，Namco的街机……每一个都比 Windows 游戏精彩，每一个都有如此高的3D性能，以至于Pentium4, Itanium + GForce4 都无法与它们比美！ </p><p>Linux 的用户们都是关心解决世界的关键问题的份子，他们哪里有时间用自己的机器来玩游戏啊？他们每天用Linux高效的做完自己的工作就到阳光下享受自然去了。要玩游戏也是玩一些类似推箱子，贪吃蛇之类的智力小游戏。所以，你知道为什么 Linux 几乎没有游戏了吧？ </p><p>“整理硬盘，优化系统” </p><p>这是一个非常有意思的话题，仅次于有关”病毒”的话题。相信很多 Windows 用户都有整理硬盘的经历。在很多 Windows 用户眼里，”硬盘用久了，会出现碎片，速度会减慢，需要一个程序来整理，整理硬盘的时候不要做其它工作”，这好像是天经地义的事情。 </p><p>我也曾经津津有味的看着 Norton Defrag 一点一点的把我的硬盘排序，调整，用图形的方式显示出来，然后报告?quot;100% 没有碎片。你的硬盘现在已经达到最佳状态。” 我现在才发觉我那时是多么的幼稚。 </p><p>Linux 和 UNIX 用户似乎从来没有”整理硬盘”这种说法呢？你觉得很奇怪吗？如果你觉得很奇怪，那说明你的思想在某种程度上被微软的垃圾程序禁锢了。你需要明白，UNIX 的大型主机很多必须是一天24小时，一年365又1/4天不停运转的，要是每个星期都要整理一次硬盘，在整理的时候几乎不能干任何事情，那是绝对行不通的！ </p><p>Linux 机器根本不用整理硬盘，这就是为什么没有看到过 Linux 用户整理硬盘。Linux 的文件系统是比 Windows 的 FAT, FAT32, NTFS 高明得多的文件系统，它们不但可以对文件设置权限，实施完全的保护，而且可以”越用越整齐”，”越用碎片越少”！你应该把文件大部分放在 Linux 的分区，而不是 Windows 分区，因为它比 Windows分区可靠得多。 </p><p>还有更滑稽的事情就是有很多”Norton System Doctor”，”Windows 优化大师”，”超级兔仔注册表魔法” 之类的程序存在，而且价格昂贵。似乎一个操作系统本来应该有很多问题，需要别的厂商做程序来”优化”它，而且为了得到优化，你需要付钱！这些问题 Linux 根本就没有，所以不需要什么优化。Linux 内核本身就是高度优化的。 </p><p>IDE </p><p>有些人在抱怨为什么 Linux 没有一个良好的 IDE 开发环境。Linux 现在已经有一些IDE 了，但是总是有很多问题。你是不是正在寻找，正在期望 Linux 某一天可以有一个VC那样的开发环境？你有没有发现你正在进入微软给你设下的怪圈？你为什么一定要用 IDE？你说：”IDE 开发迅速，调试方便，适合大型程序……” 那说明微软的程序在你脑子里已经比较根深蒂固，你需要好好清醒一下了，看看我来告诉你。 </p><p>高明的 UNIX 程序员不用 IDE，IDE 从来就是给初级 Windows 程序员用的。 </p><p>你看看大型的 UNIX 程序，包括 Linux 内核，各种网络服务程序，Xwindow 程序在内，哪一个是 IDE 搞出来的？我们实验室的 EDA 程序也没有一个是 IDE 弄的，我还知道Candence, Synopsys，Mentor 的高性能的图形界面 EDA 程序也都不是 IDE 写的。你信不信，微软的人在写 Windows 本身的时候也根本不用 IDE。微软内部程序员最喜欢的编辑器其实是 VIM，用 VIM 的微软程序员上次向乌干达的可怜儿童捐助了1000多美元，这是值得称赞的。 </p><p>有一次某杂志采访一些出名的 Linux 内核程序员，包括 Linus 在内，没有一个人用IDE，有的人用 VIM，有的用 Emacs，只有 Linus 说”GNU Emacs is evil”，但是其实他用的是一种跟 Emacs 有同样键绑定功能的 MicroEmacs。大家都是用编辑器编辑了程序文件，然后用 make 这样的自动工具调用 gcc 编译器完成编译工作的。甚至高级的 Windows 程序员也不用 IDE，他们可以从命令行调用 cl，nmake 来编译自己的程序。虽然这样的 Windows 程序员很少，但是他们却是最了解 Windows，最高明的Windows 程序员。 </p><p>为什么 UNIX 程序员不用 IDE？明白了这个道理你就能体会到 UNIX 的设计思想了。首先，一个 IDE 集成了编辑器，编译器，汇编器，调试器，跟踪器…… 这个编辑器功能肯定比不上 VIM 或 Emacs，编译器比不上 GCC，汇编器比不上 as，调试器比不上 gdb，ddd, 跟踪器比不上 strace, ltrace, truss。你得到的是一套整合的低能的程序。如果你对调试器的功能不满意，你只好换用另外一套 IDE，但是这套 IDE 的热键，菜单，编辑器功能，按钮…… 跟原来那个有很大不同。你不得不花很多时间来熟悉新的环境，而不能保持原来的某些东西。 </p><p>而在 UNIX 下就不一样了。你可以用你最喜欢的 VIM 编辑程序，你在 VIM 里可以调用GNU make，make 可以调用 gcc, ld, … make 的出错信息可以被 VIM 捕获，VIM 能帮你在源程序里定位。你如果喜欢 icc, 你可以让 make 用 icc 而不是 gcc。你如果觉得 gdb 跟踪变量时比较麻烦，你可以用 ddd 来显示各种数据结构之间的关系。你还可以在 Emacs 里调用 gdb，那样就可以同步显示源代码了。而且 VIM 和 Emacs 还可以编辑很多其它东西，比如信件，LaTeX 文档，HTML，配置文件…… 你不用另外找一个什么编辑器来干这些杂活了。很多程序比如 Mutt, tin 都可以在内部使用 VIM，这样就更方便了。实际上 make 在其它方面还能帮你很多忙，我的每一个比较大型的 LaTeX文档都是用 make 维护的。 </p><p>Linux 能干的高精尖的事情 Windows 都干不了 </p><p>当然有很多事情是Linux/UNIX的专利了。因为 Windows 只能装在 PC 机上，好像以前也有 Alpha 可以使用 Windows NT，但是就是没见到有人用。PC 机的能力是很低的，像我们编程序处理 NP-Hard 问题的人，用 Windows 的机器显然速度不够，而且有时一个问题算上几天甚至几个星期，Windows 机器是以”死机”著称的，我们怎么能放心？所以几乎所有科学计算程序，EDA 程序，高性能图像处理程序都不是 Windows 的。他们有时也会移植一些给 Windows，但是常常降低那些程序的能力。你比较过 Windows 版本的 Mathematica 和 Linux 的有什么区别吗？ </p><p>IBM 制造的最大的并行计算机有 8000 多个处理器，Windows 不可能有能力管理这么多处理器，它用的是什么操作系统？答案是 Linux。 </p><p>《泰坦尼克号》电影里的三维动画，那么细腻逼真，Windows机器能做出来吗？不行。那也是 Linux 机器做的。 </p><p>民航总局用来训练地情人员的虚拟现实训练设备，Windows 当然无能为力。那都是商业的 IRIX 机器。 </p><p>UNIX 是最早支持 TCP/IP 网络协议的系统。它上面有很多可以互相协作的网络服务程序，它们经过多年的使用和修订，已经达到比较完善的程度。而就在1997年，微软的比尔盖茨还在扬言：”Internet 是没有前途的。” 微软的这个”远见卓识”大家应该都已见识，它后来加上的网络服务程序IIS漏洞之多，让公安部都频频发出警报，大家也是见识了的。 </p><p>其实你知道了，Windows 没有一样有用的事情能比 UNIX 干的更好。 </p><p>Linux 干不了的有用的事情 Windows 照样干不了 </p><p>当然 Linux 不是万能的。它也有不能干的事情，电脑也有干不了的事情。但是 Linux干不了的事情，Windows 肯定也干不了。这些事情就是我们需要探索，需要努力的事情了。在你探索的过程中，Linux 必定是你的好伙伴。 </p><p>不要把Linux和Xwindow掩盖起来！不要把我们的用户当成傻瓜。 </p><p>什么？你早就知道 Windows 是垃圾？噢！你怎么不早说呢！害我废话这么多。嘿嘿。 </p><p>“好了。你知道 Windows 是垃圾，你现在用什么?quot; </p><p>“Linux + Xwindow” </p><p>“那我问你，Xwindow 是什么样的？” </p><p>“不就是跟 Windows 差不多吗？只不过 ‘Start’ 按钮比较方，而且上面不是一个Windows 标志，而是一个脚丫子。点击一下居然还有很漂亮的中文菜单。我喜欢！” </p><p>“你知道什么是’根窗口’吗？” </p><p>“不知道。从来没听说过呢？” </p><p>“根窗口就是遮盖整个屏幕的那个最大的窗口。” </p><p>“哪儿有什么窗口啊！我没有看到呢？” </p><p>你发现了问题吗？这些 Linux 用户说是在用 Linux 和 Xwindow，但是他们对 Linux和 Xwindow 几乎完全不了解。很多人用了那么久 Xwindow 都不知道根窗口是什么东西，不知道其实按钮也是窗口，不知道窗口管理器和其它程序有什么关系，大家都以为窗口上面的按钮是程序自己放上去的，不知道窗口?quot;class name”，”resource name”是什么东西。他们也不知道 .Xdefaults 是用来干什么的。特别是他们很多人都不知道 Xwindow 的字体是如何命名的，什么是 fontset，有了一个新的字体也不知道怎么安装。 </p><p>他们被遮在 Linux 之上的一层一层的包装迷惑了，他们等待有图形界面的工具来帮助完成一切事情，他们认为 Linux 跟 Windows 一样，只是麻烦一点。他们知道 Linux内核很好，但是他们感觉不到 Linux 和 Xwindow 在操作层面的天生的先进性，随后不久就把 Linux 完全删除掉了。你发现没有，要用户理解 UNIX 和 Xwindow 的操作层面的先进性，才是留住用户的最好办法。如果用户体会不到操作时的方便和高效，内核再好他们也不会理会。 </p><p>但是用摹仿 Windows 的作法来吸引用户，永远会失败的。因为 Linux 如果摹仿Windows那一套低效率的方式，那么 Linux 的这套”低效率方式”永远比不上Windows 的那一套”低效率方式”。那么用户就会说：”这个 Linux，没有一样比的上 Windows。” </p><p>Linux 天生就是继承了 UNIX 的高效的工作方式，为什么我们要把它掩盖起来？我们为什么只告诉用户 KDE 的菜单怎么用？我们为什么不能像早期的 Xwindow 书籍那样第一节就告诉用户什么是 X server, 什么是 X client，什么是 Window Manager, 什么是根窗口。第二章就告诉用户窗口有哪些属性，什么是 classname, resource name, hint，怎样使用 .Xdefaults, xrdb …… </p><p>在这里我又不得不说一下那些 Linux 的发行公司和写书的人，他们把 Linux 和Xwindow 包装起来，却没有从基本上告诉用户 Xwindow 的工作原理。很多书籍讲授的层次就是在Gnome, KDE 的菜单操作的层次，靠大量抓图来占篇幅，”繁荣”Linux 书籍市场。 </p><p>现在很多人已经把能够利用别人的库写出一个好看的程序作为自己编程水平的象征。在这?quot;图形化”，”可视化” 的年代，你如果还在用 troff, LaTeX 写文档，你还在用VIM 自己编辑 HTML，用 Mutt 处理邮件，你还在用文本模式的 gdb 调试程序，你还在用Xlib 写程序, 你还在用 tin 上 USENET，你还在自己写 Makefile，写机器代码，你还在玩 Clossal Cave 这样的字符模式冒险游戏，那你就是老古董。 </p><p>其实这种思想是错误的。虽然你是一个坚决的 Linux 支持者，但是你的思想是 Windows的思想。你认为图形界面，菜单，按钮就可以解决一切问题，就可以给你高效方便。你还是没能摆脱微软给你的潜移默化的东西。你其实离不开 Windows 那样的环境，你迟早会删掉自己的 Linux。 </p><p>GUI vs. CLI </p><p>做一个坚定不移的”两面派” </p><p>大家看到这个标题是不是热血沸腾？两派大虾都可以围攻我了： </p><p>GUI派用户：”哇！我一看你这小子就是 CLI 的。要不然自己写什么 Makefile？用什么Mutt？” </p><p>CLI派用户：”切～ 你还用 X！高手都不用 X。你是 GUI 那边的。” </p><p>可怜的我：”555～～ 你们都不要我～～ GUI 和 CLI 就那么水火不容吗？” </p><p>计算机界这样的门派之分还很多。很有特点的就是 CLI 和 GUI 了。CLI (Command LIne)的狂热份子声称永远不用 X。我上次在实验室看到一个同学用一个 SecureCRT 登录到Sun 机器，然后用一个 vanilla vi 编辑程序，我建议他启动一个 GVIM 过来显示在Exceed 上可以有语法加亮。但是他坚决反对，说：”高手不用X。你想想，要是我在一个很慢的网络连接怎么用 X？而且好多服务器没有装 X 程序。” </p><p>但是我们实验室的网速可够快，Windows 机器都有 Exceed 啊，而且 Sun 机器有全套X 客户程序包括 GVIM。他说他是 CLI 的坚决拥护者，但是他却在用 Windows，他后来打开了好几个 SecureCRT，每次从文本框输入地址，用户名和密码，从下拉菜单选择”SSH2”，然后点击”Connnect”。他还不断的夸SecureCRT 是”网络管理员投票选出的最受欢迎的登录方式”。老天，SecureCRT 本身就是个 GUI 啊，他其实没有明白Xwindow 的好处。 </p><p>你说我是 GUI 的？我虽然很少在 console 下工作。但是我对 bash, VIM 很熟悉，我可以让 bash 按照我的键绑定方式来工作。我可以在 rxvt 里使用 Mutt 来收发 email。我的每个桌面上都常常堆放着一打不同大小的 rxvt。我用 VIM 编辑 LaTeX。我自己写Makefile 来维护 LaTeX 文档。我有时用 mpg321 来放 mp3。我上BBS用的我自己写的expect 脚本。 好了，CLI 派的朋友可以收我做盟友了 </p><p>你说我是 CLI 的老古董？我的 FVWM 被我配置为可以”手写操作”，我只要画一个”r”就可以启动 rxvt，我只要画一个 “U” 就可以启动 GVIM，…… 我用 GVIM 语法加亮模式编辑程序，我用 Mozilla 浏览网页，…… GUI 派的现在好像认我做朋友了 </p><p>好了。CLI 派的朋友，虽然我很喜欢命令行，但是我有时在屏幕上左右画一下就可以执行: </p><p>Module FvwmConsole -terminal rxvt -geometry 45x5-0+0 -bg gold -fg midnightblue -fn “-adobe-courier-medium-r-<em>-</em>-14-<em>-</em>-<em>-</em>-<em>-</em>-*” </p><p>你是不是现在又想把我逐出师门？ </p><p>GUI 派的朋友，虽然我很喜欢窗口。但是我可以在 FvwmConsole 里输入： </p><p>All (rxvt) MoveToDesk </p><p>把我所有的 rxvt 移动到我现在工作的桌面。”这家伙，怎么这么快就叛变了！” </p><p>其实何必分什么 GUI 和 CLI，UNIX 和 Xwindow 都是工业标准，它们从设计那天开始就有非常灵活的用法，各个程序，不管是 GUI 还是命令行的都可以互相协作。UNIX 和X 是一家，何必搞的那么偏激，非此即彼？你从我上面的行为可以看出 GUI 和 CLI的模糊界线吗？我就是坚定不移的”两面派”。 </p><p>UNIX 是简单的– </p><p>“我相信简单就是最好，如果太复杂，我是不能理解的。” -Seymour Cray </p><p>很多第一次用 Linux 的人会惊奇的发现，Linux 的程序居然不?quot;安装”就可以运行，程序拷贝到随便那个目录都可以用，而不是一定要占用你第一个分区的空间。程序的设置只是一些简简单单的文本文件。你根本不需要什么”注册表修改器” 就可以改变系统的设置。这就叫做简单，但是简单就是美。虽然这只是 UNIX 简单性的一个肤浅的认识，你已经体会到了某些东西。 </p><p>但是简单并不意味着功能弱，并不意味着落后。相反，简单意味着强大，意味着生命力。 </p><p>我不会再继续阐述我理解到的”UNIX 的简单”，因为这个需要自己去体会。 </p><p>UNIX 是永恒的 </p><p>有人说：”Plan9 会取代 UNIX，Mach 会取代 Linux 内核。” </p><p>但是你如果是一个深入体会了 UNIX 的人，你就会知道：UNIX 的思想是永恒的，不管时过境迁，Plan9 是否代替 UNIX，UNIX 的灵魂都会在 Plan9 身上现形！ </p><p>我为同一个设备写过 Linux 内核和 Windows VxD 驱动程序。写 Linux 驱动程序时，我对 UNIX 设计的完美的一致性，远见性所折服。UNIX 用同样界面的 read(), write()系统调用就可以对不同的对象：普通文件，设备文件，管道，管道文件，socket，……进行统一的读写操作。我跟本不需要写一个测试用的应用程序就可以对我的设备驱动进行测试，因为 cat, cp, dd, 它们也使用了同样的 read(), write()，设备和普通文件在应用程序眼里没有区别。在那个还没有 Smalltalk, 没有 C++ 的年代，UNIX 的设计者已经使用了所谓的 “面向对象方法”。对，C 语言也可以实现面向对象。 </p><p>UNIX 的系统调用几十年都没有很大变化，这非但不是顽固，不进步的象征，反而是UNIX 的远见卓识的体现！这就跟 TeX 程序几十年都不变的情况差不多。这些才是真正的永恒的 master piece! 你应该改变所有软件都必需从 0.1, 1.0, 1.1, 1.2, 2.0,…, 3.0, 3.1, 95, 98, 2000, XP, … 不断升级的想法。 </p><p>Windows 就不同了，它在最开头只是一个 DOS 之上的图形包装而已。后来为了兼容以前的糟糕设计，不得不加上很多累赘。我写 VxD 驱动程序的时候就深有体会，Windows 95 程序对设备的操作只有用 DeviceIoControl，我不得不写了两个应用程序来对设备驱动进行测试。Windows 内核的不一致性和隐密性使我非常恼火。不过 Windows WDM驱动程序现在也有了 ReadFile, WriteFile，…… 那说明什么？那说明 Windows 在向UNIX 学习，或者有可能是某个 UNIX 设计人员在微软打了几天临工，顺手加了几个UNIX 的东西进去。这样做是没有用的，Windows 从一开始就是非常糟糕的设计，它的历史的包袱太沉重了，缝缝补补有什么用？它只能永远的被 UNIX 甩在身后！ </p><p>UNIX 是强大的 </p><p>让聪明人干任何他们想干的事情。 </p><p>UNIX 的一个特点就是非常高的灵活性，Xwindow 也具有这种灵活性。这种灵活性体现在哪里呢？ </p><p>UNIX 的程序一般都有很多参数，不管你现在用的着用不着，总有人需要某些参数。它们的行为很多都可以用配置文件来改变。比如 GNU bash, 通常缺省的命令行输入方式是 Emacs 方式，但是只要我编辑一个 .inputrc 文件，就可以把它变成 vi 的输入方式，而且我还可以自己绑定键序列到某些操作。我可以用 shopt 来设置它的很多特点，比如是否进行通配符扩展，是否可以把一个变量当作一个目录来cd，是否可以自动纠正某些明显的目录名打字错误 …… </p><p>UNIX 程序设计的思想是提供给用户”机制”，而不限制用户制定”政策”。这是一个重要的尊重用户的作法。 </p><p>我们再来看看 Xwindow。Xwindow 是一个出色的设计，它把显示服务器和客户程序分开。一个显示上既可以显示本机上的程序，也可以显示别的机器上的 X 程序，而它们都遵守你的窗口管理器的统一指挥，它们之间可以方便的传送剪贴版数据，各种事件 …… 比如有时我的 XFree86 上会出现四个不同机器上的 XTerm，两个不同机器上的 GVIM，…… 它们统一受本机上的 FVWM 指挥。 </p><p>Xwindow 程序都具有很多很多命令行参数和 resource 参数。你可以随意的在命令行或者 .Xdefaults 文件设置所有的颜色，字体，尺寸…… 而且如果你用 xrdb 把 .Xdefaults 导入到根窗口，那么其它机器上没有经过配置的同样的程序，显示到你的机器上的时候也会遵守同样的外观规定。 </p><p>Xwindow 的窗口具有 Property, 也就是一些可以自己定义的共享数据(原子)。正是因为这些 Property 的存在，使得 Xwindow 具有无比强大的生命力。X 的窗口管理器和其它客户程序之间并没有统一的协议，但是后来出现了 ICCCM(客户程序间通信规范)，这个规范就是通过 property 定义的。现在又有人定义了一套”扩展的窗口协议(EWM Hints)”，使得Xwindow 可以具有某些 Windows 的特征，比如一个工具条程序可以告诉窗口管理器：”这个屏幕下面被我占据了24个像素的空间，你最大化程序的时候不要越过这个界线。” </p><p>一个强大的窗口管理程序比如 FVWM，它收到这样的提示时，可以答应工具条程序的这个要求，也可以不答应。一切选择的权力在于谁？当然是用户了！ </p><p>你想想，是不是有些 Windows 程序常常弹出一个窗口要你选择 “Yes or No”？你不点击它它就不下去。你觉不觉得你的程序在侵犯你的尊严？你是一个人，一个智慧的生物，怎能受到一个程序如此的待遇？ </p><p>还有就是很多 Windows 程序把人当成傻瓜，而它是”智能程序”。比如，有一个程序就是喜欢把你的每句话第一个字母都变成大写，我不说它是谁了，你遇到的时候就知道了。 </p><p>如果连”一句话开头一个字母要大写”这么明显的问题都需要程序帮你纠正的话，人脑还用来干什么？况且如果你故意想要不大写的话，那就更麻烦了，我楞是没有从它那一大堆菜单里找到怎么关闭这个愚蠢的选项。 </p><p>只有符号才能完全操纵计算机。 </p><p>我们来说说很多初学 Linux 的用户。虽然他们在用 Linux，但是他们打心眼儿里是觉得Windows 的工作方式好，他们希望 Linux 有一天能”像Windows那样”。你说：”我的鼠标一点，我菜单一拉，…… 就可以完成我的操作。” 但是我要告诉你：”Linux 从来没有摹仿 Windows，将来也不会。Linux 从诞生之日起，它的工作方式就比 Windows 的先进。 </p><p>Linux 属于能勇敢面对符号的人。只有符号才能完全操纵计算机。” </p><p>看看优秀的 UNIX 程序，XFree86, FVWM, VIM, Emacs, proftpd, Mutt, wget, tin, … 没有一个不是用配置文件来设置选项的。为什么这些程序没有方便的菜单可以用来配置？难道它们的设计者就那么低能，连个图形配置界面也写不出来？ </p><p>当然不是。因为图形界面配置方式的能力是极其有限的，而配置文件和程序语言的表达能力却是无限的。用图形界面配置这些程序的话，如果你想达到配置文件的效果，你需要成百上千的菜单，checkbox, radio button, … 到时候你根本没办法找到你需要修改的地方了！而各个程序的配置文件的语法都有很多相似之处，一般就是一些命令，设置一些变量，参数，…… 一旦用会了一个，其它的也就容易理解了。如果你用惯了 awk, sed, Perl，你会觉得那才是真正的自动化啊。 </p><p>鼠标虽然是很好的工具，但是它的表达能力是有限的。你不可能光用鼠标就让电脑完全明白你的意思，它毕竟只有3个按钮。看看我的MetaPost页你就能体会到鼠标的这一弱点。所以我们虽然很喜欢鼠标，但是却不能完全依赖它。 </p><p>各个小程序的完美配合 </p><p>这就是UNIX最重要的特点了，它就是UNIX设计的思想。让每个程序只具有一项专门的能力，然后让它们合作。Xwindow也继承了这种好传统。这恐怕就是Windows和其它操作系统望尘末及的地方了。UNIX 程序设计之统一，配合之完美，真使我难以置信！shell, grep, find, awk, sed, make, Perl, Emacs, vi, tin, Mutt, … 它们是那么的具有一致性！你一旦学会了 sed 的正则表达式，其它程序基本上都能用了。你一旦学会了vi 和 VIM, 你会发现它的操作是那么的有规律性，似乎vi的设计者在几十年前就已经设计好了 VIM 在今天的完美而统一的操作方式！而且vi的操作还体现在 Mutt, tin 等很多程序中。你甚至可以把 bash 设置为 vi 的输入方式来输入命令行，我就是这么做的。一个程序可以调用另外一个程序来得到数据，可以把数据交给它处理后返回来，可以在自己的窗口里”嵌入”另外一个程序。 </p><p>在 Windows 和其它非 UNIX 操作系统中，这种合作是非常困难的。我曾经在Windows下使用 Perl来进行一些自动工作。但是 Windows 的文件操作，管道是如此的不稳定，程序之间基本不能合作。你别想在 Visual Studio 窗口里面嵌入 UltraEdit 编辑器，你别想用一个 expect 脚本来控制 telnet 到水木清华BBS。 </p><p>Windows 的程序都是大而全，大而杂，所有的电子邮件程序都需要自己提供编辑器，自己发送和收取邮件，自己显示邮件的附件。每一个BBS程序都提供自己的 Virtual Terminal, 自己的通讯代码。每一个 IDE 都自己提供编辑器，编译器，汇编器，调试器。人们为了使用一种新的程序，需要适应所有这些它提供的界面，而不能使用自己喜欢的编辑器的键绑定，菜单组织…… 不能 DIY！ </p><p>你要知道，最高级的电脑是定做的，自己想要什么什么CPU，什么主板，多少内存，什么硬盘，键盘，鼠标，显示器都是自己选择的。最高级的滑板，自己想要什么牌子的版面，什么牌子的沙，什么桥，什么轮子，什么轴承，也都是自己选的。最高级的古球拍，木板，胶皮，海绵，胶水都是可以自己选择…… 而用 Windows 程序，你得到的是大杂烩，就像你去买”品牌机”，只有那么几种配置，而且附带很多你不需要的软件和服务；就像你去买组装好的滑板，你想要大一点的轮子和窄一点的板子，但是你没有这种选择余地！Windows 程序就相当于最廉价，最次的滑板。但是它却会花你更多的钱，因为一旦一个部件坏了，或者你不喜欢了，你不能另外找一个好的换掉它，你必需重新买全套配件！ </p><p>而 UNIX 和 Xwindow 就是高档的”组装货”。比如我用 Mutt 的时候，我可以用 VIM也可以用 pico 来编辑邮件，我可以用 ImageMagick 也可以用 xv 来显示附件里的图片，我可以用 lynx 把 HTML 附件转成文本嵌入窗口中，我也可以把 HTML 附件交给Mozilla 图形显示。我可以让 GnuPG 帮我把邮件进行数字签名和加密，我也可以用其它 PGP 程序。 </p><p>我想让 Postfix 而不是 sendmail 帮我发出邮件，我想让 fetchmail 帮我收邮件，转发给 postfix，然后被我自己写的Perl过滤器处理…… 这一切我都可以办到！我可以选择我最喜欢的专门的程序来完成专门的工作，然后把它们结合在一起，我也可以分别得到它们的好处。</p><p>学 UNIX 绝对不是浪费时间 </p><p>有人告诉我：”你看我用 Windows 什么都不用学。而用 Linux，光是安装就花了我一个星期！” </p><p>首先，我要告诉你的是，你装 Linux 花了一个星期，不是因为 Linux 不好装，而是因为你已经习惯了 Windows，对 Linux 最初难以理解而已。你想一想你最初安装Windows的时候呢？你花了多少时间搞明白什么是硬盘分区？什么是盘符？什么是目录？你认为Windows 就是那么容易可以学会的吗？虽然你觉得没花时间学，但是你以前在用别人的机器的时候已经耳濡目染，自然就了解了。而且由于你想要 Linux 和 Windows 并存于硬盘上，又增加了安装难度。而且你肯定没有得到有经验的 Linux 用户的帮助，否则他们会在20分种之内帮你搞定。一个星期也太夸张了. </p><p>如果一开始用的就是Linux就没有这个问题。你想想如果你没有用过 windows，你肯定会很习惯 /etc, /usr, /usr/local ,… 而不是 C:, D:, E:, … 是不是？如果你只用过Linux，你第一次用 windows 时恐怕也会问：”/bin 目录哪里去了啊？” </p><p>最重要的是，你用惯了的UNIX工具，它们可以伴随你一生，而不会那么容易变化或消失。你可以永远不用再换另外的工具了。除非那个工具比你这个好的太多，而且可以完全模拟你现在的工具。 </p><p>我们实验室一个60多岁的老师，用vi, cc, make, …都几十年了，他以前的经验绝对没有白费，而且教会了我们一批又一批的学生。vi 伴随着 UNIX 的最初发行而诞生，直到今天还是世界上头两号编辑器之一！有些人的 FVWM 配置文件已经用了 10 多年，现在完全不经修改还可以用。 </p><p>看看 Windows 的工具，你从 Borland C++ 换到 VC, 就必需适应新的环境：菜单不同了，颜色不同了，按钮不同了，帮助信息不同了，热键不同了，编译器参数，调试器功能也不同了，…… 那个时候恐怕花要花你很多时间去适应。当你刚刚适应了 VC, 你又要换成VJ, PowerBuilder, C++Builder, … </p><p>很多windows程序员都是这样，开头在dos下用Turbo C, 然后是 Borland C, VC, C++ Builder, ……不断追赶微软的潮流。而且微软的SDK, MFC, .NET …… 什么都在不断变化，不断出问题，又不断的在修改…… Windows 程序员不得不买又厚又重的 Microsoft Press 的书籍，看了才一个月，又过时了。今天你才学会了写 VxD，明天你就必须用WDM 了。你不得不注册 MSDN 才能赶上 Microsoft 的步伐。很多人说：”计算机是贵族的专业。” 这就是微软一手造成的。 </p><p>这些东西才是没完没了的浪费大家的时间和金钱的。这是是浪费生命！我们为什么不使用从诞生就那么一致和完美的 UNIX？你需要理解先进工具的设计理念。UNIX 的工具就像我们用的汽车，它的离合器，油门，刹车，方向盘，后视镜，永远都在同样的位置。用惯了的话，你对你的汽车的每一个部件都会了如指掌，甚至你自己都可以修车了。这难道不好吗？</p><p>有人说：”你说我们需要了解 UNIX，难道你要开车还必须了解汽车的结构吗？” 你去问问开车的司机，哪一个不了解汽车的结构的，那他的驾照就是混来的。你难道想要傻瓜型的”微软牌汽车”吗？我们来看看： </p><p>你买的微软牌汽车最开头只有一个座位，每加一个座位你得向汽车公司付钱。车上的防撞气囊不时会冒出来，说是为了你的安全。每开100英里要大修一次，每过一年要换一次引擎。附带的，你还必须换用由微软汽车公司指定的石油公司提供的新型号的机油。你的车出了问题，但是法律规定，你不准私自拆开你的汽车来修理，你必需到微软汽车公司指定的维修点去，需要付相当多的钱才能修好一个小毛病。 </p><p>最可气的是，你每换一个型号的微软牌汽车，它的刹车和离合器都在不同的位置，你需要重新去考驾驶执照。如果这辆汽车在途中刹车失灵，你受了重伤，你也不能状告微软汽车公司，因为你买来汽车之后必须签一个合同，说”由于微软牌汽车对你和家人造成的一切死伤，微软概不负责。” </p><p>怎样完全用 GNU/Linux 工作 </p><p>说了这么多 Windows 的不好。我还没有告诉你我怎么用 Linux 处理有些必要的事情。半年以前我由于中文老是配置不好，一直是双系统，不时需要重起到 Win2k 来处理汉字。后来我找到了 miniChinput, XSIM 和 SCIM 输入法。这下可以处理汉字了。而且 VIM 和Emacs 对汉字支持越来越好。我的大部分文本是用 VIM 编辑的，包括程序，信件，网页，LaTeX 论文，MetaPost 绘图语言。 </p><p>我不用 Word 这样的程序写论文，而是用 LaTeX，因为这是世界上效果最好，最方便的论文工具，是大多数学术杂志要求的格式。幻灯都是用 ConTeXt 做的，用起来很简单，而且效果非常漂亮。你可以看看我的TeX介绍。 </p><p>至于绘图，你可以用很多可视化的工具，比如 xfig，dia。但是对于我来说，任何可视化的工具都不能完成某些任务，我需要一种可以精确描述图形的语言。我找到了MetaPost。它简单又好用，而且效果是世界一流的。我的插图，如果不是图像，都是MetaPost 画出来的。 </p><p>我曾经抱怨 mozilla-mail 经常突然消失，损坏我好几封快要完成的信件。后来我发现mozilla 的邮件处理程序确实是不稳定的，功能又弱，有经验的 UNIX 用户都不用这样的程序。Mutt 是一个非常稳定可靠的 UNIX 邮件处理程序，而且功能非常强大。我曾经为 Gnome 和 KDE 的不稳定而烦恼。现在我找到了非常强大的 FVWM。KDE，Gnome也能和 FVWM 一起工作。虽然 Gnome 和 KDE 总体不稳定，但是某些部件程序还不错，很多 gtk, Qt 的程序也很不错，它们很多都是可以独立于这些桌面环境运行的。 </p><p>Linux 有很多强大方便的工作方式是 Windows 没有的，或者有类似的东西，但是很差劲或者用起来不方便。比如 ssh 服务，rsync，cvs，expect …… </p><p>结论 </p><p>我写这么多的目的是什么？我希望喜欢 Linux 的朋友，完全清除微软和 Windows 灌输在你脑子里的谬论，别再相信它们所谓的”新技术”，别再追赶 Windows，因为追赶Windows ＝ 倒退。马克思有一个思想很重要，”新生事物并不一定是在最近出现的。” </p><p>UNIX，Xwindow, TeX 虽然都比 Windows 先出现，但是它们才是先进生产力的代表。我们要清楚的认识到什么才是真正的现代化，什么才是真正的自动化。 </p><p>消除学计算机很难的幻觉，勇敢的拿起像 bash, FVWM, TeX, VIM, Emacs, Mutt ……这样强大的程序，勇敢的面对符号。不要再埋怨”Linux 为什么不能像 Windows 那样”，不要再浪费时间试用这样那样的程序，不要再忙着升级。你需要理解 UNIX 的工作方式，因为那是大多数科学家的工作方式。Linux 可以成为你的好朋友，你需要认识它，了解它，信任它，才能完全的靠它来高效的工作。当然，在游戏机，手机，掌上电脑里，或者在用电脑来娱乐的时候，用一些”傻瓜软件”还是不错的. </p><p>我希望小学，中学的计算机老师能够提高自己的素质，在孩子们的启蒙教育中充分利用Linux 神秘的特点，引起孩子们对数学，对符号的好奇心。诱导他们用计算机来解决世界上的有趣问题，而不要把教学的范围局限于计算机的操作和它自身的问题。 </p><p>附录: 我用来处理日常事务的 Linux 程序 </p><p>好了好了。我知道你发现自己应该转向 Linux，你很后悔当初为什么中了微软的邪。但是不要着急。因为这些东西本来只是工具，它们是用来完成你的主要任务的辅助而已。你以前选错了工具，这不要紧。你还是拥有你自己原来的专业技能，那才是最重要的。工具的东西只有慢慢适应转换，不能一蹴而就，否则你会感到非常没意思，甚至放弃。 </p><p>如果你只想做一个像我这样的普通用户，主要目的是用 Linux 来完成自己的任务，那就可以不用系统管理员或者网络管理员的标准来要求自己，因为当一个系统和网络管理员确实很辛苦。这里我对实验室的网管同学鞠一躬，谢谢你的指点和帮助. 不用把你的机器当成网络服务器，不用开放没有必要的服务，设置好 ssh, ftp 已经足够了。这样会省去了解很多没必要了解的东西的时间。不用过度考虑”安全”，因为 Linux 缺省已经很安全了。不过你有兴趣了解更多那也无妨。 </p><p>下面给出一些推荐使用的可以处理一般事情的程序。至于你的专业上要用到的科学和工程软件比如 Matlab, Mathematica, Maple, HSpice, Design Compiler, …… 还有其它物理上的，化学上的，生物上的 …… 都必然有 Linux 和 UNIX 的版本。当然他们很多不是免费的，不要总是觉得什么都应该免费，自由不等于免费。它们是经过很多人辛勤劳动的产物，是可靠的程序，它们物有所值。 </p><p>下面列出我常用的一些 Linux 程序。一个列表里可能有很多，那是为了方便你来选择，我列出了比较信得过的。但其实很多只有第一个是我真正在用的，我不喜欢试用程序。我不是一个合格的网络管理员，我的服务器都只设置了我自己需要的功能，那样可以省去我很多麻烦。 </p><p>Shell: bash。它结合了 csh 和 ksh 的优点，并且有 readline 功能，你可以随意绑定自己的键盘。 </p><p>编辑器： VIM, Emacs。 </p><p>程序开发： GCC, make, ld, Scheme48, j2sdk, Perl, Python, Tcl/Tk … </p><p>论文，幻灯工具：LaTeX, ConTeXt </p><p>绘图工具：MetaPost。这个语言太强了，以至于我只用它了。你不熟悉的话可以用 xfig, dia 来画一些流程图之类的图片。 </p><p>图像处理：ImageMagick。其中的 import 程序可以屏幕抓图，convert 程序可以转换图像格式，display 可以显示图片和简单编辑(缩放，换质量，转格式，简单绘图，简单虑镜)。通常我就这么点需要。如果你要更强大的图像工具可以用 Gimp, 它几乎和Photoshop差不多。 </p><p>自动管理工具：make。我可以用make来自动编译程序，自动编译文档，自动更新插图…… 全自动，而且不会重复劳动。 </p><p>数值计算程序：SciLab。这个程序基本上可以代替 Matlab。 </p><p>代数计算程序：MAXIMA。这个程序基于世界上最老的计算机代数系统之一: 由美国能源部(DOE)发行的 MIT Macsyma 系统。它是用 Common Lisp 实现的。很多现在的符号计算程序比如 Maple 都从 MAXIMA 身上学到很多东西。它现在经过 DOE 批准以GPL发行，永远是一个自由软件。 </p><p>加密程序：GnuPG。我的 PGP 密钥就是它搞出来的。 </p><p>打包，压缩程序。什么都有: tar, gzip, bzip2, zip, rar, … </p><p>虚拟光驱程序。Linux 不需要虚拟光驱程序，直接 mount 就行了。 </p><p>ftp 服务器：proftpd, vsftpd。proftpd 功能很强，但是我只用了最简单的一种设置。 </p><p>WWW 服务器：apache。(我一般没有开) </p><p>ftp 客户程序：lftp，ncftp。它们都是文本方式操作的，但是比起图形界面的方便的多。比如 lftp 几乎具有 bash 的所有方便功能，Tab 补全，bookmark, queue, 后台下载，镜像…… Linux 也有图形界面的 ftp 客户程序，但是大多不稳定，有很多问题。这就是很多人抱怨 Linux 不如 Windows 的一个小原因。还有很多人用 Wine 模拟 Windows 的leapftp，其实 lftp 比 leapftp 好很多，你需要的只是适应一下。 </p><p>自动下载工具：wget。它非常稳定，有一次我下载一个程序，用 IE 和 Mozilla 下载回来的文件都是坏的，最后还是 wget 可靠的传输了数据。用它甚至可以镜像整个网站，比起WebZip 这样的 Windows 程序强多了，而且不会因为你不付钱就在下载回来的网页里强制插入广告。 </p><p>虚拟终端：rxvt, xterm, gnome-terminal, mlterm, … </p><p>X server: XFree86 </p><p>窗口管理器：FVWM。编译加入了 libstroke。 </p><p>中文输入：XSIM。被我修改过以适应 FVWM 的需要。另外推荐你还可以用 SCIM。 </p><p>email 处理：Mutt + Postfix + fetchmail </p><p>看 PDF, PS, DJVU 文件：Acrobat Reader, xpdf, GhostScript, gv, djvu工具包和netscape 插件。 </p><p>看CAJ文档。我从来不看CAJ之类的文档，如果找不到PDF或PS，直接去图书馆借最好。 </p><p>看网页：Mozilla, Phoenix, lynx。Mozilla-Xft 的显示效果比IE 好很多。 </p><p>英汉字典：IBM智能词典，星际译王。 </p><p>编辑网页：我用VIM 直接写 HTML。你如果想要图形方式的可以用其它的比如screem, BlueFish。 </p><p>登录其它 UNIX, Linux 机器：openSSH, telnet。 我喜欢用 openSSH 把其它机器的X 程序通过 ssh 加密的隧道传到我机器上显示。 </p><p>登录 Windows2000 server 的 display service: rdesktop，…我有一天试了一下，不错。后来就没有用过了。 </p><p>同步程序：rsync。我用 rsync 通过 ssh 来跟某些机器同步数据，或者做自己机器上不同目录间的同步。 </p><p>上BBS：rxvt(或任何一种终端) + telnet + chatbot(helloooo 机器人的程序) </p><p>QQ, ICQ: 我没有 QQ 或 ICQ。不过你可以用 Gaim, 它同时支持 QQ, ICQ 和很多其它的即时通信方式。ICQ 用户也可以用 Licq。 </p><p>放录像：MPlayer, RealPlayer。MPlayer 太好了，直接就可以放 VCD, DVD, divx, wma, wmv … 用 Windows 的同学都很羡慕我，说 Windows 要放这个需要大堆插件。rm 最好还是用 realplayer 放，它也是免费的。 </p><p>放音乐： xmms(mp3,ogg都可以), mpg321(放mp3), ogg123(放ogg)。mpg321 不如xmms管理音乐文件那么方便，但是有时我还是用 mpg321 放 mp3 作为背景音乐，因为懒得开一个xmms窗口:-) </p><p>游戏：我觉得 KDE 的那个 ksokoban(推箱子)，很好玩 :-) </p><p>看 Word 文档。请 Word 用户把文档全部转为 PDF 或 PS 再给我，文档里没有特殊的格式干脆就用文本吧，何必那么麻烦。以前很奇怪的是，通知里本来没有什么特殊的格式居然还要发doc附件的email。现在好了，我们系发通知都用文本，PDF，甚至图片了。 </p><p>其它程序：还有很多我需要用而你不一定用得着的。比如，Doctor Scheme, </p><p>Scheme48, Scsh, kawa…这些程序只有 Doctor Scheme 有Windows版本。还有很多幕后工作但是你一般不察觉的：xinetd, telnetd, sshd, crond, atd, lpd, … 他们都比 Windows 的对应者强的多，或者根本没有对应者。 </p><p>附: </p><p>写给支持和反对《完全用Linux工作》的人们 </p><p>作者：王垠 </p><p>在一阵阵唾骂和欢呼声中，《完全用linux工作》被转载到了天涯海角。很多人支持我，也有很多人唾骂我。我不知道它是怎样流传到那么多地方，其实我不知道它都被转到哪里去了…… 我知道现在这篇文章又会罗里罗索写很长（因为我计划写这样一个东西已经很久了，坐在Emacs前面总是有一种巫师在炼丹的感觉……），所以先提出中心思想吧。中心思想就是： </p><p>我只是一个傻瓜。看《完全用Linux 工作》的时候请用你们自己的判断力。 </p><p>几乎所有人都承认，那篇文章很偏激。当时的情况是这样，我用 Linux 的时候被一个同学鄙视了，说：”你怎么用像 DOS 一样落后的东西，真土！看我漂亮的 Win2000…” 这跟当面嘲笑别人老婆或者妈妈有什么区别？我义愤填膺啊，就几乎跟他吵起来。然后就写出了这篇文章放在主页上，叫了几个人来看。接着我珍爱的 TeX 又受到众人鄙视，于是我又写了一篇文章打击 Word，然后把 TeX 捧上了天。道理很简单，鄙视我喜欢的东西的人就是敌人 –邪教徒或者恐怖分子–他支持的我就反对，他反对的我就支持。为了使人信服，举例必用大科学家，世界一流大学，一流实验室的名号，虽然我不跟其中任何一种沾边。还好那时候我还不认识上帝，要不就打他的名字了。论据不管是实际经历还是自己推测的，先写上去再说。扬眉吐气啊！隔壁微软研究院的哥们居然都被我打动了，开始写 Linux 程序，学用 LaTeX 和 Emacs。不过几天之后我就把它删掉了，因为我自己都感觉到偏激。 </p><p>于是就没管那篇文章了。可是没想到它竟然已经被转载到那么多地方，似乎引起不小的波澜。有段时间每天都收到十几封email，国内的，国外的，问技术问题的，夸我的，骂我的，讲道理的，鄙视我的，想交朋友的，语重心长的，号称要删掉机器上的 Windows 的…… 我的主页居然也占据了”王垠”在 Google 上的首选位置，把那个日本的什么王公贵族”李王垠殿下”都挤下去了。大家似乎都知道我天花乱坠的本事了，有人就想找我写文章向别人推荐商业软件，我很后悔没有趁机狠狠赚一笔。走到图书馆，亮出借书证，管理员张大了嘴说：”哇！你就是那个 Linux 牛人啊！”，也不知道他是褒是贬。甚至有人把他的 BBS 昵称都改成了”坚决拥护精神领袖花生” （花生是我的外号）。为此还骗到了好几顿报告?quot;报告”是清华专用动词，意思是请客吃饭）。虽然我觉得自己身上没有什么值得自豪的东西，但是又有点为自己兴风作浪的本事感到惊讶。虽然我一再告诫自己要谦虚，但是不由的有一种毛泽东，甘地，甚至摩西的感觉。我更加体会到”网络上没有人知道你是一头猪”的真理性。其实，不但网络上没有人知道我是一头猪，实际生活中也没有人知道，其实我是一头笨猪。 </p><p>这么长的时间之后，还有人写信给我说”深受鼓舞”，”提壶灌顶”，”对不起我还在用 Windows 给你写信”，”真想删掉Windows 啊” …… 我很好奇，我的文章真的有那么大的威力？我再看这篇文章，觉得有点惨不忍睹，看了开头就不忍心再看下去。我告诉同学我很后悔写了一篇这么偏激的文章，可是他?quot;徼枉必须过正，你没有错”，所以我也搞不清楚自己这样写对不对，这样自责对不对。就像我从来不敢看自己照片，却有时被人称为帅哥，就让我无法判断自己是否帅一样。所以现在我就开始怀疑我自己是否真是一头笨猪。也许多年以后，我会正确的评价我的想法。就像我现在觉得我15岁的照片挺养眼一样，也许我会发现自己其实是一头聪明猪？ </p><p>写这篇文章不是为了让自己免得被骂，也不是为了显示高深的猪的哲理。只是因为我深深的感到人应该有自己的判断力，不要简单的接受别人说的 DO’s 和 DONT’s。怀疑一切，同时又敞开心扉去了解一切。 </p><p>看过《完全用Linux工作》的朋友，请仔细检查里面的 DO’s 和 DONT’s。 </p><p>2004.8.26</p>]]></content>
      
      
      <categories>
          
          <category> 码匠 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/2016/08/16/Hadoop/"/>
      <url>/2016/08/16/Hadoop/</url>
      
        <content type="html"><![CDATA[<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。<br>用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。<br>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p><p>Hadoop原本来自于谷歌一款名为MapReduce的编程模型包。谷歌的MapReduce框架可以把一个应用程序分解为许多并行计算指令，跨大量的计算节点运行非常巨大的数据集。</p><h2 id="名字起源"><a href="#名字起源" class="headerlink" title="名字起源"></a>名字起源</h2><p>Hadoop这个名字不是一个缩写，而是一个虚构的名字。该项目的创建者，Doug Cutting解释Hadoop的得名 ：“这个名字是我孩子给一个棕黄色的大象玩具命名的。我的命名标准就是简短，容易发音和拼写，没有太多的意义，并且不会被用于别处。小孩子恰恰是这方面的高手。”<br>Hadoop的发音是 [hædu:p]。</p><p>Hadoop带有用<a href="http://baike.baidu.com/view/29.htm" target="_blank" rel="noopener">Java</a>语言编写的框架，因此运行在 Linux 生产平台上是非常理想的。Hadoop 上的<a href="http://baike.baidu.com/view/330120.htm" target="_blank" rel="noopener">应用程序</a>也可以使用其他语言编写，比如 <a href="http://baike.baidu.com/view/824.htm" target="_blank" rel="noopener">C++</a>。</p><h1 id="核心架构"><a href="#核心架构" class="headerlink" title="核心架构"></a>核心架构</h1><p>Hadoop 由许多元素构成。其最底部是 Hadoop Distributed File System（HDFS），它存储 Hadoop 集群中所有存储节点上的文件。HDFS（对于本文）的上一层是<a href="http://baike.baidu.com/view/2902.htm" target="_blank" rel="noopener">MapReduce</a> 引擎，该引擎由 JobTrackers 和 TaskTrackers 组成。通过对Hadoop分布式计算平台最核心的分布式文件系统HDFS、MapReduce处理过程，以及数据仓库工具Hive和分布式数据库Hbase的介绍，基本涵盖了Hadoop分布式平台的所有技术核心。</p><h3 id="1-HDFS"><a href="#1-HDFS" class="headerlink" title="1 HDFS"></a>1 HDFS</h3><p>对外部客户机而言，HDFS就像一个传统的分级文件系统。可以创建、删除、移动或重命名文件，等等。但是 HDFS 的架构是基于一组特定的节点构建的（参见图 1），这是由它自身的特点决定的。这些节点包括 NameNode（仅一个），它在 HDFS 内部提供元数据服务；DataNode，它为 HDFS 提供存储块。由于仅存在一个 NameNode，因此这是 HDFS 的一个缺点（单点失败）。<br>存储在 HDFS 中的文件被分成块，然后将这些块复制到多个计算机中（DataNode）。这与传统的 RAID 架构大不相同。块的大小（通常为 64MB）和复制的块数量在创建文件时由客户机决定。NameNode 可以控制所有文件操作。HDFS 内部的所有通信都基于标准的 TCP/IP 协议。</p><p>NameNode本身不可避免地具有SPOF（Single Point Of Failure）单点失效的风险，主备模式并不能解决这个问题，通过<code>Hadoop Non-stop namenode</code>才能实现100% uptime可用时间。</p><p>HDFS 并不是一个万能的文件系统。它的主要目的是支持以流的形式访问写入的大型文件。</p><h2 id="Hadoop和高效能计算、网格计算的区别"><a href="#Hadoop和高效能计算、网格计算的区别" class="headerlink" title="Hadoop和高效能计算、网格计算的区别"></a>Hadoop和高效能计算、网格计算的区别</h2><p>在Hadoop 出现之前，高性能计算和网格计算一直是处理大数据问题主要的使用方法和工具，它们主要采用消息传递接口<code>（Message Passing Interface，MPI）</code>提供的API 来处理大数据。高性能计算的思想是将计算作业分散到集群机器上，<code>集群计算节点访问存储区域网络SAN 构成的共享文件系统获取数据</code>，这种设计比较适合<code>计算密集型作业</code>。当需要访问像PB 级别的数据的时候，由于存储设备网络带宽的限制，很多集群计算节点只能空闲等待数据。而Hadoop却不存在这种问题，由于Hadoop 使用专门为分布式计算设计的文件系统HDFS，计算的时候只需要将计算代码推送到存储节点上，即可在存储节点上完成数据本地化计算，<code>Hadoop 中的集群存储节点也是计算节点</code>。</p><p>在分布式编程方面，MPI 是属于比较底层的开发库，它赋予了程序员极大的控制能力，但是却要程序员自己控制程序的执行流程，容错功能，甚至底层的套接字通信、数据分析算法等底层细节都需要自己编程实现。这种要求无疑对开发分布式程序的程序员提出了较高的要求。相反，Hadoop 的MapReduce 却是一个高度抽象的并行编程模型，它将分布式并行编程抽象为两个原语操作，即map 操作和reduce 操作，开发人员只需要简单地实现相应的接口即可，完全不用考虑底层数据流、容错、程序的并行执行等细节。这种设计无疑大大降低了开发分布式并行程序的难度。</p><p><code>网格计算通常是指通过现有的互联网，利用大量来自不同地域、资源异构的计算机空闲的CPU 和磁盘来进行分布式存储和计算</code>。这些参与计算的计算机具有分处不同地域、资源异构（基于不同平台，使用不同的硬件体系结构等）等特征，从而使网格计算和Hadoop 这种基于集群的计算相区别开。Hadoop 集群一般构建在通过高速网络连接的单一数据中心内，集群计算机都具有体系结构、平台一致的特点，而网格计算需要在互联网接入环境下使用，网络带宽等都没有保证。</p><h2 id="开源实现"><a href="#开源实现" class="headerlink" title="开源实现"></a>开源实现</h2><p>Hadoop是项目的总称。主要是由HDFS和MapReduce组成。<br>HDFS是Google File System（GFS）的开源实现。<br>MapReduce是Google MapReduce的开源实现。</p><h2 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h2><p>Hadoop Common: 在0.20及以前的版本中，包含HDFS、MapReduce和其他项目公共内容，从0.21开始HDFS和MapReduce被分离为独立的子项目，其余内容为Hadoop Common<br>HDFS: Hadoop分布式文件系统(Distributed File System) － HDFS (Hadoop Distributed File System)<br>MapReduce：并行计算框架，0.20前使用 org.apache.hadoop.mapred 旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API<br>HBase: 类似Google BigTable的分布式NoSQL列数据库。（HBase和Avro已经于2010年5月成为顶级 Apache 项目）<br>Hive：数据仓库工具，由Facebook贡献。<br>Zookeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。<br>Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。<br>Pig: 大数据分析平台，为用户提供多种接口。<br>Ambari：Hadoop管理工具，可以快捷的监控、部署、管理集群。<br>Sqoop：于在HADOOP与传统的数据库间进行数据的传递</p>]]></content>
      
      
      <categories>
          
          <category> 码匠 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发环境配置</title>
      <link href="/2016/08/16/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2016/08/16/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p>安装完JDK后配置环境变量  计算机→属性→高级系统设置→高级→环境变量</p><ol><li>系统变量→新建 JAVA_HOME 变量 。变量值填写jdk的安装目录（本人是 E:\Java\jdk1.7.0)</li><li>系统变量→寻找 Path 变量→编辑，在变量值最后输<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</code><br>（注意原来Path的变量值末尾有没有;号，如果没有，先输入；号再输入上面的代码）</li><li>系统变量→新建 CLASSPATH 变量，变量值填写<code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code>（注意最前面有一点），系统变量配置完毕</li><li>检验是否配置成功 运行cmd 输入 <code>java -version</code> （java 和 -version 之间有空格），若如图所示 显示版本信息 则说明安装和配置成功。</li></ol><h1 id="Eclipse-CDT-编写C"><a href="#Eclipse-CDT-编写C" class="headerlink" title="Eclipse CDT 编写C++"></a>Eclipse CDT 编写C++</h1><h2 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h2><h2 id="安装minGW"><a href="#安装minGW" class="headerlink" title="安装minGW"></a>安装minGW</h2><p>配置环境变量：找到Path，编辑，添加</p><p><code>;C:\MinGW\bin</code></p><p>,注意要用分号“;”隔开</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP Primer4</title>
      <link href="/2016/08/11/Primer/"/>
      <url>/2016/08/11/Primer/</url>
      
        <content type="html"><![CDATA[<h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><hr><h3 id="初始化不是赋值"><a href="#初始化不是赋值" class="headerlink" title="初始化不是赋值"></a>初始化不是赋值</h3><p>在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。</p><h2 id="指针与引用的比较"><a href="#指针与引用的比较" class="headerlink" title="指针与引用的比较"></a>指针与引用的比较</h2><p>虽然使用引用（reference）和指针都可间接访问另一个值，但它们之间有两个重要区别。第一个区别在于引用总是指向某个对象：定义引用时没有初始化是错误的。第二个重要区别则是赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，而并不是使引用与另一个对象关联。引用一经初始化，就始终指向同一个特定对象（这就是为什么引用必须在定义时初始化的原因）。</p><p>考虑以下两个程序段。第一个程序段将一个指针赋给另一指针：</p><pre><code>int ival = 1024, ival2 = 2048;int *pi = &amp;ival, *pi2 = &amp;ival2;pi = pi2;    // pi now points to ival2</code></pre><p>赋值结束后，pi 所指向的 ival 对象值保持不变，赋值操作修改了 pi 指针的值，使其指向另一个不同的对象。现在考虑另一段相似的程序，使用两个引用赋值：</p><pre><code>int &amp;ri = ival, &amp;ri2 = ival2;ri = ri2;    // assigns ival2 to ival</code></pre><p>这个赋值操作修改了 ri 引用的值 ival 对象，而并非引用本身。赋值后，这两个引用还是分别指向原来关联的对象，此时这两个对象的值相等。</p><h3 id="变量的声明与定义"><a href="#变量的声明与定义" class="headerlink" title="变量的声明与定义"></a>变量的声明与定义</h3><p>C++ 程序通常由许多文件组成。<code>为了让多个文件访问相同的变量，C++ 区分了声明和定义。</code></p><p>声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。可以通过使用extern关键字声明变量名而不定义它。不定义变量的声明包括对象名、对象类型和对象类型前的关键字extern。extern 声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。</p><p>变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有且仅有一个定义。</p><p>只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有存储空间来进行初始化。如果声明有初始化式，那么它可被当作是定义，即使声明标记为 extern：</p><pre><code>extern double pi = 3.1416; // definition</code></pre><p>虽然使用了 extern ，但是这条语句还是定义了 pi，分配并初始化了存储空间。只有当 extern 声明位于函数外部时，才可以含有初始化式。</p><p>因为已初始化的 extern 声明被当作是定义，所以该变量任何随后的定义都是错误的：</p><pre><code>extern double pi = 3.1416; // definitiondouble pi;                 // error: redefinition of pi</code></pre><p>同样，随后的含有初始化式的 extern 声明也是错误的：</p><pre><code>extern double pi = 3.1416; // definitionextern double pi;          // ok: declaration not definitionextern double pi = 3.1416; // error: redefinition of pi</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1 快速入门"></a>1 快速入门</h1><h2 id="1-1-编写简单的-C-程序"><a href="#1-1-编写简单的-C-程序" class="headerlink" title="1.1. 编写简单的 C++ 程序"></a>1.1. 编写简单的 C++ 程序</h2><p>每个 C++ 程序都包含一个或多个函数，而且必须有一个命名为 main。main 函数的返回值必须是 <code>int 型</code>。操作系统通过 main 函数返回的值来确定程序是否成功执行完毕。返回 0 值表明程序程序成功执行完毕。任何其他非零的返回值都有操作系统定义的含义。通常非零返回值表明有错误出现。每一种操作系统都有自己的方式告诉用户 main 函数返回什么内容。</p><p>C++ 程序文件的后缀与运行的具体编译器有关。其形式还包括。</p><pre><code>prog1.cxxprog1.cppprog1.cpprog1.Cprog1.CC</code></pre><h2 id="1-2初窥输入-输出"><a href="#1-2初窥输入-输出" class="headerlink" title="1.2初窥输入/输出"></a>1.2初窥输入/输出</h2><p><code>C++ 并没有直接定义进行输入或输出（IO）的任何语句，这种功能是由标准库提供的。</code>iostream 库的基础是两种命名为 istream 和 ostream 的类型，分别表示输入流和输出流。ssdf</p><p>标准库定义了 4 个<code>IO 对象</code>:</p><ol><li>处理输入时使用命名为 cin（读作 see-in）的 <code>istream 类型对象</code>。这个对象也称为标准输入。</li><li>处理输出时使用命名为 cout（读作 see-out）的 <code>ostream 类型对象</code>，这个对象也称为标准输出。</li><li>标准库还定义了另外两个 <code>ostream 对象</code>，分别命名为 cerr 和 clog（分别读作“see-err”和“see-log”）。cerr 对象又叫作标准错误，通常用来输出警告和错误信息给程序的使用者。</li><li>clog 对象用于产生程序执行的一般信息。</li></ol><p>一般情况下，系统将这些对象与执行程序的窗口联系起来。这样，当我们从 cin 读入时，数据从执行程序的窗口读入，当写到 cin、cerr 或 clog 时，输出写至同一窗口。运行程序时，大部分操作系统都提供了重定向输入或输出流的方法。利用重定向可以将这些流与所选择的文件联系起来。</p><p><code>输出操作符（&lt;&lt; 操作符）</code>返回的是其左操作数。C++ 中，每个表达式都会产生一个结果，通常是将操作符作用到其操作数所产生的值。当操作符是输出操作符时，结果是左操作数的值。也就是说，<code>输出操作返回的值是输出流本身。</code></p><p><code>endl</code> 是一个特殊值，称为<code>操纵符</code>，将它写入输出流时，具有输出换行的效果，<code>并刷新与设备相关联的缓冲区</code>。通过刷新缓冲区，用户可立即看到写入到流中的输出。</p><p><code>作用域操作符（scope operator，:: 操作符）</code></p><p><code>输入操作符（&gt;&gt; 操作符）</code>行为与输出操作符相似。它接受一个 istream 对象作为其左操作数，接受一个对象作为其右操作数，<code>它从 istream 操作数读取数据并保存到右操作数中</code>。像输出操作符一样，输入操作符返回其左操作数作为结果。由于输入操作符返回其左操作数，我们可以将输入请求序列合并成单个语句。</p><blockquote><p>在写 C++ 程序时，大部分出现空格符的地方可用换行符代替。这条规则的一个例外是字符串字面值中的空格符不能用换行符代替。另一个例外是空格符不允许出现在预处理指示中。</p></blockquote><h2 id="1-3-关于注释"><a href="#1-3-关于注释" class="headerlink" title="1.3 关于注释"></a>1.3 关于注释</h2><p>注释并不会增加可执行程序的大小，编译器会忽略所有注释。</p><p>单行注释以双斜线（//）开头，行中处于双斜线右边的内容是注释，被编译器忽略。</p><p>多行注释为（/* */），是从 C 语言继承过来的。</p><p><code>注释对不可嵌套</code></p><h3 id="1-4-4-读入未知数目的输入"><a href="#1-4-4-读入未知数目的输入" class="headerlink" title="1.4.4. 读入未知数目的输入"></a>1.4.4. 读入未知数目的输入</h3><pre><code>#include &lt;iostream&gt;int main(){    int sum = 0, value;    // read till end-of-file, calculating a running total of all values read    while (std::cin &gt;&gt; value)        sum += value; // equivalent to sum = sum + value    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;    return 0; }</code></pre><p>如果我们给出本程序的输入：</p><p>  3 4 5 6 （空格分隔，control+z结束，或者输入非整数类型+回车）</p><p>那么输出是：</p><p>  Sum is: 18</p><p>当我们使用 istream 对象作为条件，结果是测试流的状态。如果流是有效的（也就是说，如果读入下一个输入是可能的）那么测试成功。遇到<code>文件结束符或遇到无效输入</code>时，如读取了一个不是整数的值，则 istream 对象是无效的。处于无效状态的 istream 对象将导致条件失败。</p><p><code>操作系统使用不同的值作为文件结束符。Windows 系统下我们通过键入 control—z——同时键入“ctrl”键和“z”键，来输入文件结束符。Unix 系统中，包括 Mac OS—X 机器，通常用 control—d。</code></p><h2 id="1-5-类的简介"><a href="#1-5-类的简介" class="headerlink" title="1.5. 类的简介"></a>1.5. 类的简介</h2><p>类类型存储在一个文件中，其文件名如同程序的源文件名一样，由文件名和文件后缀两部分组成。通常文件名和定义在头文件中的类名是一样的。通常后缀是 .h，但也有一些程序员用 .H、.hpp 或 .hxx。编译器通常并不挑剔头文件名，但 IDE 有时会。</p><p><code>标准库的头文件用尖括号 &lt; &gt; 括起来，非标准库的头文件用双引号 &quot; &quot; 括起来。</code></p><p><code>与大多数其他操作符不同，点操作符（“.”）的右操作数不是对象或值，而是成员的名字。</code></p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>通常使用成员函数作为点操作符的右操作数来调用成员函数。执行成员函数和执行其他函数相似：要调用函数，可将<code>调用操作符（()）</code>放在函数名之后。调用操作符是一对圆括号，括住传递给函数的实参列表（可能为空）。</p><blockquote><ol><li>main函数的形参个数是有限的</li><li>我们倾向于吧确定函数边界的花括号自成一行，且缩进复合的输入或输出表达式从而使操作符排列整齐；</li></ol></blockquote><h1 id="2-变量和基本类型"><a href="#2-变量和基本类型" class="headerlink" title="2 变量和基本类型"></a>2 变量和基本类型</h1><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1. 基本内置类型"></a>2.1. 基本内置类型</h2><p>C++ 定义了一组表示整数、浮点数、单个字符和布尔值的<code>算术类型</code>，另外还定义了一种称为 void 的<code>特殊类型</code>。void 类型没有对应的值，仅用在有限的一些情况下，通常用作无返回值函数的返回类型。</p><p>算术类型的存储空间依机器而定。<code>这里的存储空间是指用来表示该类型的位（bit）数。C++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间。</code>事实上，对于int类型，几乎所有的编译器使用的存储空间都比所要求的大。int表 2.1 列出了内置算术类型及其对应的最小存储空间。</p><table><thead><tr><th>bool</th><th>布尔型</th><th>-</th><th></th></tr></thead><tbody><tr><td>char</td><td>字符型</td><td>8</td><td></td></tr><tr><td>wchar_t</td><td>宽字符型</td><td>16</td><td>用于扩展字符集，比如汉字和日语</td></tr><tr><td>short</td><td>短整型</td><td>16</td><td></td></tr><tr><td>int</td><td>整形</td><td>16</td><td></td></tr><tr><td>long</td><td>长整形</td><td>32</td><td></td></tr><tr><td>float</td><td>单精度浮点型</td><td>6位有效数字</td><td></td></tr><tr><td>double</td><td>双精度浮点型</td><td>10位有效数字</td><td></td></tr><tr><td>long double</td><td>扩展精度浮点型</td><td>10位有效数字</td></tr></tbody></table><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>表示整数、字符和布尔值的算术类型合称为整型。</p><p>short、int 和 long 类型都表示整型值，存储空间的大小不同。一般， short 类型为半个机器字长，int 类型为一个机器字长，而 long 类型为一个或两个机器字长（在 32 位机器中 int 类型和 long 类型通常字长是相同的）。</p><p>bool 类型表示真值 true 和 false。<code>可以将算术类型的任何值赋给 bool 对象。</code>0 值算术类型代表 false，任何非 0 的值都代表 true。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>除 bool 类型外，整型可以是带符号的（signed）也可以是无符号的（unsigned）。顾名思义，带符号类型可以表示正数也可以表示负数（包括 0），而无符号型只能表示大于或等于 0 的数。</p><p>整型 int、short 和 long 都默认为带符号型。<code>unsigned int 类型可以简写为 unsigned</code>，也就是说，unsigned 后不加其他类型说明符意味着是 unsigned int 。</p><p><code>和其他整型不同，char 有三种不同的类型：plain char 、unsigned char 和 signed char。</code>虽然 char 有三种不同的类型，但只有两种表示方式。可以使用 unsigned char 或 signed char 表示 char 类型。使用哪种 char 表示方式由编译器而定。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>C++ 标准并未定义 signed 类型如何用位来表示，而是由每个编译器自由决定如何表示 signed 类型。这些表示方式会影响 signed 类型的取值范围。<code>8 位 signed 类型的取值肯定至少是从 -127 到 127，但也有许多实现允许取值从 -128 到 127。</code></p><p><code>C++ 中，把负值赋给 unsigned 对象是完全合法的，其结果是该负数对该类型的取值个数求模后的值。所以，如果把 -1 赋给8位的 unsigned char，那么结果是 255，因为 255 是 -1 对 256 求模后的值。</code></p><p>类型 float、 double 和 long double 分别表示单精度浮点数、双精度浮点数和扩展精度浮点数。一般 float 类型用一个字（32 位）来表示，double 类型用两个字（64 位）来表示，long double 类型用三个或四个字（96 或 128 位）来表示。类型的取值范围决定了浮点数所含的有效数字位数。</p><h2 id="2-2-字面值常量"><a href="#2-2-字面值常量" class="headerlink" title="2.2. 字面值常量"></a>2.2. 字面值常量</h2><p><code>只有内置类型存在字面值，没有类类型的字面值。</code></p><p>以 0（零）开头的字面值整数常量表示八进制，以 0x 或 0X 开头的表示十六进制。</p><p>通过在数值后面加 L 或者 l（字母“l”大写或小写）指定常量为 long 类型。定义长整型时，应该使用大写字母 L。小写字母 l 很容易和数值 1 混淆。</p><p>类似地，可通过在数值后面加 U 或 u 定义 unsigned 类型。同时加 L 和 U 就能够得到 unsigned long 类型的字面值常量。但其后缀不能有空格。</p><p>通常可以用十进制或者科学计数法来表示浮点字面值常量。使用科学计数法时，指数用 E 或者 e 表示。默认的浮点字面值常量为 double 类型。在数值的后面加上 F 或 f 表示单精度。同样加上 L 或者 l 表示扩展精度（再次提醒，不提倡使用小写字母l）。</p><p>可打印的字符型字面值通常用一对单引号来定义：</p><pre><code>&apos;a&apos;         &apos;2&apos;         &apos;,&apos;         &apos; &apos; // blank</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>这些字面值都是 char 类型的。<code>在字符字面值前加 L 就能够得到 wchar_t 类型的宽字符字面值。</code>如：</p><pre><code>L&apos;a&apos;</code></pre><p>我们可以将任何字符表示为以下形式的通用转义字符：</p><pre><code>\ooo</code></pre><p>这里 ooo 表示三个八进制数字，这三个数字表示字符的数字值。下面的例子是用 ASCII 码字符集表示字面值常量：</p><pre><code>\7 (bell)      \12 (newline)     \40 (blank)\0 (空字符)      \062 (&apos;2&apos;)        \115 (&apos;M&apos;)</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>为了兼容 C 语言，C++ 中所有的字符串字面值都由编译器自动在末尾添加一个空字符。字符字面值’A’表示单个字符 A，然而 “A” 表示包含字母 A 和空字符两个字符的字符串。</p><p>正如存在宽字符字面值，也存在<code>宽字符串字面值</code>，一样在前面加“L”，如</p><pre><code>L&quot;a wide string literal&quot;</code></pre><p>宽字符串字面值是一串常量宽字符，同样以一个<code>宽空字符</code>结束。</p><p>两个相邻的仅由空格、制表符或换行符分开的字符串字面值（或宽字符串字面值），可连接成一个新字符串字面值。 </p><p><code>在一行的末尾加一反斜线符号\可将此行和下一行当作同一行处理。注意反斜线符号必须是该行的尾字符——不允许有注释或空格符。同样，后继行行首的任何空格和制表符都是字符串字面值的一部分。正因如此，长字符串字面值的后继行才不会有正常的缩进。</code></p><h2 id="2-3变量"><a href="#2-3变量" class="headerlink" title="2.3变量"></a>2.3变量</h2><p><strong>变量名</strong>，可以由字母、数字和下划线组成。变量名必须以字母或下划线开头，并且区分大小写字母。</p><p>定义时指定了初始值的对象被称为是<code>已初始化的</code>。C++ 支持两种初始化变量的形式：<code>复制初始化和直接初始化</code>。复制初始化语法用等号（=），直接初始化则是把初始化式放在括号中。</p><pre><code>int ival = 1024;    // copy-initializationint ival(1024);      // direct-initialization</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span><code>在 C++ 中理解“初始化不是赋值”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。</code></p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>对于字符串，除了以上两种方法之外，也可以通过一个计数器和一个字符初始化string对象。这样创建的对象包含重复多次的指定字符，重复次数由计数器指定：</p><pre><code>std::string all_nines(10, &apos;9&apos;);   // all_nines= &quot;9999999999&quot;</code></pre><p><code>内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成 0，在函数体里定义的内置类型变量不进行自动初始化。</code></p><p>如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即默认构造函数来实现的。这个构造函数之所以被称作默认构造函数，是因为它是“默认”运行的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。</p><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>因为常量在定义后就不能被修改，所以定义时必须初始化：</p><pre><code>const std::string hi = &quot;hello!&quot;; // ok: initializedconst int i, j = 0;  // error: i is uninitialized const</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>与其他变量不同，除非特别说明，在全局作用域声明的 const 变量是定义该对象的文件的局部变量。此变量只存在于那个文件中，不能被其他文件访问。</p><p><code>非 const 变量默认为 extern。要使 const 变量能够在其他的文件中访问，必须地指定它为 extern。</code></p><h2 id="2-5引用"><a href="#2-5引用" class="headerlink" title="2.5引用"></a>2.5引用</h2><p>引用是一种复合类型，是对象的另一个名字，通过在变量名前添加“&amp;”符号来定义。复合类型是指用其他类型定义的类型。在引用的情况下，每一种引用类型都“关联到”某一其他类型。<code>不能定义引用类型的引用，但可以定义任何其他类型的引用。</code></p><p>引用必须用与该引用同类型的对象初始化：</p><pre><code>int ival = 1024;int &amp;refVal = ival; // ok: refVal refers to ivalint &amp;refVal2;       // error: a reference must be initializedint &amp;refVal3 = 10;  // error: initializer must be an object</code></pre><p>当引用初始化后，只要该引用存在，它就保持绑定到初始化时指向的对象。不可能将引用绑定到另一个对象。`</p><p>const 引用是指向 const 对象的引用：</p><pre><code>const int ival = 1024;const int &amp;refVal = ival;      // ok: both reference and object are constint &amp;ref2 = ival;              // error: non const reference to a const object</code></pre><p>const 引用可以初始化为不同类型的对象或者初始化为右值（第 2.3.1 节），如字面值常量：</p><pre><code>int i = 42;//  legal for const references onlyconst int &amp;r = 42;const int &amp;r2 = r + i;</code></pre><p>同样的初始化对于非 const 引用却是不合法的，而且会导致编译时错误。其原因非常微妙，值得解释一下。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>观察将引用绑定到不同的类型时所发生的事情，最容易理解上述行为。假如我们编写</p><pre><code>double dval = 3.14;const int &amp;ri = dval;</code></pre><p>编译器会把这些代码转换成如以下形式的编码：</p><pre><code>int temp = dval;          // create temporary int from the doubleconst int &amp;ri = temp;   // bind ri to that temporary</code></pre><p>如果 ri 不是 const，那么可以给 ri 赋一新值。这样做不会修改 dval，而是修改了 temp。期望对 ri 的赋值会修改 dval 的程序员会发现 dval 并没有被修改。仅允许 const 引用绑定到需要临时使用的值完全避免了这个问题，因为 const 引用是只读的。</p><p>非 const 引用只能绑定到与该引用同类型的对象。</p><p>const 引用则可以绑定到不同但相关的类型的对象或绑定到右值。</p><h2 id="2-7枚举"><a href="#2-7枚举" class="headerlink" title="2.7枚举"></a>2.7枚举</h2><p>枚举的定义包括关键字 enum，其后是一个可选的枚举类型名，和一个用花括号括起来、用逗号分开的枚举成员列表。</p><p>默认地，第一个枚举成员赋值为 0，后面的每个枚举成员赋的值比前面的大 1。</p><p>例如，可以定义下列枚举类型：</p><pre><code>// shape is 1, sphere is 2, cylinder is 3, polygon is 4enum Forms {shape = 1, sphere, cylinder, polygon};</code></pre><p>在 枚举类型 Forms 中，显式将 shape 赋值为 1。其他枚举成员隐式初始化：sphere 初始化为 2，cylinder 初始化为 3，polygon 初始化为 4。</p><p>可以为一个或多个枚举成员提供初始值，用来初始化枚举成员的值必须是一个常量表达式。常量表达式是编译器在编译时就能够计算出结果的整型表达式。整型字面值常量是常量表达式。</p><p>可以定义下列枚举类型：</p><pre><code>// shape is 1, sphere is 2, cylinder is 3, polygon is 4enum Forms {shape = 1, sphere, cylinder, polygon};</code></pre><p>在 枚举类型 Forms 中，显式将 shape 赋值为 1。其他枚举成员隐式初始化：sphere 初始化为 2，cylinder 初始化为 3，polygon 初始化为 4。</p><p>枚举成员值可以是不唯一的。</p><pre><code>// point2d is 2, point2w is 3, point3d is 3, point3w is 4enum Points { point2d = 2, point2w,              point3d = 3, point3w };</code></pre><p>本例中，枚举成员 point2d 显式初始化为 2。下一个枚举成员 point2w 默认初始化，即它的值比前一枚举成员的值大 1。因此 point2w 初始化为 3。枚举成员 point3d 显式初始化为 3。一样，point3w 默认初始化，结果为 4。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>每个 enum 都定义一种唯一的类型。枚举类型的对象的初始化或赋值，只能通过其枚举成员或同一枚举类型的其他对象来进行：</p><pre><code>Points pt3d = point3d; //  ok: point3d is a Points enumeratorPoints pt2w = 3;       //  error: pt2w initialized with intpt2w = polygon;        //  error: polygon is not a Points enumeratorpt2w = pt3d;           //  ok: both are objects of Points enum type</code></pre><h2 id="2-8类类型"><a href="#2-8类类型" class="headerlink" title="2.8类类型"></a>2.8类类型</h2><p>用 class 和 struct 关键字定义类的唯一差别在于默认访问级别：默认情况下，struct 的成员为 public，而 class 的成员为 private。</p><h2 id="2-9-编写自己的头文件"><a href="#2-9-编写自己的头文件" class="headerlink" title="2.9. 编写自己的头文件"></a>2.9. 编写自己的头文件</h2><p>头文件用于声明而不是用于定义。当设计头文件时，记住定义和声明的区别是很重要的。定义只可以出现一次，而声明则可以出现多次（第 2.3.5 节）。下列语句是一些定义，所以不应该放在头文件里：</p><pre><code>extern int ival = 10;      // initializer, so it&apos;s a definitiondouble fica_rate;          // no extern, so it&apos;s a definition</code></pre><p>虽然 ival 声明为 extern，但是它有初始化式，代表这条语句是一个定义。类似地，fica_rate 的声明虽然没有初始化式，但也是一个定义，因为没有关键字 extern。同一个程序中有两个以上文件含有上述任一个定义都会导致多重定义链接错误。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>对于头文件不应该含有定义这一规则，有三个例外。头文件可以定义类、值在编译时就已知道的 const 对象和 inline 函数（第 7.6 节介绍 inline 函数）。这些实体可在多个源文件中定义，只要每个源文件中的定义是相同的。</p><p>如果 const 变量不是用常量表达式初始化，那么它就不应该在头文件中定义。相反，和其他的变量一样，该 const 变量应该在一个源文件中定义并初始化。应在头文件中为它添加 extern 声明，以使其能被多个文件共享。</p><h1 id="3标准库类型"><a href="#3标准库类型" class="headerlink" title="3标准库类型"></a>3标准库类型</h1><hr><h2 id="3-1-命名空间的-using-声明"><a href="#3-1-命名空间的-using-声明" class="headerlink" title="3.1. 命名空间的 using 声明"></a>3.1. 命名空间的 using 声明</h2><pre><code>using std::cin;using std::string;</code></pre><p>有一种情况下，必须总是使用完全限定的标准库名字：在头文件中。理由是头文件的内容会被预处理器复制到程序中。用 #include 包含文件时，相当于头文件中的文本将成为我们编写的文件的一部分。如果在头文件中放置 using 声明，就相当于在包含该头文件 using 的每个程序中都放置了同一 using，不论该程序是否需要 using 声明。</p><h2 id="3-2-标准库-string-类型"><a href="#3-2-标准库-string-类型" class="headerlink" title="3.2. 标准库 string 类型"></a>3.2. 标准库 string 类型</h2><p>几种初始化 string 对象的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1; 默认构造函数 s1 为空串</span><br><span class="line"></span><br><span class="line">string s2(s1);将 s2 初始化为 s1 的一个副本</span><br><span class="line"></span><br><span class="line">string s3(&quot;value&quot;);将 s3 初始化为一个字符串字面值副本</span><br><span class="line"></span><br><span class="line">string s4(n, &apos;c&apos;);将 s4 初始化为字符 &apos;c&apos; 的 n 个副本</span><br></pre></td></tr></table></figure><h3 id="String对象的读写"><a href="#String对象的读写" class="headerlink" title="String对象的读写"></a>String对象的读写</h3><pre><code>int main() {    string s;          // empty string    cin &gt;&gt; s;          // read whitespace-separated string into s    cout &lt;&lt; s &lt;&lt; endl; // write s to the output    return 0;}</code></pre><p>以上程序首先定义命名为 s 的 string 第二行代码：</p><pre><code>cin &gt;&gt; s;        // read whitespace-separated string into s</code></pre><p>从标准输入读取 string 并将读入的串存储在 s 中。string 类型的输入操作符：</p><ol><li>读取并忽略开头所有的<code>空白字符（如空格，换行符，制表符）</code>。</li><li>读取字符直至再次遇到空白字符，读取终止。</li></ol><p>如果输入是”Hello World!”（注意到开头和结尾的空格），则屏幕上将输出”Hello”，而不含任何空格。</p><p>另外还有一个有用的 string IO 操作：getline。这个函数接受两个参数：一个输入流对象和一个 string 对象。getline 函数从输入流的下一行读取，并保存读取的内容到不包括<code>换行符</code>。和输入操作符不一样的是，getline 并不忽略行开头的换行符。只要 getline 遇到换行符，即便它是输入的第一个字符，getline 也将停止读入并返回。如果第一个字符就是换行符，则 string 参数将被置为空 string。</p><p>由于 line 不含换行符，若要逐行输出需要自行添加。照常，我们用 endl 来输出一个换行符并刷新输出缓冲区。</p><h3 id="String对象的操作"><a href="#String对象的操作" class="headerlink" title="String对象的操作"></a>String对象的操作</h3><table><thead><tr><th>s.empty()</th><th>如果 s 为空串，则返回 true，否则返回 false。</th></tr></thead><tbody><tr><td>s.size()</td><td>返回 s 中字符的个数</td></tr><tr><td>s[n]</td><td>返回 s 中位置为 n 的字符，位置从 0 开始计数</td></tr><tr><td>s1 + s2</td><td>把 s1 和s2 连接成一个新字符串，返回新生成的字符串</td></tr><tr><td>s1 = s2</td><td>把 s1 内容替换为 s2 的副本</td></tr><tr><td>v1 == v2</td><td>比较 v1 与 v2的内容，相等则返回 true，否则返回 false</td></tr><tr><td>!=, &lt;, &lt;=, &gt;, and &gt;=</td><td>保持这些操作符惯有的含义</td></tr></tbody></table><p>size 操作返回的是 <code>string::size_type</code> 类型的值。string 类类型和许多其他库类型都定义了一些配套类型（companion type）。通过这些配套类型，库类型的使用就能与机器无关（machine-independent）。size_type 就是这些配套类型中的一种。它定义为与 unsigned 型（unsigned int 或 unsigned long）具有相同的含义，而且可以保证足够大能够存储任意 string 对象的长度。为了使用由 string 类型定义的 size_type 类型是由 string 类定义。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>任何存储 string 的 size 操作结果的变量必须为 string::size_type 类型。特别重要的是，还要把 size 的返回值赋给一个 int 变量。（size_type是unsigned类型的，而有些机器int型仅为16位）</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>string 对象比较操作是区分大小写的，即同一个字符的大小写形式被认为是两个不同的字符。在多数计算机上，大写的字母位于小写之前：任何一个大写之母都小于任意的小写字母。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>当进行 string 对象和字符串字面值混合连接操作时，+ 操作符的左右操作数必须至少有一个是 string 类型的：</p><pre><code>string s1 = &quot;hello&quot;;   // no punctuationstring s2 = &quot;world&quot;;string s3 = s1 + &quot;, &quot;;           // ok: adding a string and a literalstring s4 = &quot;hello&quot; + &quot;, &quot;;      // error: no string operandstring s5 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has string operandstring s6 = &quot;hello&quot; + &quot;, &quot; + s2; // error: can&apos;t add string literals</code></pre><p>s5 的初始化方法显得有点不可思议，但这种用法和标准输入输出的串联效果是一样的（1.2 节）。本例中，string 标准库定义加操作返回一个 string 对象。这样，在对 s5 进行初始化时，子表达式 s1 + “, “ 将返回一个新 string 对象，后者再和字面值 “world\n”连接。</p><p><code>string 类型通过下标操作符（[ ]）来访问 string 对象中的单个字符。下标操作符需要取一个 size_type 类型的值，来标明要访问字符的位置。这个下标中的值通常被称为“下标”或“索引”（index）</code></p><p>和变量一样，string 对象的下标操作返回值也是左值。因此，下标操作可以放于赋值操作符的左边或右边。通过下面循环把 str 对象的每一个字符置为 ‘*’：</p><pre><code>for (string::size_type ix = 0; ix != str.size(); ++ix)    str[ix] = &apos;*&apos;;</code></pre><p>任何可产生整型值的表达式可用作下标操作符的索引。例如，假设 someval 和 someotherval 是两个整形对象，可以这样写：</p><pre><code>str[someotherval * someval] = someval;</code></pre><p>虽然任何整型数值都可作为索引，但索引的实际数据类型却是类型 unsigned 类型 string::size_type。</p><h3 id="string对象中字符的处理"><a href="#string对象中字符的处理" class="headerlink" title="string对象中字符的处理"></a>string对象中字符的处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)</span><br><span class="line"></span><br><span class="line"> True if c is a letter or a digit.</span><br><span class="line"></span><br><span class="line">如果 c 是字母或数字，则为 True。</span><br><span class="line"></span><br><span class="line">isalpha(c)</span><br><span class="line"></span><br><span class="line"> true if c is a letter.</span><br><span class="line"></span><br><span class="line">如果 c 是字母，则为 true。</span><br><span class="line"></span><br><span class="line">iscntrl(c)</span><br><span class="line"></span><br><span class="line"> true if c is a control character.</span><br><span class="line"></span><br><span class="line">如果 c 是控制字符，则为 true </span><br><span class="line"></span><br><span class="line">isdigit(c)</span><br><span class="line"></span><br><span class="line"> true if c is a digit.</span><br><span class="line"></span><br><span class="line">如果 c 是数字，则为 true。</span><br><span class="line"></span><br><span class="line">isgraph(c)</span><br><span class="line"></span><br><span class="line"> true if c is not a space but is printable.</span><br><span class="line"></span><br><span class="line">如果 c 不是空格，但可打印，则为 true。</span><br><span class="line"></span><br><span class="line">islower(c)</span><br><span class="line"></span><br><span class="line"> true if c is a lowercase letter.</span><br><span class="line"></span><br><span class="line">如果 c 是小写字母，则为 true。</span><br><span class="line"></span><br><span class="line">isprint(c)</span><br><span class="line"></span><br><span class="line"> True if c is a printable character.</span><br><span class="line"></span><br><span class="line">如果 c 是可打印的字符，则为 true。</span><br><span class="line"></span><br><span class="line">ispunct(c)</span><br><span class="line"></span><br><span class="line"> True if c is a punctuation character.</span><br><span class="line"></span><br><span class="line">如果 c 是标点符号，则 true。</span><br><span class="line"></span><br><span class="line">isspace(c)</span><br><span class="line"></span><br><span class="line"> true if c is whitespace.</span><br><span class="line"></span><br><span class="line">如果 c 是空白字符，则为 true。</span><br><span class="line"></span><br><span class="line">isupper(c)</span><br><span class="line"></span><br><span class="line"> True if c is an uppercase letter.</span><br><span class="line"></span><br><span class="line">如果 c 是大写字母，则 true。</span><br><span class="line"></span><br><span class="line">isxdigit(c)</span><br><span class="line"></span><br><span class="line"> true if c is a hexadecimal digit.</span><br><span class="line"></span><br><span class="line">如果是 c 十六进制数，则为 true。</span><br><span class="line"></span><br><span class="line">tolower(c)</span><br><span class="line"></span><br><span class="line"> If c is an uppercase letter, returns its lowercase equivalent; otherwise returns c unchanged.</span><br><span class="line"></span><br><span class="line">如果 c 大写字母，返回其小写字母形式，否则直接返回 c。</span><br><span class="line"></span><br><span class="line">toupper(c)</span><br><span class="line"></span><br><span class="line"> If c is a lowercase letter, returns its uppercase equivalent; otherwise returns c unchanged.</span><br><span class="line"></span><br><span class="line">如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c。</span><br></pre></td></tr></table></figure><p>这些函数都在 cctype 头文件中定义。</p><h2 id="3-3-标准库-vector-类型"><a href="#3-3-标准库-vector-类型" class="headerlink" title="3.3. 标准库 vector 类型"></a>3.3. 标准库 vector 类型</h2><p>vector 是<code>同一种类型的对象的集合</code>，每个对象都有一个对应的整数索引值。我们把 vector 称为容器，是因为它可以包含其他对象。一个容器中的所有对象都必须是同一种类型的。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>vector 不是一种数据类型，而只是一个类模板，可用来定义任意多种数据类型。vector 类型的每一种都指定了其保存元素的类型。因此，vector<int> 和 vector<string> 都是数据类型。</string></int></p><p>初始化方法：</p><table><thead><tr><th>vector<t> v1;</t></th><th>vector 保存类型为 T 对象。</th></tr></thead><tbody><tr><td>vector<t> v2(v1);</t></td><td>v2 是 v1 的一个副本。</td></tr><tr><td>vector<t> v3(n, i);</t></td><td>v3 包含 n 个值为 i 的元素。</td></tr><tr><td>vector<t> v4(n);</t></td><td>v4 含有值初始化的元素的 n 个副本。（依据类型初始值）</td></tr></tbody></table><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>vector 对象（以及其他标准库容器对象）的重要属性就在于可以在运行时高效地添加元素。因为 vector 增长的效率高，在元素值已知的情况下，最好是动态地添加元素。</p><h3 id="vector对象的操作"><a href="#vector对象的操作" class="headerlink" title="vector对象的操作"></a>vector对象的操作</h3><table><thead><tr><th>v.empty()</th><th>如果 v 为空，则返回 true，否则返回 false。</th></tr></thead><tbody><tr><td>v.size()</td><td>返回 v 中元素的个数。</td></tr><tr><td><code>v.push_back(t)</code></td><td>在 v 的末尾增加一个值为 t 的元素。</td></tr><tr><td>v[n]</td><td>返回 v 中位置为 n 的元素。</td></tr><tr><td>v1 = v2</td><td>把 v1 的元素替换为 v2 中元素的副本。</td></tr><tr><td>v1 == v2</td><td>如果 v1 与 v2 相等，则返回 true。</td></tr><tr><td>!=, &lt;, &lt;=,</td><td>保持这些操作符惯有的含义。</td></tr></tbody></table><p>成员函数 size 返回相应 vector 类定义的 size_type 的值。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>使用 size_type 类型时，必须指出该类型是在哪里定义的。vector 类型总是包括总是包括 vector 的元素类型：</p><pre><code>vector&lt;int&gt;::size_type        // okvector::size_type            // error</code></pre><p>下标操作不添加元素。</p><h2 id="3-4-迭代器简介"><a href="#3-4-迭代器简介" class="headerlink" title="3.4. 迭代器简介"></a>3.4. 迭代器简介</h2><p>除了使用下标来访问 vector 对象的元素外，标准库还提供了另一种访问元素的方法：使用迭代器（iterator）。迭代器是一种检查容器内元素并遍历元素的数据类型。</p><p>标准库为每一种标准容器（包括 vector）定义了一种迭代器类型。迭代器类型提供了比下标操作更通用化的方法：<code>所有的标准库容器都定义了相应的迭代器类型，而只有少数的容器支持下标操作</code>。因为迭代器对所有的容器都适用，现代 C++ 程序更倾向于使用迭代器而不是下标操作访问容器元素，即使对支持下标操作的 vector 类型也是这样。</p><p>每种容器都定义了一对命名为 begin 和 end 的函数，用于返回迭代器。如果容器中有元素的话，由 begin 返回的迭代器指向第一个元素：</p><pre><code>vector&lt;int&gt;::iterator iter = ivec.begin();</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>由 end 操作返回的迭代器指向 vector 的“末端元素的下一个”。“超出末端迭代器”（off-the-end iterator）。表明它指向了一个不存在的元素。如果 vector 为空，begin 返回的迭代器与 end 返回的迭代器相同。由 end 操作返回的迭代器并不指向 vector 中任何实际的元素，相反，它只是起一个哨兵（sentinel）的作用，表示我们已处理完 vector 中所有元素。</p><p>迭代器类型可使用解引用操作符（dereference operator）（*）来访问迭代器所指向的元素：</p><pre><code>*iter = 0;</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>每种容器类型还定义了一种名为 const_iterator 的类型，该类型只能用于读取容器内元素，但不能改变其值。</p><h3 id="迭代器的算数操作"><a href="#迭代器的算数操作" class="headerlink" title="迭代器的算数操作"></a>迭代器的算数操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iter + n</span><br><span class="line"></span><br><span class="line">iter - n</span><br><span class="line"></span><br><span class="line">iter1 - iter2</span><br></pre></td></tr></table></figure><h2 id="3-5-标准库-bitset"><a href="#3-5-标准库-bitset" class="headerlink" title="3.5. 标准库 bitset"></a>3.5. 标准库 bitset</h2><p>bitset初始化：</p><table><thead><tr><th>bitset<n> b;</n></th><th>b 有 n 位，每位都 0</th></tr></thead><tbody><tr><td>bitset<n> b(u);</n></td><td>b 是 unsigned long 型 u 的一个副本</td></tr><tr><td>bitset<n> b(s);</n></td><td>b 是 string 对象 s 中含有的位串的副本</td></tr><tr><td>bitset<n> b(s, pos, n);</n></td><td>b 是 s 中从位置 pos 开始的&nbps;n 个位的副本</td></tr></tbody></table><p>当用 unsigned long 值作为 bitset 对象的初始值时，该值将转化为二进制的位模式。而 bitset 对象中的位集作为这种位模式的副本。如果 bitset 类型长度大于 unsigned long 值的二进制位数，则其余的高阶位将置为 0；如果 bitset 类型长度小于 unsigned long 值的二进制位数，则只使用 unsigned 值中的低阶位，超过 bistset 类型长度的高阶位将被丢弃。</p><p>在 32 位 unsigned long 的机器上，十六进制值 0xffff 表示为二进制位就是十六个 1 和十六个 0（每个 0xf 可表示为 1111）。可以用 0xffff 初始化 bitset 对象：</p><pre><code>// bitvec1 is smaller than the initializerbitset&lt;16&gt; bitvec1(0xffff);          // bits 0 ... 15 are set to 1// bitvec2 same size as initializerbitset&lt;32&gt; bitvec2(0xffff);          // bits 0 ... 15 are set to 1; 16 ... 31 are 0// on a 32-bit machine, bits 0 to 31 initialized from 0xffffbitset&lt;128&gt; bitvec3(0xffff);         // bits 32 through 127 initialized to zero</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>当用 string 对象初始化 bitset 对象时，string 对象直接表示为位模式。从 string 对象读入位集的顺序是从右向左（from right to left）：</p><pre><code>string strval(&quot;1100&quot;);bitset&lt;32&gt; bitvec4(strval);</code></pre><p>bitvec4 的位模式中第 2 和 3 的位置为 1，其余位置都为 0。如果 string 对象的字符个数小于 bitset 类型的长度，则高阶位置为 0。</p><p>string 对象和 bitsets 对象之间是反向转化的：string 对象的最右边字符（即下标最大的那个字符）用来初始化 bitset 对象的低阶位（即下标为 0 的位）。当用 string 对象初始化 bitset 对象时，记住这一差别很重要。</p><p>不一定要把整个 string 对象都作为 bitset 对象的初始值。相反，可以只用某个子串作为初始值：</p><pre><code>string str(&quot;1111111000000011001101&quot;);bitset&lt;32&gt; bitvec5(str, 5, 4); // 4 bits starting at str[5], 1100bitset&lt;32&gt; bitvec6(str, str.size() - 4);     // use last 4 characters</code></pre><p>这里用 str 从 str[5] 开始包含四个字符的子串来初始化 bitvec5。照常，初始化 bitset 对象时总是从子串最右边结尾字符开始的，bitvec5 的从 3 到 0 的二进制位置为 1100 ，其他二进制位都置为 0。如果省略第三个参数则意味着取从开始位置一直到 string 末尾的所有字符。本例中，取出 str 末尾的四位来对 bitvec6 的低四位进行初始化。bitvec6 其余的位初始化为 0。</p><table><thead><tr><th>b.any()</th><th>b 中是否存在置为 1 的二进制位？</th></tr></thead><tbody><tr><td>b.none()</td><td>Are no bits in b on?</td></tr><tr><td>b.count()</td><td>b 中不存在置为 1 的二进制位吗？</td></tr><tr><td>b.size()</td><td>b 中置为 1 的二进制位的个数（返回类型为size_t）</td></tr><tr><td>b[pos]</td><td>访问 b 中在 pos 处二进制位</td></tr><tr><td>b.test(pos)</td><td>b 中在 pos 处的二进制位置为 1</td></tr><tr><td>b.set()</td><td>Turn on all bits in b</td></tr><tr><td>b.set(pos)</td><td>把 b 中在 pos 处的二进制位置为 1</td></tr><tr><td>b.reset()</td><td>把 b 中所有二进制位都置为 0</td></tr><tr><td>b.reset(pos)</td><td>把 b 中在 pos 处的二进制位置为 0</td></tr><tr><td>b.flip()</td><td>把 b 中所有二进制位逐位取反</td></tr><tr><td>b.flip(pos)</td><td>把 b 中在 pos 处的二进制位取反</td></tr><tr><td>b.to_ulong()</td><td>把 b 中在 pos 处的二进制位取反</td></tr><tr><td>os &lt;&lt; b</td><td>把 b 中的位集输出到 os 流</td></tr></tbody></table><h1 id="4数组和指针"><a href="#4数组和指针" class="headerlink" title="4数组和指针"></a>4数组和指针</h1><hr><p>数组的长度是固定的。数组一经创建，就不允许添加新的元素。</p><p><code>现代 C++ 程序应尽量使用 vector 和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</code></p><p>数组的维数必须用值大于等于1的常量表达式定义（第 2.7 节）。此常量表达式只能包含整型字面值常量、枚举常量（第 2.7 节）或者用常量表达式初始化的整型 const 对象。非 const 变量以及要到运行阶段才知道其值的 const 变量都不能用于定义数组的维数。</p><p>数组的维数必须在一对方括号 [] 内指定：</p><pre><code> // both buf_size and max_files are const const unsigned buf_size = 512, max_files = 20; int staff_size = 27;            // nonconst const unsigned sz = get_size();  // const value not known until run time char input_buffer[buf_size];     // ok: const variable string fileTable[max_files + 1]; // ok: constant expression`double salaries[staff_size];     // error: non const variable` int test_scores[get_size()];     // error: non const expression int vals[sz];                    // error: size not known until run time</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>非const变量不能初始化数组。</p><pre><code>char ca1[] = {&apos;C&apos;, &apos;+&apos;, &apos;+&apos;};                // no nullchar ca2[] = {&apos;C&apos;, &apos;+&apos;, &apos;+&apos;, &apos;\0&apos;};         // explicit nullchar ca3[] = &quot;C++&quot;;     // null terminator added automatically</code></pre><p>ca1 的维数是 3，而 ca2 和 ca3 的维数则是 4。使用一组字符字面值初始化字符数组时，一定要记得添加结束字符串的空字符。例如，下面的初始化将导致编译时的错误：</p><pre><code>const char ch3[6] = &quot;Daniel&quot;; // error: Daniel is 7 elements</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>与vector不同，一个数组不能用另外一个数组初始化，也不能将一个数组赋值给另一个数组，这些操作都是非法的：</p><pre><code>int ia[] = {0, 1, 2}; // ok: array of intsint ia2[](ia);        // error: cannot initialize one array with anotherint main(){    const unsigned array_size = 3;    int ia3[array_size]; // ok: but elements are uninitialized!    ia3 = ia;           //  error: cannot assign one array to another    return 0;}</code></pre><p>数组下标的正确类型则是 <code>size_t</code>。</p><h2 id="4-2指针的引入"><a href="#4-2指针的引入" class="headerlink" title="4.2指针的引入"></a>4.2指针的引入</h2><p>C++ 语言使用 * 符号把一个标识符声明为指针：</p><pre><code>vector&lt;int&gt;   *pvec;      // pvec can point to a vector&lt;int&gt;int           *ip1, *ip2; // ip1 and ip2 can point to an intstring        *pstring;   // pstring can point to a stringdouble        *dp;        // dp can point to a double</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span><strong>另一种声明指针的风格：</strong> 在定义指针变量时，可用空格将符号 * 与其后的标识符分隔开来。下面的写法是合法的：</p><pre><code>string* ps; // legal but can be misleading</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string* ps1, ps2; // ps1 is a pointer to string,  ps2 is a string</span><br></pre></td></tr></table></figure><p>实际上只把 ps1 定义为指针，而 ps2 并非指针，只是一个普通的 string 对象而已。如果需要在一个声明语句中定义两个指针，必须在每个变量标识符前再加符号 * 声明：</p><pre><code>string* ps1, *ps2; // both ps1 and ps2 are pointers to string</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>一个有效的指针必然是以下三种状态之一：保存一个特定对象的地址；指向某个对象后面的另一对象；或者是0值。若指针保存0值，表明它不指向任何对象。</p><p>对指针进行初始化或赋值只能使用以下四种类型的值：</p><ol><li>0 值常量表达式（第 2.7 节），例如，在编译时可获得 0 值的整型 const 对象或字面值常量 0。</li><li>类型匹配的对象的地址。</li><li>另一对象末的下一地址。</li><li>同类型的另一个有效指针。</li></ol><p>把 int 型变量赋给指针是非法的，尽管此 int 型变量的值可能为 0。但允许把数值 0 或在编译时可获得 0 值的 const 量赋给指针：</p><pre><code>int ival;int zero = 0;const int c_ival = 0;int *pi = ival; // error: pi initialized from int value of ivalpi = zero;      // error: pi assigned int value of zeropi = c_ival;    // ok: c_ival is a const with compile-time value of 0pi = 0;         // ok: directly initialize to literal constant 0</code></pre><h3 id="void指针"><a href="#void指针" class="headerlink" title="void指针"></a>void指针</h3><p>C++ 提供了一种特殊的指针类型 void*，它可以保存任何类型对象的地址：</p><pre><code>double obj = 3.14;double *pd = &amp;obj;// ok: void* can hold the address value of any data pointer typevoid *pv = &amp;obj;       // obj can be an object of any typepv = pd;               // pd can be a pointer to any type</code></pre><p>void* 表明该指针与一地址值相关，但不清楚存储在此地址上的对象的类型。</p><p>C++ 还支持对这两个指针做减法操作：</p><pre><code>ptrdiff_t n = ip2 - ip; // ok: distance between the pointers</code></pre><p>结果是 4，这两个指针所指向的元素间隔为 4 个对象。两个指针减法操作的结果是标准库类型（library type）ptrdiff_t 的数据。与 size_t 类型一样，ptrdiff_t 也是一种与机器相关的类型，在 cstddef 头文件中定义。size_t 是 unsigned 类型，而 ptrdiff_t 则是 signed 整型。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>ia[0] 是一个使用数组名的表达式。在使用下标访问数组时，实际上是对指向数组元素的指针做下标操作。只要指针指向数组元素，就可以对它进行下标操作：</p><pre><code>int *p = &amp;ia[2];     // ok: p points to the element indexed by 2int j = p[1];        // ok: p[1] equivalent to *(p + 1),                     //    p[1] is the same element as ia[3]int k = p[-2];       // ok: p[-2] is the same element as ia[0]</code></pre><p>C++ 允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端位置之后或数组首地址之前的地址都是不合法的。</p><h3 id="指向const的指针"><a href="#指向const的指针" class="headerlink" title="指向const的指针"></a>指向const的指针</h3><p>到目前为止，我们使用指针来修改其所指对象的值。但是如果指针指向 const 对象，则不允许用指针来改变其所指的 const 值。为了保证这个特性，C++ 语言强制要求指向 const 对象的指针也必须具有 const 特性：</p><pre><code>const double pi = 3.14;double *ptr = &amp;pi;        // error: ptr is a plain pointerconst double *cptr = &amp;pi; // ok: cptr is a pointer to const</code></pre><p>不能使用 void<em> 指针（第 4.2.2 节）保存 const 对象的地址，而必须使用 const void</em> 类型的指针保存 const 对象的地址：</p><p>允许把非 const 对象的地址赋给指向 const 对象的指针，但不能通过指针来修改对象。</p><h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h3><p>除指向 const 对象的指针外，C++ 语言还提供了 const 指针——本身的值不能修改：</p><pre><code>int errNumb = 0;int *const curErr = &amp;errNumb; // curErr is a constant pointer</code></pre><p>我们可以从右向左把上述定义语句读作“curErr 是指向 int 型对象的 const 指针”。与其他 const 量一样，const 指针的值不能修改，这就意味着不能使 curErr 指向其他对象。任何企图给 const 指针赋值的行为（即使给 curErr 赋回同样的值）都会导致编译时的错误：</p><h2 id="4-3-C风格字符串与动态数组"><a href="#4-3-C风格字符串与动态数组" class="headerlink" title="4.3 C风格字符串与动态数组"></a>4.3 C风格字符串与动态数组</h2><p>字符串字面值的类型就是 const char 类型的数组。</p><p>数组类型的变量有三个重要的限制：数组长度固定不变，在编译时必须知道其长度，数组只在定义它的块语句内存在。实际的程序往往不能忍受这样的限制——它们需要在运行时动态地分配数组。虽然数组长度是固定的，但动态分配的数组不必在编译时知道其长度，可以（通常也是）在运行时才确定数组长度。与数组变量不同，动态分配的数组将一直存在，直到程序显式释放它为止。</p><p>每一个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间称为程序的自由存储区或堆。C 语言程序使用一对标准库函数 malloc 和 free 在自由存储区中分配存储空间，而 C++ 语言则使用 new 和 delete 表达式实现相同的功能。</p><p>动态分配数组时，如果数组元素具有类类型，将使用该类的默认构造函数（第 2.3.4 节）实现初始化；如果数组元素是内置类型，则无初始化：</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>如果我们在自由存储区中创建的数组存储了内置类型的 const 对象，则必须为这个数组提供初始化：因为数组元素都是 const 对象，无法赋值。实现这个要求的唯一方法是对数组做值初始化：</p><pre><code>// error: uninitialized const arrayconst int *pci_bad = new const int[100];// ok: value-initialized const arrayconst int *pci_ok = new const int[100]();</code></pre><h1 id="5表达式"><a href="#5表达式" class="headerlink" title="5表达式"></a>5表达式</h1><hr><h2 id="5-1算数操作符"><a href="#5-1算数操作符" class="headerlink" title="5.1算数操作符"></a>5.1算数操作符</h2><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span><code>C++提供了一元操作符和二元操作符两种操作符。除此之外，C++ 还提供了一个使用三个操作数的三元操作符（ternary operator）：条件操作符。</code></p><p>对两个整数做除法，结果仍为整数，如果它的商包含小数部分，则小数部分会被截除。</p><p>操作符 % 称为“求余（remainder）”或“求模（modulus）”操作符，用于计算左操作数除以右操作数的余数。<code>该操作符的操作数只能为整型，包括 bool、char、short 、int 和 long 类型，以及对应的 unsigned 类型。</code></p><p>如果两个操作数为正，除法（/）和求模（%）操作的结果也是正数（或零）；如果两个操作数都是负数，除法操作的结果为正数（或零），而求模操作的结果则为负数（或零）；如果只有一个操作数为负数，这两种操作的结果取决于机器；求模结果的符号也取决于机器，而除法操作的值则是负数（或零）。</p><p>当只有一个操作数为负数时，求模操作结果值的符号可依据分子（被除数）或分母（除数）的符号而定。如果求模的结果随分子的符号，则除出来的值向零一侧取整；如果求模与分母的符号匹配，则除出来的值向负无穷一侧取整。</p><h2 id="5-2关系操作符和逻辑操作符"><a href="#5-2关系操作符和逻辑操作符" class="headerlink" title="5.2关系操作符和逻辑操作符"></a>5.2关系操作符和逻辑操作符</h2><h2 id="5-3位操作符"><a href="#5-3位操作符" class="headerlink" title="5.3位操作符"></a>5.3位操作符</h2><p>~        bitwise NOT（位求反）</p><p>&lt;&lt;        left shift（左移）</p><p>>>    right shift（右移）</p><p>&amp;        bitwise AND（位与）</p><p>^        bitwise XOR（位异或）</p><p>|        bitwise OR（位或）</p><p><code>输入输出标准库（IO library）分别重载了位操作符 &gt;&gt; 和 &lt;&lt; 用于输入和输出。</code></p><h2 id="5-4赋值操作符"><a href="#5-4赋值操作符" class="headerlink" title="5.4赋值操作符"></a>5.4赋值操作符</h2><p>赋值操作符的左操作数必须是非 const 的左值。下面的赋值语句是不合法的：</p><pre><code> int i, j, ival; const int ci = i;  // ok: initialization not assignment 1024 = ival;       // error: literals are rvalues i + j = ival;      // error: arithmetic expressions are rvalues ci = ival;         // error: can&apos;t write to ciint ival, jval;ival = jval = 0; // ok: each assigned 0</code></pre><p>与其他二元操作符不同，赋值操作具有右结合特性。当表达式含有多个赋值操作符时，从右向左结合。上述表达式，将右边赋值操作的结果（也就是 jval）赋给 ival。多个赋值操作中，各对象必须具有相同的数据类型，或者具有可转换（第 5.12 节）为同一类型的数据类型。</p><h2 id="5-5自增和自减操作符"><a href="#5-5自增和自减操作符" class="headerlink" title="5.5自增和自减操作符"></a>5.5自增和自减操作符</h2><p>建议：只有在必要时才使用后置操作符。道理很简单：因为前置操作需要做的工作更少，只需加 1 后返回加 1 后的结果即可。而后置操作符则必须先保存操作数原来的值，以便返回未加 1 之前的值作为操作的结果。对于 int 型对象和指针，编译器可优化掉这项额外工作。但是对于更多的复杂迭代器类型，这种额外工作可能会花费更大的代价。因此，养成使用前置操作这个好习惯，就不必操心性能差异的问题。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>建议使用使用解引用和自增操作的组合形式：</p><pre><code>vector&lt;int&gt;::iterator iter = ivec.begin();// prints 10 9 8 ... 1 while (iter != ivec.end())     cout &lt;&lt; *iter++ &lt;&lt; endl; // iterator postfix increment</code></pre><p>由于后自增操作的优先级高于解引用操作，因此 <em>iter++ 等效于 </em>(iter++)。子表达式 iter++ 使 iter 加 1，然后返回 iter 原值的副本作为该表达式的结果。因此，解引用操作 * 的操作数是 iter 未加 1 前的副本。</p><h2 id="5-6箭头操作符"><a href="#5-6箭头操作符" class="headerlink" title="5.6箭头操作符"></a>5.6箭头操作符</h2><p>假设有一个指向类类型对象的指针（或迭代器），下面的表达式相互等价：</p><pre><code>(*p).foo; // dereference p to get an object and fetch its member named foop-&gt;foo;   // equivalent way to fetch the foo from the object to which p points</code></pre><h2 id="5-7条件操作符"><a href="#5-7条件操作符" class="headerlink" title="5.7条件操作符"></a>5.7条件操作符</h2><p>条件操作符是 C++ 中唯一的三元操作符，它允许将简单的 if-else 判断语句嵌入表达式中。条件操作符的语法格式为：</p><pre><code>cond ? expr1 : expr2;</code></pre><p>其中，cond 是一个条件判断表达式（第 1.4.1 节）。条件操作符首先计算 cond 的值，如果 cond 的值为 0，则条件为 false；如果 cond 非 0，则条件为 true。无论如何，cond 总是要被计算的。然后，条件为 true 时计算 expr1 ，否则计算 expr2 。和逻辑与、逻辑或（&amp;&amp; 和 ||）操作符一样，条件操作符保证了上述操作数的求解次序。<code>expr1 和 expr2 中只有一个表达式被计算。</code></p><h2 id="5-8-sizeof-操作符"><a href="#5-8-sizeof-操作符" class="headerlink" title="5.8. sizeof 操作符"></a>5.8. sizeof 操作符</h2><p>sizeof 操作符的作用是返回一个对象或类型名的长度，返回值的类型为<code>size_t</code>（第 3.5.2 节），长度的单位是字节。<code>size_t</code>表达式的结果是编译时常量，该操作符有以下三种语法形式：</p><pre><code>sizeof (type name);sizeof (expr);sizeof expr;</code></pre><p>将 sizeof 应用在表达式 expr 上，将获得该表达式的结果的类型长度。</p><p>使用 sizeof 的结果部分地依赖所涉及的类型：</p><ul><li>对 char 类型或值为 char 类型的表达式做 sizeof 操作保证得 1。</li><li>对引用类型做 sizeof 操作将返回存放此引用类型对象所需的内在空间大小。</li><li>对指针做 sizeof 操作将返回存放指针所需的内在大小；注意，如果要获取该指针所指向对象的大小，则必须对指针进行引用。</li><li>对数组做 sizeof 操作等效于将对其元素类型做 sizeof 操作的结果乘上数组元素的个数。</li></ul><h2 id="5-9逗号操作符"><a href="#5-9逗号操作符" class="headerlink" title="5.9逗号操作符"></a>5.9逗号操作符</h2><p>逗号表达式是一组由逗号分隔的表达式，这些表达式从左向右计算。逗号表达式的结果是其最右边表达式的值。如果最右边的操作数是左值，则逗号表达式的值也是左值。此类表达式通常用于for循环：</p><pre><code>int cnt = ivec.size();// add elements from size... 1 to ivecfor(vector&lt;int&gt;::size_type ix = 0;                ix != ivec.size(); ++ix, --cnt)    ivec[ix] = cnt;</code></pre><h2 id="5-11new和delete表达式"><a href="#5-11new和delete表达式" class="headerlink" title="5.11new和delete表达式"></a>5.11new和delete表达式</h2><p>定义变量时，必须指定其数据类型和名字。而动态创建对象时，只需指定其数据类型，而不必为该对象命名。取而代之的是，new 表达式返回指向新创建对象的指针，我们通过该指针来访问此对象：</p><pre><code>int i;              // named, uninitialized int variableint *pi = new int;  // pi points to dynamically allocated,                    // unnamed, uninitialized int</code></pre><p>如果不提供显式初始化，动态创建的对象与在函数内定义的变量初始化方式相同（第 2.3.4 节）。对于类类型的对象，用该类的默认构造函数初始化；而内置类型的对象则无初始化。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>C++ 保证：删除 0 值的指针是安全的。删除指针后，该指针变成悬垂指针。悬垂指针指向曾经存放对象的内存，但该对象已经不再存在了。悬垂指针往往导致程序错误，而且很难检测出来。一旦删除了指针所指向的对象，立即将指针置为 0，这样就非常清楚地表明指针不再指向任何对象。</p><h1 id="5-12类型转换"><a href="#5-12类型转换" class="headerlink" title="5.12类型转换"></a>5.12类型转换</h1><p>C++ 定义了算术类型之间的内置转换以尽可能防止精度损失。通常，如果表达式的操作数分别为整型和浮点型，则整型的操作数被转换为浮点型。</p><h2 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h2><p>显式转换也称为强制类型转换（cast），包括以下列名字命名的强制类型转换操作符：<code>static_cast、dynamic_cast、const_cast 和 reinterpret_cast。</code></p><ol><li>dynamic_cast 支持运行时识别指针或引用所指向的对象。</li><li>const_cast ，顾名思义，将转换掉表达式的 const 性质。</li><li>编译器隐式执行的任何类型转换都可以由 static_cast 显式完成。</li><li>reinterpret_cast 通常为操作数的位模式提供较低层次的重新解释。</li></ol><h1 id="6语句"><a href="#6语句" class="headerlink" title="6语句"></a>6语句</h1><h2 id="6-1-简单语句"><a href="#6-1-简单语句" class="headerlink" title="6.1. 简单语句"></a>6.1. 简单语句</h2><p>如果在程序的某个地方，语法上需要一个语句，但逻辑上并不需要，此时应该使用<code>空语句</code>。这种用法常见于在循环条件判断部分就能完成全部循环工作的情况。</p><h2 id="6-3复合语句"><a href="#6-3复合语句" class="headerlink" title="6.3复合语句"></a>6.3复合语句</h2><p>复合语句，通常被称为块，是用一对花括号括起来的语句序列（也可能是空的）。块标识了一个作用域，在块中引入的名字只能在该块内部或嵌套在块中的子块里访问。通常，一个名字只从其定义处到该块的结尾这段范围内可见。</p><p><code>与其他大多数语句不同，块并不是以分号结束的。</code></p><h2 id="6-5if语句"><a href="#6-5if语句" class="headerlink" title="6.5if语句"></a>6.5if语句</h2><h2 id="6-6-switch-语句"><a href="#6-6-switch-语句" class="headerlink" title="6.6. switch 语句"></a>6.6. switch 语句</h2><p> char ch;</p><pre><code>// initialize counters for each vowelint aCnt = 0, eCnt = 0, iCnt = 0,    oCnt = 0, uCnt = 0;while (cin &gt;&gt; ch) {    // if ch is a vowel, increment the appropriate counter    switch (ch) {        case &apos;a&apos;:            ++aCnt;            break;        case &apos;e&apos;:            ++eCnt;            break;        case &apos;i&apos;:            ++iCnt;            break;        case &apos;o&apos;:            ++oCnt;            break;        case &apos;u&apos;:            ++uCnt;            break;    }}// print resultscout  &lt;&lt; &quot;Number of vowel a: \t&quot; &lt;&lt; aCnt &lt;&lt; &apos;\n&apos;      &lt;&lt; &quot;Number of vowel e: \t&quot; &lt;&lt; eCnt &lt;&lt; &apos;\n&apos;      &lt;&lt; &quot;Number of vowel i: \t&quot; &lt;&lt; iCnt &lt;&lt; &apos;\n&apos;      &lt;&lt; &quot;Number of vowel o: \t&quot; &lt;&lt; oCnt &lt;&lt; &apos;\n&apos;      &lt;&lt; &quot;Number of vowel u: \t&quot; &lt;&lt; uCnt &lt;&lt; endl;</code></pre><p>default 标号提供了相当于 else 子句的功能。如果所有的 case 标号与 switch 表达式的值都不匹配，并且 default 标号存在，则执行 default 标号后面的语句。</p><p>case 标号必须是整型常量表达式。</p><p>对于 switch 结构，只能在它的最后一个 case 标号或 default 标号后面定义变量：</p><h2 id="6-7while语句"><a href="#6-7while语句" class="headerlink" title="6.7while语句"></a>6.7while语句</h2><p><code>在循环条件中定义的变量在每次循环里都要经历创建和撤销的过程。</code></p><h2 id="6-8for循环语句"><a href="#6-8for循环语句" class="headerlink" title="6.8for循环语句"></a>6.8for循环语句</h2><h2 id="6-9do-while语句"><a href="#6-9do-while语句" class="headerlink" title="6.9do while语句"></a>6.9do while语句</h2><h2 id="6-10break语句"><a href="#6-10break语句" class="headerlink" title="6.10break语句"></a>6.10break语句</h2><p>break 语句用于结束最近的 while、do while、for 或 switch 语句，并将程序的执行权传递给紧接在被终止语句之后的语句。</p><h2 id="6-11-continue-语句"><a href="#6-11-continue-语句" class="headerlink" title="6.11. continue 语句"></a>6.11. continue 语句</h2><p>continue 语句导致最近的循环语句的当次迭代提前结束。continue 语句只能出现在 for、while 或者 do while 循环中，包括嵌套在这些循环内部的块语句中。</p><h2 id="6-12-goto-语句"><a href="#6-12-goto-语句" class="headerlink" title="6.12 goto 语句"></a>6.12 goto 语句</h2><h2 id="6-13-try-块和异常处理"><a href="#6-13-try-块和异常处理" class="headerlink" title="6.13 try 块和异常处理"></a>6.13 try 块和异常处理</h2><p>try 块的通用语法形式是：</p><pre><code>try {    program-statements} catch (exception-specifier) {    handler-statements} catch (exception-specifier) {    handler-statements} //...</code></pre><p>try 块以关键字 try 开始，后面是用花括号起来的语句序列块。try 块后面是一个或多个 catch 子句。每个 catch 子句包括三部分：关键字 catch，圆括号内单个类型或者单个对象的声明——称为异常说明符，以及通常用花括号括起来的语句块。如果选择了一个 catch 子句来处理异常，则执行相关的块语句。一旦 catch 子句执行结束，程序流程立即继续执行紧随着最后一个 catch 子句的语句。</p><h2 id="6-14-使用预处理器进行调试"><a href="#6-14-使用预处理器进行调试" class="headerlink" title="6.14. 使用预处理器进行调试"></a>6.14. 使用预处理器进行调试</h2><h1 id="7-函数（※）"><a href="#7-函数（※）" class="headerlink" title="7 函数（※）"></a>7 函数（※）</h1><h2 id="7-1-函数的定义"><a href="#7-1-函数的定义" class="headerlink" title="7.1. 函数的定义"></a>7.1. 函数的定义</h2><p>函数由函数名以及一组操作数类型唯一地表示。函数的操作数，也即形参，在一对圆括号中声明，形参与形参之间以逗号分隔。函数执行的运算在一个称为函数体的块语句中定义。每一个函数都有一个相关联的返回类型。</p><p>C++ 语言使用<code>调用操作符</code>（即一对圆括号）实现函数的调用。</p><p>函数的返回类型可以是内置类型（如 int 或者 double）、类类型或复合类型（如 int&amp; 或 string*），还可以是 void 类型，表示该函数不返回任何值。函数不能返回另一个函数或者内置数组类型，但可以返回指向函数的指针，或指向数组元素的指针的指针。</p><p><code>函数必须指定返回类型。</code></p><p>函数形参表可以为空，但不能省略。没有任何形参的函数可以用空形参表或含有单个关键字 void 的形参表来表示。例如，下面关于 process 的声明是等价的：</p><pre><code>void process() { /* ... */ }      // implicit void parameter list void process(void){ /* ... */ }  // equivalent declaration</code></pre><p>形参表由一系列用逗号分隔的参数类型和（可选的）参数名组成。如果两个参数具有相同的类型，则其类型必须重复声明：</p><pre><code>int manip(int v1, v2) { /* ... */ }      // errorint manip(int v1, int v2) { /* ... */ }  // ok</code></pre><p><code>形参的初始化与变量的初始化一样：如果形参具有非引用类型，则复制实参的值，如果形参为引用类型，则它只是实参的别名。</code></p><h2 id="7-2参数传递"><a href="#7-2参数传递" class="headerlink" title="7.2参数传递"></a>7.2参数传递</h2><h3 id="指针形参"><a href="#指针形参" class="headerlink" title="指针形参"></a>指针形参</h3><p>函数的形参可以是指针（第 4.2 节），此时将复制实参指针。与其他非引用类型的形参一样，该类形参的任何改变也仅作用于局部副本。如果函数将新指针赋给形参，主调函数使用的实参指针的值没有改变。</p><p>事实上被复制的指针只影响对指针的赋值。如果函数形参是非 const 类型的指针，则函数可通过指针实现赋值，修改指针所指向对象的值：</p><pre><code>void reset(int *ip){    *ip = 0; // changes the value of the object to which ip points    ip = 0;   // changes only the local value of ip; the argument is unchanged}void use_ptr(const int *p){     // use_ptr may read but not write to *p}</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>指针形参是指向 const 类型还是非 const 类型，将影响函数调用所使用的实参。我们既可以用 int<em> 也可以用 const int</em> 类型的实参调用 use_ptr 函数；但仅能将 int* 类型的实参传递给 reset 函数。这个差别来源于指针的初始化规则（第 4.2.5 节）。可以将指向 const 对象的指针初始化为指向非 const 对象，但不可以让指向非 const 对象的指针向 const 对象。</p><h3 id="const-形参"><a href="#const-形参" class="headerlink" title="const 形参"></a>const 形参</h3><p><code>在调用函数时，如果该函数使用非引用的非 const 形参，则既可给该函数传递 const 实参也可传递非 const 的实参。</code></p><p>如果将形参定义为非引用的 const 类型：</p><pre><code>void fcn(const int i) { /* fcn can read but not write to i */ }</code></pre><p><code>则在函数中，不可以改变实参的局部副本。</code>由于实参仍然是以副本的形式传递，因此传递给 fcn 的既可以是 const 对象也可以是非 const 对象。</p><h3 id="引用形参"><a href="#引用形参" class="headerlink" title="引用形参"></a>引用形参</h3><pre><code>void swap(int &amp;v1, int &amp;v2){    int tmp = v2;    v2 = v1;    v1 = tmp;}</code></pre><p>与所有引用一样，引用形参直接关联到其所绑定的圣贤，而并非这些对象的副本。定义引用时，必须用与该引用绑定的对象初始化该引用。引用形参完全以相同的方式工作。每次调用函数，引用形参被创建并与相应实参关联。</p><p>利用 const 引用避免复制。在向函数传递大型对象时，需要使用引用形参，这是引用形参适用的另一种情况。虽然复制实参对于内置数据类型的对象或者规模较小的类类型对象来说没有什么问题，但是对于大部分的类类型或者大型数组，它的效率（通常）太低了。</p><h3 id="传递指向指针的引用"><a href="#传递指向指针的引用" class="headerlink" title="传递指向指针的引用"></a>传递指向指针的引用</h3><p>假设我们想编写一个与前面交换两个整数的 swap 类似的函数，实现两个指针的交换。已知需用 * 定义指针，用 &amp; 定义引用。现在，问题在于如何将这两个操作符结合起来以获得指向指针的引用。这里给出一个例子：</p><pre><code>// swap values of two pointers to intvoid ptrswap(int *&amp;v1, int *&amp;v2){    int *tmp = v2;    v2 = v1;    v1 = tmp;}</code></pre><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>形参</p><pre><code>int *&amp;v1</code></pre><p>的定义应从右至左理解：v1 是一个引用，与指向 int 型对象的指针相关联。也就是说，v1 只是传递进 ptrswap 函数的任意指针的别名。</p><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>如果要编写一个函数，输出 int 型数组的内容，可用下面三种方式指定数组形参：</p><pre><code>// three equivalent definitions of printValuesvoid printValues(int*) { /* ... */ }void printValues(int[]) { /* ... */ }void printValues(int[10]) { /* ... */ }</code></pre><p>虽然不能直接传递数组，但是函数的形参可以写成数组的形式。虽然形参表示方式不同，但可将使用数组语法定义的形参看作指向数组元素类型的指针。上面的三种定义是等价的，形参类型都是 <code>int*</code>。</p><p><code>编译器忽略为任何数组形参指定的长度。当编译器检查数组形参关联的实参时，它只会检查实参是不是指针、指针的类型和数组元素的类型时是否匹配，而不会检查数组的长度。</code></p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span><code>通过引用传递数组</code>    和其他类型一样，数组形参可声明为数组的引用。如果形参是数组的引用，编译器不会将数组实参转化为指针，而是传递数组的引用本身。在这种情况下，数组大小成为形参和实参类型的一部分。编译器检查数组的实参的大小与形参的大小是否匹配。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>和其他类型一样，数组形参可声明为数组的引用。如果形参是数组的引用，编译器不会将数组实参转化为指针，而是传递数组的引用本身。在这种情况下，<code>数组大小成为形参和实参类型的一部分。</code>编译器检查数组的实参的大小与形参的大小是否匹配：</p><pre><code>// ok: parameter is a reference to an array; size of array is fixedvoid printValues(int (&amp;arr)[10]) { /* ... */ }int main(){    int i = 0, j[2] = {0, 1};    int k[10] = {0,1,2,3,4,5,6,7,8,9};    printValues(&amp;i); // error: argument is not an array of 10 ints    printValues(j);  // error: argument is not an array of 10 ints    printValues(k);  // ok: argument is an array of 10 ints    return 0;}</code></pre><p>这个版本的 printValues 函数只严格地接受含有 10 个 int 型数值的数组，这限制了哪些数组可以传递。然而，由于形参是引用，在函数体中依赖数组的大小是安全的：</p><h2 id="7-3return语句"><a href="#7-3return语句" class="headerlink" title="7.3return语句"></a>7.3return语句</h2><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>返回类型不是 void 的函数必须返回一个值，但此规则有一个例外情况：允许主函数 main 没有返回值就可结束。如果程序控制执行到主函数 main 的最后一个语句都还没有返回，那么编译器会隐式地插入返回 0 的语句。</p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>当函数返回引用类型时，没有复制返回值。相反，返回的是对象本身。例如，考虑下面的函数，此函数返回两个 string 类型形参中较短的那个字符串的引用：</p><pre><code>// find longer of two stringsconst string &amp;shorterString(const string &amp;s1, const string &amp;s2){    return s1.size() &lt; s2.size() ? s1 : s2;}</code></pre><p><code>形参和返回类型都是指向 const string 对象的引用，调用函数和返回结果时，都没有复制这些 string 对象。但千万不要返回局部变量的引用</code></p><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>返回引用的函数返回一个左值。因此，这样的函数可用于任何要求使用左值的地方：</p><pre><code>char &amp;get_val(string &amp;str, string::size_type ix){    return str[ix];}int main(){    string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl;   // prints a value    get_val(s, 0) = &apos;A&apos;; // changes s[0] to A    cout &lt;&lt; s &lt;&lt; endl;   // prints A value    return 0;}</code></pre><p>给函数返回值赋值可能让人惊讶，由于函数返回的是一个引用，因此这是正确的，该引用是被返回元素的同义词。</p><p>如果不希望引用返回值被修改，返回值应该声明为 const：</p><h2 id="7-4-函数声明"><a href="#7-4-函数声明" class="headerlink" title="7.4. 函数声明"></a>7.4. 函数声明</h2><p>函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型，但是不必对形参命名。这三个元素被称为函数原型，函数原型描述了函数的接口。</p><h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><p>默认实参是通过给形参表中的形参提供明确的初始值来指定的。程序员可为一个或多个形参定义默认值。但是，如果有一个形参具有默认实参，那么，它后面所有的形参都必须有默认实参。</p><pre><code>string screenInit(string::size_type height = 24,string::size_type width = 80,char background = &apos; &apos; );</code></pre><h2 id="静态局部对象"><a href="#静态局部对象" class="headerlink" title="静态局部对象"></a>静态局部对象</h2><p><span style="color:black"><i class="fa fa-asterisk  fa-spin fa-2x fa-fw"></i></span>一个变量如果位于函数的作用域内，但生命期跨越了这个函数的多次调用，这种变量往往很有用。则应该将这样的对象定义为 static（静态的）。static 局部对象确保不迟于在程序执行流程第一次经过该对象的定义语句时进行初始化。这种对象一旦被创建，在程序结束前都不会撤销。当定义静态局部对象的函数结束时，静态局部对象不会撤销。在该函数被多次调用的过程中，<code>静态局部对象会持续存在并保持它的值</code>。</p><p>size_t count_calls()</p><pre><code>{     static size_t ctr = 0; // value will persist across calls     return ++ctr;}int main(){    for (size_t i = 0; i != 10; ++i)        cout &lt;&lt; count_calls() &lt;&lt; endl;    return 0;}</code></pre><p>This program will print the numbers from 1 through 10 inclusive.</p><p>这个程序会依次输出 1 到 10（包含 10）的整数。</p><h2 id="7-6-内联函数"><a href="#7-6-内联函数" class="headerlink" title="7.6 内联函数"></a>7.6 内联函数</h2><p><code>调用函数比求解等价表达式要慢得多。</code>inline 函数避免函数调用的开销。将函数指定为 inline 函数，（通常）就是将它在程序中每个调用点上“内联地”展开。假设我们将 shorterString 定义为内联函数，则调用：</p><pre><code>cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;</code></pre><p>在编译时将展开为：</p><pre><code>cout &lt;&lt; (s1.size() &lt; s2.size() ? s1 : s2)     &lt;&lt; endl;</code></pre><p><code>内联函数应该在头文件中定义，这一点不同于其他函数。</code></p><h2 id="7-7-类的成员函数"><a href="#7-7-类的成员函数" class="headerlink" title="7.7 类的成员函数"></a>7.7 类的成员函数</h2><p>类的所有成员都必须在类定义的花括号里面声明，此后，就不能再为类增加任何成员。类的成员函数必须如声明的一般定义。类的成员函数既可以在类的定义内也可以在类的定义外定义。在类 Sales_item 中，这两种情况各有一例说明：函数 same_isbn 在类内定义，而函数 avg_price 则在类内声明，在类外定义。</p><p><code>编译器隐式地将在类内定义的成员函数当作内联函数</code></p><h3 id="this-指针的引入"><a href="#this-指针的引入" class="headerlink" title="this 指针的引入"></a>this 指针的引入</h3><p>每个成员函数（除了在第 12.6 节介绍的 static 成员函数外）都有一个额外的、隐含的形参 this。在调用成员函数时，形参 this 初始化为调用函数的对象的地址。</p><h3 id="const-成员函数的引入"><a href="#const-成员函数的引入" class="headerlink" title="const 成员函数的引入"></a>const 成员函数的引入</h3><p>可以理解跟在 Sales_item 成员函数声明的形参表后面的 const 所起的作用了：const 改变了隐含的 this 形参的类型。在调用 total.same_isbn(trans) 时，隐含的 this 形参将是一个指向 total 对象的 const Sales_Item* 类型的指针。就像如下编写 same_isbn 的函数体一样：</p><pre><code>// pseudo-code illustration of how the implicit this pointer is used// This code is illegal: We may not explicitly define the this pointer ourselves// Note that this is a pointer to const because same_isbn is a const memberbool Sales_item::same_isbn(const Sales_item *const this,                          const Sales_item &amp;rhs) const{ return (this-&gt;isbn == rhs.isbn); }</code></pre><p>用这种方式使用 const 的函数称为<code>常量成员函数</code>。由于 this 是指向 const 对象的指针，const 成员函数不能修改调用该函数的对象。因此，函数 avg_price 和函数 same_isbn 只能读取而不能修改调用它们的对象的数据成员。</p><p>在类的定义外面定义成员函数必须指明它们是类的成员：</p><pre><code>double Sales_item::avg_price() const{    if (units_sold)        return revenue/units_sold;    else        return 0;}</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是特殊的成员函数，与其他成员函数不同，<code>构造函数和类同名，而且没有返回类型</code>。而与其他成员函数相同的是，构造函数也有形参表（可能为空）和函数体。一个类可以有多个构造函数，每个构造函数必须有与其他构造函数不同数目或类型的形参。</p><p>和其他成员函数一样，构造函数也必须在类中声明，但是可以在类中或类外定义。由于我们的构造函数很简单，因此在类中定义它：</p><pre><code>class Sales_item {public:    // operations on Sales_item objects    double avg_price() const;    bool same_isbn(const Sales_item &amp;rhs) const        { return isbn == rhs.isbn; }    // default constructor needed to initialize members of built-in type    Sales_item(): units_sold(0), revenue(0.0) { }// private members as beforeprivate:    std::string isbn;    unsigned units_sold;    double revenue;};</code></pre><p>在冒号和花括号之间的代码称为构造函数的初始化列表。构造函数的初始化列表为类的一个或多个数据成员指定初值。它跟在构造函数的形参表之后，以冒号开关。构造函数的初始化式是一系列成员名，每个成员后面是括在圆括号中的初始值。多个成员的初始化用逗号分隔。</p><h2 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h2><p>出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称为重载函数。</p><h2 id="7-9-函数指针"><a href="#7-9-函数指针" class="headerlink" title="7.9 函数指针"></a>7.9 函数指针</h2><p>函数指针是指指向函数而非指向对象的指针。像其他指针一样，函数指针也指向某个特定的类型。函数类型由其返回类型以及形参表确定，而与函数名无关：</p><h1 id="8-标准IO库"><a href="#8-标准IO库" class="headerlink" title="8 标准IO库"></a>8 标准IO库</h1><p>IO 类型在三个独立的头文件中定义：iostream 定义读写控制窗口的类型，fstream 定义读写已命名文件的类型，而 sstream 所定义的类型则用于读写存储在内存中的 string 对象。在 fstream 和 sstream 里定义的每种类型都是从 iostream 头文件中定义的相关类型派生而来。</p><h1 id="9顺序容器"><a href="#9顺序容器" class="headerlink" title="9顺序容器"></a>9顺序容器</h1><h1 id="10关联容器"><a href="#10关联容器" class="headerlink" title="10关联容器"></a>10关联容器</h1><h1 id="11泛型算法"><a href="#11泛型算法" class="headerlink" title="11泛型算法"></a>11泛型算法</h1><h1 id="12-类"><a href="#12-类" class="headerlink" title="12 类"></a>12 类</h1><h2 id="12-1-类的声明和定义"><a href="#12-1-类的声明和定义" class="headerlink" title="12.1 类的声明和定义"></a>12.1 类的声明和定义</h2><pre><code>class Sales_item {public:// operations on Sales_item objectsdouble avg_price() const;bool same_isbn(const Sales_item &amp;rhs) const    { return isbn == rhs.isbn; }// default constructor needed to initialize members of built-in typeSales_item(): units_sold(0), revenue(0.0) { }private:std::string isbn;unsigned units_sold;double revenue;};double Sales_item::avg_price() const{if (units_sold)    return revenue/units_sold;else    return 0;    }</code></pre><p> <code>在 public 部分定义的成员可被使用该类型的所有代码访问；</code></p><p><code>在 private 部分定义的成员可被其他类成员访问。</code></p><p>所有成员<code>必须</code>在类的内部声明。</p><p>构造函数一般就使用一个<code>构造函数初始化列表</code>，来初始化对象的数据成员：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item(): units_sold(0), revenue(0.0) &#123; &#125;</span><br></pre></td></tr></table></figure><hr><p>在类内部，声明成员函数是必需的，而定义成员函数则是可选的。<code>在类内部定义的函数默认为 inline</code>。在类外部定义的成员函数必须指明它们是在类的作用域中。</p><hr><p>const 成员不能改变其所操作的对象的数据成员。const 必须同时出现在声明和定义中，若只出现在其中一处，就会出现一个编译时错误。</p><p><code>在类的左花括号之后、第一个访问标号之前定义成员的访问级别，其值依赖于类是如何定义的</code>。如果类是用 struct 关键字定义的，则在第一个访问标号之前的成员是公有的；如果类是用 class 关键字是定义的，则这些成员是私有的。</p><p>可以声明一个类而不定义它：</p><pre><code>class Screen; // declaration of the Screen class</code></pre><p>这个声明，有时称为<code>前向声明（forward declaraton）</code>，在程序中引入了类类型的 Screen。在声明之后、定义之前，类 Screen 是一个<code>不完全类型（incompete type）</code>，即已知 Screen 是一个类型，但不知道包含哪些成员。</p><p>除了定义数据和函数成员之外，类还可以定义自己的局部类型名字。如果为 std::string::size_type 提供一个<code>类型别名</code>，那么 Screen 类将是一个更好的抽象：</p><pre><code>class Screen {public:    // interface member functions    typedef std::string::size_type index;private:    std::string contents;    index cursor;    index height, width;};</code></pre><p><code>在类内部定义的成员函数，例如不接受实参的 get 成员，将自动作为 inline 处理。也可以显式地将接受实参的成员函数定义为inline</code></p><p>使用头文件保护符（header guard）（第 2.9.2 节），来保证即使头文件在同一文件中被包含多次，类定义也只出现一次。</p><p>可以在类定义体内部指定一个成员为inline，作为其声明的一部分。或者，也可以在类定义外部的函数定义上指定 inline。在声明和定义处指定 inline 都是合法的。在类的外部定义 inline 的一个好处是可以使得类比较容易阅读。</p><h2 id="12-2-隐含的this指针-※"><a href="#12-2-隐含的this指针-※" class="headerlink" title="12.2 隐含的this指针(※)"></a>12.2 隐含的this指针(※)</h2><p><code>成员函数具有一个附加的隐含形参，即指向该类对象的一个指针</code>。这个隐含形参命名为 this，与调用成员函数的对象绑定在一起。<code>成员函数不能定义 this 形参，而是由编译器隐含地定义。</code>成员函数的函数体可以显式使用 this 指针，但不是必须这么做。</p><p>尽管在成员函数内部显式引用 this 通常是不必要的，但有一种情况下必须这样做：当我们需要将一个对象作为整体引用而不是引用对象的一个成员时。最常见的情况是在这样的函数中使用 this：该函数返回对调用该函数的对象的引用。</p><p>在普通的非 const 成员函数中，<code>this 的类型是一个指向类类型的 const 指针</code>。可以改变 this 所指向的值，但不能改变 this 所保存的地址。在 const 成员函数中，this 的类型是一个指向 const 类类型对象的 const 指针。既不能改变 this 所指向的对象，也不能改变 this 所保存的地址。</p><h3 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h3><p>有时（但不是很经常），我们希望类的数据成员可以修改（甚至是在 const 成员函数内）。这可以通过将它们声明为 <code>mutable</code> 来实现。</p><p>可变数据成员（mutable data member）永远都不能为 const，甚至当它是 const 对象的成员时也如此。因此，const 成员函数可以改变 mutable 成员。要将数据成员声明为可变的，必须将关键字 mutable 放在成员声明之前</p><h2 id="12-3-类作用域"><a href="#12-3-类作用域" class="headerlink" title="12.3 类作用域"></a>12.3 类作用域</h2><p>每个类都定义了自己的新作用域和唯一的类型。在类的定义体内声明类成员，将成员名引入类的作用域。</p><h3 id="形参表和函数体处于类作用域中"><a href="#形参表和函数体处于类作用域中" class="headerlink" title="形参表和函数体处于类作用域中"></a>形参表和函数体处于类作用域中</h3><p>在定义于类外部的成员函数中，形参表和成员函数体都出现在成员名之后。这些都是在类作用域中定义，所以可以不用限定而引用其他成员。例如，类 Screen 中 get 的二形参版本的定义：</p><pre><code>char Screen::get(index r, index c) const{    index row = r * width;      // compute the row location    return contents[row + c];   // offset by c to fetch specified character}</code></pre><p>该函数用 Screen 内定义的 index 类型来指定其形参类型。因为形参表是在 Screen 类的作用域内，所以不必指明我们想要的是 Screen::index。我们想要的是定义在当前类作用域中的，这是隐含的。同样，使用 index、width 和 contents 时指的都是 Screen 类中声明的名字。</p><h3 id="函数返回类型不一定在类作用域中"><a href="#函数返回类型不一定在类作用域中" class="headerlink" title="函数返回类型不一定在类作用域中"></a>函数返回类型不一定在类作用域中</h3><p>与形参类型相比，返回类型出现在成员名字前面。如果函数在类定义体之外定义，则用于返回类型的名字在类作用域之外。如果返回类型使用由类定义的类型，则必须使用完全限定名。例如，考虑 get_cursor 函数：</p><pre><code>class Screen {public:    typedef std::string::size_type index;    index get_cursor() const;};inline Screen::index Screen::get_cursor() const{    return cursor;}</code></pre><p>该函数的返回类型是 index，这是在 Screen 类内部定义的一个类型名。如果在类定义体之外定义 get_cursor，则在函数名被处理之前，代码在不在类作用域内。当看到返回类型时，其名字是在类作用域之外使用。必须用完全限定的类型名 Screen::index 来指定所需要的 index 是在类 Screen 中定义的名字。</p><h2 id="12-4-构造函数"><a href="#12-4-构造函数" class="headerlink" title="12.4 构造函数"></a>12.4 构造函数</h2><p>构造函数的名字与类的名字相同，并且不能指定返回类型。像其他任何函数一样，它们可以没有形参，也可以定义多个形参。</p><p>构造函数不能声明为 const 。</p><p>有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须在构造函数初始化列表中进行初始化。</p><p>必须对任何 const 或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。</p><p>构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化执行的次序。<code>成员被初始化的次序就是定义成员的次序</code>。第一个成员首先被初始化，然后是第二个，依次类推。</p><p>初始化的次序常常无关紧要。然而，如果一个成员是根据其他成员而初始化，则成员初始化的次序是至关重要的。</p><p>考虑下面的类：</p><pre><code>class X {    int i;    int j;public:    // run-time error: i is initialized before j    X(int val): j(val), i(j) { }};</code></pre><p>在这种情况下，构造函数初始化列表看起来似乎是用val 初始化 j，然后再用 j 来初始化 i。然而，i 首先被初始化。这个初始化列表的效果是用尚未初始化的 j 值来初始化 i！如果数据成员在构造函数初始化列表中的列出次序与成员被声明的次序不同，那么有的编译器非常友好，会给出一个警告。</p><p>一个类哪怕只定义了一个构造函数，编译器也不会再生成默认构造函数。<code>只有当一个类没有定义构造函数时，编译器才会自动生成一个默认构造函数。</code></p><p>合成的默认构造函数（synthesized default constructor）使用与变量初始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数来进行初始化。<code>内置和复合类型的成员，如指针和数组，只对定义在全局作用域中的对象才初始化。当对象定义在局部作用域中时，内置或复合类型的成员不进行初始化。</code></p><h2 id="12-5友元"><a href="#12-5友元" class="headerlink" title="12.5友元"></a>12.5友元</h2><p>友元机制允许一个类将对其非公有成员的访问权授予指定的函数或类。友元的声明以关键字 friend 开始。它只能出现在类定义的内部。友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受声明出现部分的访问控制影响。</p><p>友元可以是普通的非成员函数，或前面定义的其他类的成员函数，或整个类。将一个类设为友元，友元类的所有成员函数都可以访问授予友元关系的那个类的非公有成员。</p><p>如果不是将整个 Window_Mgr 类设为友元，Screen 就可以指定只允许 relocate 成员访问：</p><pre><code>class Screen {    // Window_Mgrmust be defined before class Screen    friend Window_Mgr&amp;        Window_Mgr::relocate(Window_Mgr::index,                             Window_Mgr::index,                             Screen&amp;);    // ...restofthe Screen class};</code></pre><p>当我们将成员函数声明为友元时，函数名必须用该函数所属的类名字加以限定。</p><h2 id="12-6-static类成员"><a href="#12-6-static类成员" class="headerlink" title="12.6 static类成员"></a>12.6 static类成员</h2><p>通常，非 static 数据成员存在于类类型的每个对象中。不像普通的数据成员，static 数据成员独立于该类的任意对象而存在；每个 static 数据成员是与类关联的对象，并不与该类的对象相关联。</p><p>类也可以定义 static 成员函数。<code>static 成员函数没有 this 形参，它可以直接访问所属类的 static 成员，但不能直接使用非 static 成员。</code></p><p>因为 static 成员不是任何对象的组成部分，所以 static 成员函数不能被声明为 const。毕竟，将成员函数声明为 const 就是承诺不会修改该函数所属的对象。最后，static 成员函数也不能被声明为虚函数。</p><p>static 数据成员必须在类定义体的外部定义（正好一次）。不像普通数据成员，static 成员不是通过类构造函数进行初始化，而是应该在定义时进行初始化。</p><p>static 关键字只能用于类定义体内部的声明中，定义不能标示为 static。</p><p>static 数据成员的类型可以是该成员所属的类类型。<code>非 static 成员被限定声明为其自身类对象的指针或引用</code>：</p><pre><code>class Bar {public:    // ...private:    static Bar mem1; // ok    Bar *mem2;       // ok    Bar mem3;        // error};</code></pre><p>类似地，static 数据成员可用作默认实参：</p><pre><code>class Screen {public:    // bkground refers to the static member    // declared later in the class definition    Screen&amp; clear(char = bkground);private:    static const char bkground = &apos;#&apos;;};</code></pre><p>非 static 数据成员不能用作默认实参，因为它的值不能独立于所属的对象而使用。使用非 static 数据成员作默认实参，将无法提供对象以获取该成员的值，因而是错误的。</p><p><span style="color:red">xx</span></p>]]></content>
      
      
      <categories>
          
          <category> 码匠 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不懂我,我不怪你</title>
      <link href="/2016/07/31/%E4%BD%A0%E4%B8%8D%E6%87%82%E6%88%91%E6%88%91%E4%B8%8D%E6%80%AA%E4%BD%A0/"/>
      <url>/2016/07/31/%E4%BD%A0%E4%B8%8D%E6%87%82%E6%88%91%E6%88%91%E4%B8%8D%E6%80%AA%E4%BD%A0/</url>
      
        <content type="html"><![CDATA[<center>每个人都有一个死角<br><br>自己走不出来，别人也闯不进去。<br><br>我把最深沉的秘密放在那里。<br><br>你不懂我，我不怪你。<br><br><br><br>每个人都有一道伤口，<br><br>或深或浅，盖上布，以为不存在。<br><br>我把最殷红的鲜血涂在那里。<br><br>你不懂我，我不怪你。<br><br><br><br>每个人都有一场爱恋，<br><br>用心、用情、用力，感动也感伤。<br><br>我把最炙热的心情藏在那里。<br><br>你不懂我，我不怪你。<br><br><br><br>每个人都有一行眼泪，<br><br>喝下的冰冷的水，酝酿成的热泪。<br><br>我把最心酸的委屈汇在那里。<br><br>你不懂我，我不怪你。<br><br><br><br>每个人都有一段告白，<br><br>忐忑、不安，却饱含真心和勇气。<br><br>我把最抒情的语言用在那里。<br><br>你不懂我，我不怪你。<br><br><br><br><br><br>你永远也看不见我最爱你的时候，<br><br>因为我只有在看不见你的时候，才最爱你。<br><br>同样，<br><br>你永远也看不见我最寂寞的时候，<br><br>因为我只有在你看不见我的时候，我才最寂寞。<br><br>也许，我太会隐藏自己的悲伤。<br><br>也许，我太会安慰自己的伤痕。<br><br>也许，你眼中的我，太会照顾自己，<br><br>所以，你从不考虑我的感受。<br><br><br><br>你以为，我可以很迅速的恢复过来，有些自私的以为。<br><br>从阴雨走到艳阳，我路过泥泞、路过风。<br><br>一路走来，你不曾懂我，我亦不曾怪你。<br><br>我不是为了显示自己的大度，<br><br>也不是为了体现自己的大方。<br><br>只想让你知道，感情不在，责备也不存在。<br><br><br><br>我说，每个人都有一段暗恋<br><br>欣喜，雀跃，恐慌，失望<br><br>我把最真挚的感情埋藏在那里<br><br>所以<br><br>你不懂我<br><br>我不怪你。<br><br></center>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重要图片</title>
      <link href="/2016/07/31/%E9%87%8D%E8%A6%81%E5%9B%BE%E7%89%87/"/>
      <url>/2016/07/31/%E9%87%8D%E8%A6%81%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Gnuplot测试图"><a href="#Gnuplot测试图" class="headerlink" title="Gnuplot测试图"></a>Gnuplot测试图</h1><p><img src="/images/test.png" alt="Gnuplot测试图"></p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gnuplot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Ubuntu15后要做的事儿</title>
      <link href="/2016/07/31/%E5%AE%89%E8%A3%85Ubuntu15%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E5%84%BF/"/>
      <url>/2016/07/31/%E5%AE%89%E8%A3%85Ubuntu15%E5%90%8E%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E5%84%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="Latex"><a href="#Latex" class="headerlink" title="Latex"></a>Latex</h1><blockquote><p>sudo apt-get install texlive-full</p></blockquote><blockquote><p>sudo apt-get install texmaker</p></blockquote><h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><p>下载Linux下的JDK压缩包，例如jdk-7u4-linux-i586.tar.gz，（最好放在downloads 目录下，否则易出错）然后直接解压<br>Step1:</p><p>将解压好的jdk1.7.0_04文件夹用最高权限复制到/usr/lib/jvm目录里</p><blockquote><p>sudo cp -r ~/jdk1.7.0_04/ /usr/lib/jvm/</p></blockquote><p>Step2:</p><p>配置环境变量</p><pre><code>sudo gedit ~/.profile在末尾加上：export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_04</code></pre><p>使用source更新一下</p><blockquote><p>$ source ~/.profile</p></blockquote><p>使用env命令察看JAVA_HOME的值</p><blockquote><p>$ env</p></blockquote><p>如果JAVA_HOME=/usr/lib/jvm/jdk1.7.0_04，说明配置成功。<br>Step3:</p><p>将系统默认的jdk修改过来</p><p>$ sudo update-alternatives –install /usr/bin/java java /usr/lib/jvm/jdk1.7.0_04/bin/java 300<br>输入sun jdk前的数字就好了<br>$ sudo update-alternatives –install /usr/bin/javac javac /usr/lib/jvm/jdk1.7.0_04/bin/javac 300<br>$ sudo update-alternatives –config java<br>$ sudo update-alternatives –config javac<br>Step4:<br>然后再输入java -version,看到如下信息，就说明改成sun的jdk了:<br>java version “1.7.0_04”<br>Java(TM) SE Runtime Environment (build 1.7.0_04-b20)<br>Java HotSpot(TM) Server VM (build 23.0-b21, mixed mode)<br>Eclipse<br>    1.安装OpenJDK Java 7<br>    如果你的系统中没有安装 Java，我们需要按如下步骤事先安装好 OpenJDK Java 7。使用 Ctrl+Alt+T 打开终端，并按如下步骤执行安装所需的 Java 版本安装命令：<br>    1）、如果你在 Ubuntu 软件中心安装过 OpenJDK，请先使用如下命令将其删除：<br>    sudo apt-get purge openjdk*<br>    2）、添加 PPA 源<br>    sudo add-apt-repository ppa:webupd8team/java<br>    3）、更新下源数据库<br>    sudo apt-get update<br>    4）、安装 Oracle Java 7<br>    sudo apt-get install oracle-java7-installer</p><pre><code>2.下载 Eclipse 最新版</code></pre><p>3.解压 Eclipse<br>    使用 Ctrl+Alt+T 打开终端并使用如下命令将 Eclipse 解压到 /opt/ 目录以供全局使用：<br>    cd /opt/ &amp;&amp; sudo tar -zxvf ~/下载/eclipse-*.tar.gz<br>    解压完成后，就可以在 /opt/ 目录中看到 Eclipse 了<br>    4.创建 Eclipse 快捷方式<br>    1、在终端中执行如下命令<br>    gksudo gedit /usr/share/applications/eclipse.desktop<br>    2、粘贴并保存如下内容<br>[Desktop Entry]<br>Name=Eclipse 4<br>Type=Application<br>Exec=/opt/eclipse/eclipse<br>Terminal=false<br>Icon=/opt/eclipse/icon.xpm<br>Comment=Integrated Development Environment<br>NoDisplay=false<br>Categories=Development;IDE;<br>Name[en]=Eclipse<br>    至此，我们就将最新版本的 Eclipse Kepler (4.3.2) 安装到 Ubuntu 14.04 中并可以使用了。</p><p>相关设置<br>编辑器字体调整    colors and fonts<br>编辑器颜色调整    syntax coloring<br>                    关键字颜色    keywork<br>                    类颜色        class</p><h1 id="Gnuplot"><a href="#Gnuplot" class="headerlink" title="Gnuplot"></a>Gnuplot</h1><p>Gnuplot是一个命令行的交互式绘图工具（command-driven interactive function plotting program）。用户通过输入命令，可以逐步设置或修改绘图环境，并以图形描述数据或函数，使我们可以借由图形做更进一步的分析。<br>Gnuplot是由Colin Kelly和Thomas Williams于1986年开始开发的科学绘图工具，支持二维和三维图形。它的功能是把数据资料和数学函数转换为容易观察的平面或立体的图形，它有两种工作方式，交互式方式和批处理方式，它可以让使用者很容易地读入外部的数据结果，在屏幕上显示图形，并且可以选择和修改图形的画法，明显地表现出数据的特性。<br>时序图的绘制—使用Gnuplot    <a href="http://www.linuxidc.com/Linux/2014-08/104930.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-08/104930.htm</a><br>Tpcc-MySQL测试并使用Gnuplot生成图表    <a href="http://www.linuxidc.com/Linux/2014-03/98566.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-03/98566.htm</a><br>RH442攻略之Gnuplot        <a href="http://www.linuxidc.com/Linux/2014-03/98405.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2014-03/98405.htm</a><br>Ubuntu下应用Gnuplot进行数据的可视化    <a href="http://www.linuxidc.com/Linux/2011-12/50358.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-12/50358.htm</a><br>利用oprofile分析fortran并用Gnuplot画图的shell脚本    <a href="http://www.linuxidc.com/Linux/2011-04/34497.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2011-04/34497.htm</a><br>一、下载gnuplot4.6.0<br>官网：<a href="http://www.gnuplot.info/" target="_blank" rel="noopener">http://www.gnuplot.info/</a><br>二、解压文件<br>将文件解压到/home/song/下<br>三、配置安装路径<br>cd gnuplot-4.6.0<br>./configure –prefix=/home/song/gnuplot<br>四、编译安装<br>make<br>make install<br>五、配置环境变量<br>sudo gedit /etc/profile<br>将如下环境变量加入：<br>export GNUPLOT=/home/song/gnuplot<br>export PATH=/home/song/gnuplot/bin:$PATH<br>export MANPATH=/home/song/gnuplot/share/man/man1:$MANPATH<br>启用环境变量：<br>source /etc/profile<br>六、运行<br>gnuplot</p><h1 id="MatlabR2015b"><a href="#MatlabR2015b" class="headerlink" title="MatlabR2015b"></a>MatlabR2015b</h1><p>1 下载完成后将iso文件挂载到Linux<br>sudo mkdir /media/matlab<br>mount -o loop [path][filename].iso /media/matlab<br>cd /media/matlab<br>sudo ./install<br>进行安装</p><p>2 安装过程中使用readme.txt中的序列号:54422-40402-23817-20808-30933</p><p>3 破解<br>安装完成后使用crack下的 license进行激活<br>将crack文件夹下的libmwservices.so和libcufft.so.7.0.28 复制到  /opt/MATLAB/R2014A/bin/glnxa64</p><p>4 完成安装，命令行下使用sudo matlab即可启动使用，使用Matlab_R2015b_glnxa64.lic文件来激活matlab。<br>5 添加桌面快捷方式。</p><p>新建一个桌面配置文件，文件名为Ｍatab_2015b.desktop： $ gedit Matlab_2015b.desktop ，其内容如下：</p><p>[Desktop Entry]<br>Name=Matlab 2015b<br>Exec=/usr/local/MATLAB/R2015b/bin/matlab -desktop<br>Icon=/home/She/Documents/MATLAB/matlab.png<br>Type=Application<br>Name[zh_CN]=Matlab_2015b<br>把这个桌面配置文件复制到桌面，即可在桌面得到一个Ｍatlab启动的快捷方式；如果将它复制到/usr/share/applications，则得到主面板菜单栏的快捷方式。</p><p>$ cp Matlab_2015b.desktop /home/She/桌面<br>$ sudo cp Matlab_2015b.desktop /usr/share/applications</p><p>卸载MATLAB<br>$ sudo rm -rf /usr/local/MATLAB/R2014b<br>$ sudo rm /usr/local/bin/matlab /usr/local/bin/mcc /usr/local/bin/mex /usr/local/bin/mbuild #　仅供参考，这些文件可能不存在</p><h1 id="libreoffice汉化"><a href="#libreoffice汉化" class="headerlink" title="libreoffice汉化"></a>libreoffice汉化</h1><p>下载语言包之后执行<br>alvin@BJYB:~/下载/LibreOffice_5.0.4.2_Linux_x86-64_deb_langpack_zh-CN/DEBS$ sudo dpkg -i *.deb<br>Xournal<br>选中笔，尺子，中等线粗，红色后，选择工具→默认设置（最下边的选项）；<br>选中高亮，尺子，粗线，黄色后，选择工具→默认设置（最下边的选项）；<br>最后选择选项→保存首选项即可。</p><h1 id="Inkspace"><a href="#Inkspace" class="headerlink" title="Inkspace"></a>Inkspace</h1><p>软件中心里可以安装</p><h1 id="Audacious"><a href="#Audacious" class="headerlink" title="Audacious"></a>Audacious</h1><p>软件中心里可以安装</p><h1 id="Sougouinput"><a href="#Sougouinput" class="headerlink" title="Sougouinput"></a>Sougouinput</h1><h1 id="Compiz"><a href="#Compiz" class="headerlink" title="Compiz"></a>Compiz</h1><p>快捷键编辑以及系统特效编辑</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse快捷键</title>
      <link href="/2016/07/27/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2016/07/27/Eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<p>注释掉多行：ctrl + /或ctrl + shift + c</p><p>以下是myeclipse中的所有快捷键列表：</p><p>Ctrl+1 快速修复(最经典的快捷键,就不用多说了) </p><p>Ctrl+D: 删除当前行</p><p>Ctrl+Alt+↓ 复制当前行到下一行(复制增加) </p><p>Ctrl+Alt+↑ 复制当前行到上一行(复制增加) </p><p>Alt+↓ 当前行和下面一行交互位置(特别实用,可以省去先剪切,再粘贴了) </p><p>Alt+↑ 当前行和上面一行交互位置(同上) </p><p>Alt+← 前一个编辑的页面</p><p>Alt+→ 下一个编辑的页面(当然是针对上面那条来说了) </p><p>Alt+Enter 显示当前选择资源(工程,or 文件 or文件)的属性</p><p>Shift+Enter 在当前行的下一行插入空行(这时鼠标可以在当前行的任一位置,不一定是最后) </p><p>Shift+Ctrl+Enter 在当前行插入空行(原理同上条) </p><p>Ctrl+Q 定位到最后编辑的地方</p><p>Ctrl+L 定位在某行 (对于程序超过100的人就有福音了) </p><p>Ctrl+M 最大化当前的Edit或View (再按则反之) </p><p>Ctrl+/ 注释当前行,再按则取消注释 </p><p>Ctrl+O 快速显示 OutLine </p><p>Ctrl+T 快速显示当前类的继承结构</p><p>Ctrl+W 关闭当前Editer </p><p>Ctrl+K 参照选中的Word快速定位到下一个 </p><p>Ctrl+E 快速显示当前Editer的下拉列表(如果当前页面没有显示的用黑体表示) </p><p>Ctrl+/(小键盘) 折叠当前类中的所有代码 </p><p>Ctrl+×(小键盘) 展开当前类中的所有代码</p><p>Ctrl+Space 代码助手完成一些代码的插入(但一般和输入法有冲突,可以修改输入法的热键,也可以暂用Alt+/来代替) </p><p>Ctrl+Shift+E 显示管理当前打开的所有的View的管理器(可以选择关闭,激活等操作) </p><p>Ctrl+J 正向增量查找(按下Ctrl+J后,你所输入的每个字母编辑器都提供快速匹配定位到某个单词,如果没有,则在stutes line中显示没有找到了,查一个单词时,特别实用,这个功能Idea两年前就有了) </p><p>Ctrl+Shift+J 反向增量查找(和上条相同,只不过是从后往前查) </p><p>Ctrl+Shift+F4 关闭所有打开的Editer </p><p>Ctrl+Shift+X 把当前选中的文本全部变味小写</p><p>Ctrl+Shift+Y 把当前选中的文本全部变为小写</p><p>Ctrl+Shift+F 格式化当前代码</p><p>Ctrl+Shift+P 定位到对于的匹配符(譬如{}) (从前面定位后面时,光标要在匹配符里面,后面到前面,则反之) </p><p>下面的快捷键是重构里面常用的,本人就自己喜欢且常用的整理一下(注:一般重构的快捷键都是Alt+Shift开头的了) </p><p>Alt+Shift+R 重命名 (是我自己最爱用的一个了,尤其是变量和类的Rename,比手工方法能节省很多劳动力)</p><p>Alt+Shift+M 抽取方法 (这是重构里面最常用的方法之一了,尤其是对一大堆泥团代码有用) </p><p>Alt+Shift+C 修改函数结构(比较实用,有N个函数调用了这个方法,修改一次搞定) </p><p>Alt+Shift+L 抽取本地变量( 可以直接把一些魔法数字和字符串抽取成一个变量,尤其是多处调用的时候) </p><p>Alt+Shift+F 把Class中的local变量变为field变量 (比较实用的功能) </p><p>Alt+Shift+I 合并变量(可能这样说有点不妥Inline) </p><p>Alt+Shift+V 移动函数和变量(不怎么常用) </p><p>Alt+Shift+Z 重构的后悔药(Undo) </p><p>编辑 </p><p>作用域 功能 快捷键</p><p>全局 查找并替换 Ctrl+F </p><p>文本编辑器 查找上一个 Ctrl+Shift+K </p><p>文本编辑器 查找下一个 Ctrl+K </p><p>全局 撤销 Ctrl+Z </p><p>全局 复制 Ctrl+C </p><p>全局 恢复上一个选择 Alt+Shift+↓ </p><p>全局 剪切 Ctrl+X </p><p>全局 快速修正 Ctrl1+1 </p><p>全局 内容辅助 Alt+/ </p><p>全局 全部选中 Ctrl+A </p><p>全局 删除 Delete </p><p>全局 上下文信息 Alt+？ </p><p>Alt+Shift+? </p><p>Ctrl+Shift+Space </p><p>Java编辑器 显示工具提示描述 F2 </p><p>Java编辑器 选择封装元素 Alt+Shift+↑ </p><p>Java编辑器 选择上一个元素 Alt+Shift+← </p><p>Java编辑器 选择下一个元素 Alt+Shift+→ </p><p>文本编辑器 增量查找 Ctrl+J </p><p>文本编辑器 增量逆向查找 Ctrl+Shift+J </p><p>全局 粘贴 Ctrl+V </p><p>全局 重做 Ctrl+Y </p><p>查看 </p><p>作用域 功能 快捷键</p><p>全局 放大 Ctrl+= </p><p>全局 缩小 Ctrl+- </p><p>窗口 </p><p>作用域 功能 快捷键</p><p>全局 激活编辑器 F12 </p><p>全局 切换编辑器 Ctrl+Shift+W </p><p>全局 上一个编辑器 Ctrl+Shift+F6 </p><p>全局 上一个视图 Ctrl+Shift+F7 </p><p>全局 上一个透视图 Ctrl+Shift+F8 </p><p>全局 下一个编辑器 Ctrl+F6 </p><p>全局 下一个视图 Ctrl+F7 </p><p>全局 下一个透视图 Ctrl+F8 </p><p>文本编辑器 显示标尺上下文菜单 Ctrl+W </p><p>全局 显示视图菜单 Ctrl+F10 </p><p>全局 显示系统菜单 Alt+- </p><p>导航 </p><p>作用域 功能 快捷键</p><p>Java编辑器 打开结构 Ctrl+F3 </p><p>全局 打开类型 Ctrl+Shift+T </p><p>全局 打开类型层次结构 F4 </p><p>全局 打开声明 F3 </p><p>全局 打开外部javadoc Shift+F2 </p><p>全局 打开资源 Ctrl+Shift+R </p><p>全局 后退历史记录 Alt+← </p><p>全局 前进历史记录 Alt+→ </p><p>全局 上一个 Ctrl+, </p><p>全局 下一个 Ctrl+. </p><p>Java编辑器 显示大纲 Ctrl+O </p><p>全局 在层次结构中打开类型 Ctrl+Shift+H </p><p>全局 转至匹配的括号 Ctrl+Shift+P </p><p>全局 转至上一个编辑位置 Ctrl+Q </p><p>Java编辑器 转至上一个成员 Ctrl+Shift+↑ </p><p>Java编辑器 转至下一个成员 Ctrl+Shift+↓ </p><p>文本编辑器 转至行 Ctrl+L </p><p>搜索 </p><p>作用域 功能 快捷键</p><p>全局 出现在文件中 Ctrl+Shift+U </p><p>全局 打开搜索对话框 Ctrl+H </p><p>全局 工作区中的声明 Ctrl+G </p><p>全局 工作区中的引用 Ctrl+Shift+G </p><p>文本编辑 </p><p>作用域 功能 快捷键</p><p>文本编辑器 改写切换 Insert </p><p>文本编辑器 上滚行 Ctrl+↑ </p><p>文本编辑器 下滚行 Ctrl+↓ </p><p>文件 </p><p>作用域 功能 快捷键</p><p>全局 保存 Ctrl+X </p><p>Ctrl+S </p><p>全局 打印 Ctrl+P </p><p>全局 关闭 Ctrl+F4 </p><p>全局 全部保存 Ctrl+Shift+S </p><p>全局 全部关闭 Ctrl+Shift+F4 </p><p>全局 属性 Alt+Enter </p><p>全局 新建 Ctrl+N </p><p>项目 </p><p>作用域 功能 快捷键</p><p>全局 全部构建 Ctrl+B </p><p>源代码 </p><p>作用域 功能 快捷键</p><p>Java编辑器 格式化Ctrl+Shift+F </p><p>Java编辑器 取消注释 Ctrl+\ </p><p>Java编辑器 注释 Ctrl+/ </p><p>Java编辑器 添加导入 Ctrl+Shift+M </p><p>Java编辑器 组织导入 Ctrl+Shift+O </p><p>Java编辑器 使用try/catch块来包围 未设置，太常用了，所以在这里列出,建议自己设置。 </p><p>也可以使用Ctrl+1自动修正。</p><p>运行 </p><p>作用域 功能 快捷键</p><p>全局 单步返回 F7 </p><p>全局 单步跳过 F6 </p><p>全局 单步跳入 F5 </p><p>全局 单步跳入选择 Ctrl+F5 </p><p>全局 调试上次启动 F11 </p><p>全局 继续 F8 </p><p>全局 使用过滤器单步执行 Shift+F5 </p><p>全局 添加/去除断点 Ctrl+Shift+B </p><p>全局 显示 Ctrl+D </p><p>全局 运行上次启动 Ctrl+F11 </p><p>全局 运行至行 Ctrl+R </p><p>全局 执行 Ctrl+U </p><p>重构 </p><p>作用域 功能 快捷键</p><p>全局 撤销重构 Alt+Shift+Z </p><p>全局 抽取方法 Alt+Shift+M </p><p>全局 抽取局部变量 Alt+Shift+L </p><p>全局 内联 Alt+Shift+I </p><p>全局 移动 Alt+Shift+V </p><p>全局 重命名 Alt+Shift+R </p><p>全局 重做 Alt+Shift+Y </p><p>选中后，ctrl+shift+/，将代码注释掉</p><p>选中后，ctrl+shift+\,去掉选中部分的注释</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寻</title>
      <link href="/2016/07/27/%E5%AF%BB/"/>
      <url>/2016/07/27/%E5%AF%BB/</url>
      
        <content type="html"><![CDATA[<center>我 们 承 神 之 佑 得 以 在 世 间 浮 生 ， 永 无 休 止 的<br><br>思 考 使 我 们 看 得 清 来 路 ， 却 看 不 到 去 处 。 沉<br><br>恋 于 繁 华 的 浮 光 掠 影 之 间 ， 我 们 在 寻 找 自 己<br><br>的 旅 途 中 迷 失 了 自 己 ， 直 至 那 尽 头 。 相 似 的<br><br>人 生 重 复 千 年 ， 渴 求 让 灵 魂 安 息 的 答 案 。 若<br><br>你 不 曾 试 着 参 破 这 迷 题 ， 那 么 你 的 眼 睛 里 为<br><br>何 游 离 淡 淡 的 哀 伤 。 什 么 是 真 ， 什 么 是 假 ，<br><br>时 间 冲 刷 着 残 影 浮 华 ， 也 许 火 烛 殆 尽 之 时 你<br><br>才 能 看 得 清 掩 藏 在 繁 世 尘 埃 之 下 的 谜 底 ， 不<br><br>会 再 为 追 寻 而 感 到 疲 惫 。 平 凡 的 生 命 都 想 绽<br><br>出 瑰 丽 花 朵 ， 但 不 是 每 人 都 有 幸 福 的 权 利 。<br><br>现 实 的 疼 痛 使 我 看 得 清 绝 美 的 梦 境 ， 寂 寞 伏<br><br>在 暗 处 如 影 随 形 。 我 不 知 道 这 旅 行 是 否 只 有<br><br>我 一 个 人 ， 不 再 追 寻 完 美 的 逝 物 是 我 对 自 己<br><br>的 放 逐 ， 迷 离 游 走 其 中 。 此 生 何 时 而 来 ， 此<br><br>世 何 日 而 去 。 是 什 么 横 亘 在 人 们 之 间 ， 如 疆<br><br>界 一 般 阻 隔 着 两 个 世 界 。 幽 谷 中 的 白 花 空 绽<br><br>与 谁 看 ， 一 瓣 ， 又 一 瓣 ， 飘 落 若 丝 缎 ， 也 许<br><br>我 听 的 懂 风 语 ， 不 然 我 不 会 留 于 此 地 ， 许 下<br><br>十 生 的 誓 言 。 猎 猎 长 风 ， 洗 去 不 散 的 迷 雾 ，<br><br>指 引 着 迷 路 的 羔 羊 。 我 们 都 没 有 归 途 ， 只 能<br><br>相 信 那 尽 头 是 在 比 远 更 远 之 处 。 我 想 用 双 手<br><br>扣 住 自 己 的 那 一 份 幸 福 ， 愿 温 暖 的 心 情 与 我<br><br>厮 守 ， 驱 散 我 心 底 的 荒 芜 。 不 想 留 在 记 忆 里<br><br>守 望 一 生 ， 不 愿 看 着 命 运 止 步 。 看 看 远 处 ，<br><br>此 生 还 会 遇 到 风 景 无 数  ，但 愿 ， 我 们 不 再 迷<br><br>生 于 世 ， 在 这 路 途 中 寻 得 属 于 自己 的 归 宿 。</center>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么决定了你的未来</title>
      <link href="/2016/07/27/%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E4%BA%86%E4%BD%A0%E7%9A%84%E6%9C%AA%E6%9D%A5/"/>
      <url>/2016/07/27/%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A%E4%BA%86%E4%BD%A0%E7%9A%84%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="什么决定了你的未来"><a href="#什么决定了你的未来" class="headerlink" title="什么决定了你的未来"></a>什么决定了你的未来</h1><p>我们生活的这个时代充满着前所未有的机会：如果你有雄心，又不乏智慧，那么不管你从何处起步，你都可以沿着自己所选择的道路登上事业的顶峰。</p><p>不过，有了机会，也就有了责任。今天的公司并不怎么管员工的职业发展；实际上，知识工作者必须成为自己的首席执行官。你应该在公司中开辟自己的天地，知道何时改变发展道路，并在可能长达50年的职业生涯中不断努力、干出实绩。要做好这些事情，你首先要对自己有深刻的认识——不仅清楚自己的优点和缺点，也知道自己是怎样学习新知识和与别人共事的，并且还明白自己的价值观是什么、自己又能在哪些方面做出最大贡献。因为只有当所有工作都从自己的长处着眼，你才能真正做到卓尔不群。</p><p>历史上的伟人——拿破仑、达芬奇、莫扎特——都很善于自我管理。这在很大程度上也是他们成为伟人的原因。不过，他们属于不可多得的奇才，不但有着不同于常人的天资，而且天生就会管理自己，因而才取得了不同于常人的成就。而我们当中的大多数人，甚至包括那些还算有点天赋的人，都不得不通过学习来掌握自我管理的技巧。我们必须学会自我发展，必须知道把自己放在什么样的位置上，才能做出最大的贡献，而且还必须在长达50年的职业生涯中保持着高度的警觉和投入——也就是说，我们得知道自己应该何时换工作，以及该怎么换。</p><h3 id="我的长处是什么"><a href="#我的长处是什么" class="headerlink" title="我的长处是什么"></a>我的长处是什么</h3><p> 多数人都以为他们知道自己擅长什么。其实不然，更多的情况是，人们只知道自己不擅长什么——即便是在这一点上，人们也往往认识不清。然而，一个人要有所作为，只能靠发挥自己的长处，而如果从事自己不太擅长的工作是无法取得成就的，更不用说那些自己根本干不了的事情了。</p><p>以前的人没有什么必要去了解自己的长处，因为一个人的出身就决定了他一生的地位和职业：农民的儿子也会当农民，工匠的女儿会嫁给另一个工匠等。但是，现在人们有了选择。我们需要知己所长，才能知己所属。</p><p>要发现自己的长处，唯一途径就是回馈分析法（feedback analysis）。每当做出重要决定或采取重要行动时，你都可以事先记录下自己对结果的预期。9到 12个月后，再将实际结果与自己的预期比较。我本人采用这种方法已有15到20年了，而每次使用都有意外的收获。比如，回馈分析法使我看到，我对专业技术人员，不管是工程师、会计师还是市场研究人员，都容易从直觉上去理解他们。这令我大感意外。它还使我看到，我其实与那些涉猎广泛的通才没有什么共鸣。</p><p>回馈分析法并不是什么新鲜的东西。早在14世纪，这种方法由一个原本会永远默默无闻的德国神学家发明，大约150年后被法国神学家约翰·加尔文和西班牙神学家圣依纳爵分别采用。他们都把这种方法用于其信徒的修行。事实上，回馈分析法使他们的信徒养成了一种始终注重实际表现和结果的习惯，这也是他们创立的教派——加尔文教会和耶稣会——能够主宰欧洲长达30年的原因。</p><p>我们只要持之以恒地运用这个简单的方法，就能在较短的时间内（可能两三年），发现自己的长处——这是你需要知道的最重要的事情。在采用这种方法之后，你就能知道，自己正在做（或没有做）的哪些事情会让你的长处无法发挥出来。同时，你也将看到自己在哪些方面能力不是特别强。最后，你还将了解到自己在哪些方面完全不擅长，做不出成绩来。</p><p>根据回馈分析的启示，你需要在几方面采取行动。首先最重要的是，专注于你的长处，把自己放到那些能发挥长处的地方。</p><p>其次，加强你的长处。回馈分析会迅速地显示，你在哪些方面需要改善自己的技能或学习新技能。它还将显示你在知识上的差距——这些差距通常都可以弥补。数学家是天生的，但是人人都能学习三角学。</p><p>第三，发现任何由于恃才傲物而造成的偏见和无知，并且加以克服。有太多的人，尤其是那些术业有专攻的人，往往对其他领域的知识不屑一顾，或者认为聪明的头脑就可取代知识。比如，很多一流的工程师遇上与人相关的事就束手无策，他们还以此为荣——因为他们觉得，对条理清晰的工程师头脑来说，人太混乱无序了。与此形成鲜明对照的是，人力资源方面的专业人员常常以他们连基本的会计知识或数量分析都一无所知而自傲。不过，人们要是对这样的无知还沾沾自喜的话，那无异于自取灭亡。其实，要让自己的长处得到充分发挥，你就应该努力学习新技能、汲取新知识。</p><p>另外一点也同样重要——纠正你的不良习惯。所谓不良习惯，是指那些会影响你的工作成效和工作表现的事情。这样的习惯能很快地在回馈中反映出来。例如，一位企划人员可能发现自己美妙的计划最终落空，原因是他没有把计划贯彻到底。同那些才华横溢的人一样，他也相信好的创意能够移动大山。但是，真正移山的是推土机，创意只不过是为推土机指引方向，让它知道该到何处掘土。这位企划人员必须意识到不是计划做好就大功告成，接下来还得找人执行计划，并向他们解释计划，在付诸行动前须做出及时的调整和修改，最后要决定何时中止计划。</p><p>与此同时，回馈还会反映出哪些问题是由缺乏礼貌造成的。礼貌是一个组织的润滑剂。两个移动物相互接触时发生摩擦是一个自然规律，不仅无生命的物体是这样，人类也是如此。礼貌，其实也很简单，无非是说声“请”和“谢谢”，记住别人的名字，或问候对方家人这样的小事，但就是这种不起眼的细节，使得两个人能够融洽相处，不管他们彼此之间是否有好感。许多聪明人，尤其是聪明的年轻人，没有意识到这一点。如果回馈分析表明某个人只要一遇到需要别人合作的事就屡屡失败，那么很可能就意味着这个人的举止不大得体——也就是缺乏礼貌。</p><p>把预期和实际结果进行比较，也会发现自己不能做什么。我们每个人都有许多一窍不通、毫无天分的领域，在这些领域我们甚至连平庸的水平都达不到。人们，尤其是知识工作者，就不应该试图去完成这些领域的工作和任务。他们应该尽量少把精力浪费在那些不能胜任的领域上，因为从无能到平庸要比从一流到卓越需要人们付出多得多的努力。然而，大多数人，尤其是教师，还有组织，都一门心思要把能力低下的人变成合格者。其实，他们还不如把精力、资源和时间花在将称职者培养成佼佼者上。</p><h3 id="我的工作方式是怎样的"><a href="#我的工作方式是怎样的" class="headerlink" title="我的工作方式是怎样的"></a>我的工作方式是怎样的</h3><p>令人惊讶的是，很少有人知道自己平时是怎样把事情给做成的。实际上，我们当中的大多数人甚至不知道不同人有着不同的工作方式和表现。许多人不是以他们习惯的方式工作，这当然就容易造成无所作为。对于知识工作者来说，“我的工作方式是怎样的？”可能比“我的长处是什么？”这个问题更加重要。</p><p>同一个人的长处一样，一个人的工作方式也是独一无二的。这由人的个性决定。不管个性是先天决定的，还是后天培养的，它肯定是早在一个人进入职场前就形成了。正如一个人擅长什么、不擅长什么是既定的一样，一个人的工作方式也基本固定，它可以略微有所调整，但是不可能完全改变——当然也不会轻易改变。而且就像人们从事自己最拿手的工作容易做出成绩一样，他们要是采取了自己最擅长的工作方式也容易取得成就。通常，几个常见的个性特征就决定了一个人的工作方式。</p><p>我属于读者型，还是听者型？首先，你要搞清楚的是，你是读者型（习惯阅读信息）还是听者型（习惯听取信息）的人。绝大多数人甚至都不知道还有读者型和听者型之说，而且很少有人既是读者型又是听者型。知道自己属于哪种类型的人更少。但是，有一些例子说明了这样的无知可能造成多大的危害。</p><p>德怀特·艾森豪威尔担任欧洲盟军最高统帅时，一直是新闻媒体的宠儿。他的记者招待会以其独特的风格出名——不管记者提出什么问题，艾森豪威尔将军都从容地对答如流。无论是介绍情况，还是解释政策，他都能够用两三句言简意赅的话就说清楚。十年后，艾森豪威尔当上了总统，当年曾对他十分崇拜的同一批记者，这时却公开瞧不起他。他们抱怨说，他从不正面回答问题，而是喋喋不休地胡侃着其他事情。他们总是嘲笑他回答问题时语无伦次，不合乎语法，糟蹋标准英语。</p><p>艾森豪威尔显然不知道自己属于读者型，而不是听者型。当他担任欧洲盟军最高统帅时，他的助手设法确保媒体提出的每一个问题至少在记者招待会开始前半小时以书面形式提交。这样，艾森豪威尔就完全掌握了记者提出的问题。而当他就任总统时，他的两个前任都是听者型——富兰克林·罗斯福和哈里·杜鲁门。这两位总统知道自己是听者型的，并且都喜欢举行畅所欲言的记者招待会。艾森豪威尔可能认为他必须去做两位前任所做的事。可是，他甚至连记者们在问些什么都从来没听清楚过。而且，艾森豪威尔并不是个极端的例子。</p><p>几年后，林登·约翰逊把自己的总统职位给搞砸了，这在很大程度上是因为他不知道自己是听者型的人。他的前任约翰·肯尼迪是个读者型的人，他搜罗了一些出色的笔杆子当他的助手，要求他们每次进行当面讨论之前务必先给他写通报。约翰逊留下了这些人，他们则继续写通报。可是他显然根本看不懂他们写的东西。不过，约翰逊以前当参议员时曾经表现非凡，因为议员首先必须是听者型。</p><p>没有几个听者型的人可以通过努力变成合格的读者型——不管是主动还是被动的努力，反之亦然。因此，试图从听者型转为读者型的人会遭受林登·约翰逊的命运，而试图从读者型转为听者型的人会遭受德怀特·艾森豪威尔的命运。他们都不可能发挥才干或取得成就。</p><h3 id="我如何学习"><a href="#我如何学习" class="headerlink" title="我如何学习"></a>我如何学习</h3><p>要了解一个人的工作方式，需要弄清的第二点是，他是如何学习的。许多一流的笔杆子都不是好学生——温斯顿·邱吉尔就是一例。在他们的记忆中，上学往往是十足的折磨。然而，他们的同学有这种记忆的却很少。他们可能在学校里得不到什么乐趣，对他们来说上学的最大痛苦是无聊。有关这个问题的解释是，笔头好的人一般不靠听和读来学习，而靠写来学习，这已成了一种规律。学校不让他们以这种方式学习，所以他们的成绩总是很糟糕。</p><p>所有的学校都遵循这样的办学思路：只有一种正确的学习方式，而且人人都得遵从。但是，对学习方式跟别人不大一样的学生来说，被迫按学校教的方式来学习就是地狱。实际上，学习大概有六七种不同的方式。</p><p>像邱吉尔这样的人靠写来学习。还有些人以详尽的笔记来学习。例如，贝多芬留下了许多随笔小抄，然而他说，实际上他作曲时从来不看这些随笔小抄。当被问及他为什么还要用笔记下来时，据说他回答道：“如果我不马上写下来的话，我很快就会忘得一干二净。如果我把它们写到小本子上，我就永远不会忘记了，也用不着再看一眼。”有些人在实干中学习。另一些人通过听自己讲话学习。</p><p>我认识一位公司总经理，他把一个平庸的小家族企业发展成行业领军企业。他是一个通过讲话学习的人。他习惯于每周一次把全体高层管理人员召集到他的办公室，随后对他们讲上两三个小时。他总是提出政策性问题，在每一个问题上提出三种不同观点。但他很少请这帮同事发表意见或提出问题，他只需要听众听他讲话。这就是他的学习方式。虽然他是一个比较极端的例子，但是通过讲话学习绝不是一种少见的方法。成功的出庭律师也以同样的方式学习，许多诊断医师也是如此（我自己也是这样）。</p><p>在所有最重要的自我认识当中，最容易做到的就是知道自己是怎样学习的。当我问人们：“你怎么学习？”大多数人都知道答案。但是，当我问：“你根据这个认识来调整自己的行为吗？”没有几个人回答“是”。然而，知行合一是取得成就的关键；如果知行不合一，人们就会无所作为。</p><p>我属于读者型还是听者型？我如何学习？这是你首先要问自己的问题。但是，光这些问题显然不够。要想做好自我管理，你还需要问这样的问题：我能与别人合作得好吗？还是喜欢单枪匹马？如果你确实有与别人进行合作的能力，你还得问问这个问题：我在怎样的关系下与他人共事？</p><p>有些人最适合当部属。二战时期美国的大英雄乔治·巴顿将军是一个很好的例子。巴顿是美军的一名高级将领。然而，当有人提议他担任独立指挥官时，美国陆军参谋长、可能也是美国历史上最成功的伯乐，乔治·马歇尔将军说：“巴顿是美国陆军造就的最优秀的部下，但是，他会成为最差劲的司令官。”</p><p>一些人作为团队成员工作最出色。另一些人单独工作最出色。一些人当教练和导师特别有天赋，另一些人却没能力做导师。</p><p>另一个关键的问题是，我如何才能取得成果——是作为决策者还是作为顾问？许多人做顾问时的表现会很出色，但是不能够承担决策的负担和压力。与此相反，也有许多人需要顾问来迫使他们思考，随后他们才能做出决定，接着迅速、自信和大胆地执行决定。</p><p>顺便说一下，一个组织的二号人物在提升到一号职位时常常失败，也正是因为这个原因。最高职位需要一个决策者，而一个强势的决策者常常把其信赖的人放在二号位置，当他的顾问。顾问在二号位置上往往是很出色的，但是换到一号位置，他就不行了。他虽然知道应该做出什么样的决定，但是不能接受真正做决定的责任。</p><p>其他有助于认识自我的重要问题包括：我是在压力下表现出色，还是适应一种按部就班、可预测的工作环境？我是在一个大公司还是在一个小公司中工作表现最佳？在各种环境下都工作出色的人寥寥无几。我不止一次地看到有些人在大公司中十分成功，换到小公司中则很不顺利。反过来也是如此。</p><p>下面这个结论值得我们反复强调：不要试图改变自我，因为这样你不大可能成功。但是，你应该努力改进你的工作方式。另外，不要从事你干不了或干不好的工作。</p><h3 id="我的价值观是什么"><a href="#我的价值观是什么" class="headerlink" title="我的价值观是什么"></a>我的价值观是什么</h3><p>要能够自我管理，你最后不得不问的问题是：我的价值观是什么？这不是一个有关伦理道德的问题。道德准则对每一个人都一样。要对一个人的道德进行测试，方法很简单。我把它称为“镜子测试”。</p><p>20世纪初，德国驻英国大使是当时在伦敦所有大国中最受尊重的一位外交官。显然，他命中注定会承担重任，即使不当本国的总理，至少也要当外交部长。然而，在1906年，他突然辞职，不愿主持外交使团为英国国王爱德华七世举行的晚宴。这位国王是一个臭名昭著的色鬼，并且明确表示他想出席什么样的晚宴。据有关报道，这位德国大使曾说：“我不想早晨刮脸时在镜子里看到一个皮条客。”</p><p>这就是镜子测试。我们所尊从的伦理道德要求你问自己：我每天早晨在镜子里想看到一个什么样的人？在一个组织或一种情形下合乎道德的行为，在另一个组织或另一种情形下也是合乎道德的。但是，道德只是价值体系的一部分——尤其对于一个组织的价值体系来说。</p><p>如果一个组织的价值体系不为自己所接受或者与自己的价值观不相容，人们就会备感沮丧，工作效力低下。</p><p>让我们来看看一位十分成功的人力资源主管的经历。这位主管所在的公司被一家大企业收购。收购之后，她得到了提升，从事的是她以前做得最出色的工作，包括为重要职位挑选人才。这位主管深信，在选人时，公司只有在排除内部的所有可能人选后才能从外部招聘人才。但是她的新公司认为应该首先从外部招聘，以吸收新鲜血液。对于这两种方式，需要说明的一点是，根据我的经验，适当的方式是两者兼顾。然而，这两种方式在根本上是互不相容的——表面上是政策不同，实质是价值观的不同。这说明在该公司人们对以下三个问题有着不同看法：组织与员工之间是怎样的关系；组织应该为员工以及员工的发展承担何种责任；一个人对企业最重要的贡献是什么。经过几年挫折，这位主管最终辞职——尽管她的经济损失很大。她的价值观和这个组织的价值观就是无法融合。</p><p>同样，一家制药公司无论是通过不断的小幅改进，还是通过几次费用高昂、风险巨大的“突破”来取得出色业绩，都主要不是一个经济问题。这两种战略的结果可能都差不多。实质上，这是两种价值体系之间的冲突。一种价值体系认为公司的贡献是帮助医生把他们已经在做的工作锦上添花，另一种价值体系的取向是进行更多的科学发现。</p><p>至于一个企业的经营是着眼于短期结果，还是注重长远发展，这同样是价值观问题。财务分析师认为，企业可两者同时兼顾。成功的企业家知道得更清楚。诚然，每一家公司都必须取得短期成果。但是在短期成果与长期增长之间的冲突中，每一家公司都将决定自己所选择的重点。从根本上说，这是一种关于企业职能与管理层责任的价值观冲突。</p><p>价值观冲突并不限于商业组织。美国发展最快的一个牧师教会，衡量工作成败的尺度是新教徒的人数。它的领导层认为，重要的是有多少新教徒入会。随后，上帝将满足他们的精神需求，或者至少会满足足够比例的新教徒的需求。另一个福音派牧师教会认为，重要的是人们的精神成长。这个教会慢慢地让那些形式上入会但精神上并没有融入教会生活的新教徒选择了离开。</p><p>这同样不是一个数量问题。乍一看，第二个教会好像发展较慢。但是，它留住新教徒的比例要远高于第一个。换言之，它的发展比较稳固。这也不是一个神学问题，至少首先并不是神学问题，而是有关价值观的问题。在一次公开辩论中，一位牧师这样说：“除非你先加入教会，否则你永远找不到天国之门。”</p><p>而另一位牧师反驳说：“不，除非你先有心寻找天国之门，否则你就不属于教会。”</p><p>组织和人一样，也有价值观。为了在组织中取得成效，个人的价值观必须与这个组织的价值观相容。两者的价值观不一定要相同，但是必须相近到足以共存。不然，这个人在组织中不仅会感到沮丧，而且做不出成绩。</p><p>一个人的工作方式和他的长处很少发生冲突，相反，两者能产生互补。但是，一个人的价值观有时会与他的长处发生冲突。一个人做得好甚至可以说是相当好、相当成功的事情——可能与其价值体系不吻合。在这种情况下，这个人所做的工作似乎并不值得贡献毕生的精力（甚至没必要贡献太多的精力）。</p><p>如果可以，请允许我插入一段个人的故事。多年前，我也曾不得不在自己的价值观和做得很成功的工作之间做出选择。20世纪30年代中期，我还是一个年轻人，在伦敦做投资银行业务，工作非常出色。这项工作显然能发挥我的长处。然而，我并不认为自己担任资产管理人是在做贡献。我认识到，我所重视的是对人的研究。我认为，一生忙于赚钱、死了成为墓地中的最大富翁没有任何意义。当时我没有钱，也没有任何就业前景。尽管当时大萧条仍在持续，我还是辞去了工作。这是一个正确的选择。换言之，价值观是并且应该是最终的试金石。</p><h3 id="我属于何处"><a href="#我属于何处" class="headerlink" title="我属于何处"></a>我属于何处</h3><p>少数人很早就知道他们属于何处。比如，数学家、音乐家和厨师，通常在四五岁的时候就知道自己会成为数学家、音乐家和厨师了。物理学家通常在十几岁甚至更早的时候就决定了自己的工作生涯。但是，大多数人，尤其是很有天赋的人，至少要过了二十五六岁才知道他们将身属何处。然而，到这个时候，他们应该知道上面所谈的三个问题的答案：我的长处是什么？我的工作方式是怎样的？我的价值观是什么？随后，他们就能够并且应该决定自己该向何处投入精力。</p><p>或者，他们应该能够决定自己不属于何处。已经知道自己在大公司里干不好的人，应该学会拒绝在一个大公司中任职。已经知道自己不适合担任决策者的人，应该学会拒绝做决策工作。巴顿将军（他自己大概永远不知道这一点）本来应该学会拒绝担任独立总指挥的。</p><p>同样重要的是，知道上述三个问题的答案，也使得一个人能够坦然接受一个机会、一个邀请或一项任务。“是的，我将做这件事。但是，我将按照我自己的特点，采取这样的方式来做这件事，进行这样的组织安排，这样来处理当中所牵涉的关系。这是我在这个时间范围内应该会取得的成果，因为这就是我。”</p><p>成功的事业不是预先规划的，而是在人们知道了自己的长处、工作方式和价值观后，准备把握机遇时水到渠成的。知道自己属于何处，可使一个勤奋、有能力但原本表现平平的普通人，变成出类拔萃的工作者。</p><h3 id="我该做出什么贡献"><a href="#我该做出什么贡献" class="headerlink" title="我该做出什么贡献"></a>我该做出什么贡献</h3><p>综观人类的发展史，绝大多数人永远都不需要提出这样一个问题：我该做出什么贡献？因为他们该做出什么贡献是由别人告知的，他们的任务或是由工作本身决定的（例如农民或工匠的任务），或是由主人决定的（例如佣人的任务）。以前的人大多都处于从属地位，别人吩咐他们做什么，就做什么，这被认为是理所当然的。甚至到了20世纪50年代和60年代，那时涌现出的知识工作者（即所谓的“组织人”， organization man）还指望公司的人事部为他们做职业规划。</p><p>随后，到20世纪60年代末，就再没有人想让别人来安排自己的职业生涯了。年轻的男男女女开始提出这个问题：我想做什么？而他们所听到的答案就是“你们自行其是吧”。但是，这种回答同“组织人”听命公司的做法一样错误。那些相信自行其是就能做出贡献、实现抱负、取得成功的人，一般连三点中的任何一点都做不到。</p><p>尽管如此，我们还是不能走回头路，让别人来吩咐、安排自己要干什么。对于知识工作者来说，他们还不得不提出一个以前从来没有提出过的问题：我的贡献应该是什么？要回答这个问题，他们必须考虑三个不同的因素：当前形势的要求是什么？鉴于我的长处、我的工作方式以及我的价值观，我怎样才能对需要完成的任务做出最大贡献？最后，必须取得什么结果才能产生重要影响？</p><p>请看一位新任命的医院院长的经历。这是一所享有盛名的大医院，30年来一直就靠名气顺利经营着。新院长上任后决定了自己应做的贡献：两年内在医院的某个重要领域建立起卓越服务的标准。他决定以急诊室为重点，因为该院的急诊室地方比较大，受人注意，而又秩序混乱。他决定，到急诊室就诊的每一个患者必须在60秒钟之内由一名合格的护士接待。一年之内，该医院的急诊室变成了美国所有医院的样板，又过了两年，整个医院的面貌焕然一新。</p><p>正如这个事例所表明的，把眼光放得太远是不大可能的——甚至不是特别有效。一般来说，一项计划的时间跨度如果超过了 18个月，就很难做到明确和具体。因此，在多数情况下我们应该提出的问题是：我在哪些方面能取得将在今后一年半内见效的结果？如何取得这样的结果？回答这个问题时必须对几个方面进行权衡。首先，这些结果应该是比较难实现的——用当前的一个时髦词说，就是要有“张力”（stretching）。但是，这些结果也应该是能力所及的。设定一个不能实现的目标或者只能在可能性微乎其微的情况下实现的目标，根本不能叫雄心勃勃，简直就是愚蠢。其次，这些结果应该富有意义，要能够产生一定影响。最后，结果应该明显可见，如果可能的话，还应当能够衡量。确定了要实现的结果之后，接着就可以制订行动方针：做什么，从何处着手，如何开始，目标是什么，在多长时间内完成。</p><h3 id="对人际关系负责"><a href="#对人际关系负责" class="headerlink" title="对人际关系负责"></a>对人际关系负责</h3><p>除了少数伟大的艺术家、科学家和运动员，很少有人是靠自己单枪匹马而取得成果的。不管是组织成员还是个体职业者，大多数人都要与别人进行合作，并且是有效的合作。要实现自我管理，你需要对自己的人际关系负起责任。这包括两部分内容。</p><p>首先是要接受别人是和你一样的个体这个事实。他们会执意展现自己作为人的个性。这就是说，他们也有自己的长处，自己的做事方式和自己的价值观。因此，要想卓有成效，你就必须知道共事者的长处、工作方式和价值观。这个道理听起来让人很容易明白，但是没有几个人真正会去注意。一个习惯于写报告的人就是个典型的例子——他在第一份工作时就培养起写报告的习惯，因为他的老板是一个读者型的人，而即使下一个老板是个听者型，此人也会继续写着那肯定没有任何结果的报告。这位老板因此肯定会认为这个员工愚蠢、无能、懒惰，肯定干不好工作。但是，如果这个员工事先研究过新老板的情况，并分析过这位老板的工作方式，这种情况本来可以避免。</p><p>老板既不是组织结构图上的一个头衔，也不是一个“职能”。他们是有个性的人，他们有权以自己最得心应手的方式来工作。与他们共事的人有责任观察他们，了解他们的工作方式，并做出相应的自我调整，去适应老板最有效的工作方式。事实上，这就是“管理”上司的秘诀。</p><p>这种方法适用于所有与你共事的人。每个人都有他自己的做事方法，也有权按照自己的方式来工作，而不是按你的方法来工作。重要的是，他们能否有所作为以及他们持有什么样的价值观。至于工作方式，人各有别。提高效力的第一个秘诀是了解跟你合作和你要依赖的人，以利用他们的长处、工作方式和价值观。工作关系应当既以工作为基础，也以人为基础。</p><p>人际关系责任的第二部分内容是沟通责任。在我或是其他人开始给一个组织做咨询时，我们听到的第一件事都与个性冲突有关。其中大部分冲突都是因为：人们不知道别人在做什么，他们又是采取怎样的工作方式，专注于做出什么样的贡献以及期望得到怎样的结果。而这些人不了解情况的原因是，他们没有去问，结果也就不得而知。</p><p>这种不去问明情况的做法，与其说是反映了人类的愚蠢，倒不如说是历史使然。在以前，人们没必要把这些情况告诉任何人。比如在中世纪的城市，一个区的每一个人从事的行业都一样。在乡村，土地刚一解冻，山谷里的每一个人就开始播种同一种农作物。即使有少数人做的事情和大家不一样，他们也是单独工作，因此不需要告诉任何人他们在做什么。</p><p>而现在，大多数人都与承担着不同任务和责任的人一道工作。市场营销副总裁可能是销售出身，知道有关销售的一切，但是，对于自己从未做过的事情，比如定价、广告、包装等等，就一无所知了。所以，那些正在做这些工作的人必须确保营销副总裁懂得他们设法做的是什么、他们为什么要做这件事、他们将如何去做以及期望取得什么结果。</p><p>如果营销副总裁不懂得这些高层次的、知识型的专业人士在做什么，错主要在后者身上，而不在自己。反过来说，营销副总裁的责任则是确保他的所有同事都知道自己是怎样看待营销这项工作的：他的目标是什么、他如何工作，以及他对他本人和他的每一个同事有什么期望。</p><p>即使一些人懂得负起人际关系责任的重要性，他们和同事的交流也往往不够。他们总是有所顾虑，怕别人把自己看成是一个冒昧、愚蠢、爱打听的人。他们错了。因为我们看到，每当有人找到他的同事说“这是我所擅长的工作。这是我的做事方式。这是我的价值观。这是我计划做出的贡献和应当取得的成果”，这个人总会得到如此回答：“这太有帮助了，可你为什么不早点告诉我？”</p><p>如果一个人继续问道：“那么，关于你的长处、你的工作方式、你的价值观以及你计划做出的贡献，我需要知道什么？”他也会得到类似的答复——据我的经验，无一例外。事实上，知识工作者应该向与他们共事的每一个人，不管是下属、上司、同事还是团队成员，都发出这样的疑问。而且，每次提出此类问题，都会得到这样的回答：“谢谢你来问我。但是，你为什么不早点问我？”</p><p>组织已不再建立在强权的基础上，而是建立在信任的基础上。人与人之间相互信任，不一定意味着他们彼此喜欢对方，而是意味着彼此了解。因此，人们绝对有必要对自己的人际关系负责。这是一种义务。不管一个人是公司的一名成员，还是公司的顾问、供应商或经销商，他都需要对他的所有共事者负起这种责任。所谓共事者，是指在工作上他所依赖的同事以及依赖他的同事。</p><h3 id="管理后半生"><a href="#管理后半生" class="headerlink" title="管理后半生"></a>管理后半生</h3><p>当多数人的工作是体力劳动时，你不必为自己的后半生担心。你只要继续从事你一直在做的工作就行了。如果你够幸运，能在工厂或铁路辛勤工作40年后撑下来，你就可以快乐地度过余生，什么也用不着干。然而，现在的多数工作都是知识工作，而知识工作者在干了40年后，仍能发挥余热，他们只是有些厌倦。</p><p>我们听到了许多有关经理人中年危机的谈论，“厌倦”这个词在其中频频出现。45岁时，多数经理人的职业生涯达到了顶峰，他们也知道这一点。在做了 20年完全相同的工作之后，他们已经得心应手。但是他们学不到新东西，也没有什么新贡献，从工作中得不到挑战，因而也谈不上满足感。然而，在他们面前，还有20到25年的职业道路要走。这就是为什么经理人在进行自我管理后，越来越多地开始发展第二职业的原因。</p><p>发展第二职业有三种方式。第一种是完全投身于新工作。这常常只需要从一种组织转到另一种组织。例如，一家大公司某事业部的会计师成为一家中型医院的财务总监。但是也有越来越多的人转入完全不同的职业。例如，公司经理在45岁时进入政府内阁；或者中层管理人员在公司工作20年后离职，到法学院进修，成为一个小镇的律师。</p><p>还有许多人在第一份职业中取得的成功有限，于是改行从事第二职业。这样的人有很多技能，他们也知道该如何工作。而且，他们需要一个社群——因为孩子已长大单飞，剩下一座空屋。他们也需要收入。但最重要的是，他们需要挑战。</p><p>为后半生做准备的第二种方式是，发展一个平行的职业。许多人的第一职业十分成功，他们还会继续从事原有工作，或全职或兼职，甚至只是当顾问。但是，除此之外，他们会开创一项平行的工作，通常是在非营利机构，每周占用10个小时。例如，他们可能接手教会的管理，或者担任当地女童子军顾问委员会主席。他们也可能管理受虐妇女庇护所，担任当地公共图书馆的儿童图书管理员，或在学校董事会任职等。</p><p>最后一种方法是社会创业。社会创业者通常是在第一职业中非常成功的人士。他们都热爱自己的工作，但是这种工作对他们已经不再有挑战性。在许多情况下，他们虽然继续做着原来的工作，但在这份工作上花的时间越来越少。他们同时开创了另一项事业，通常是非营利性活动。例如，我的朋友鲍勃·布福德创办了一个非常成功的电视公司，现在他仍然经营着。但与此同时，他还创建了一个与新教教会合作的非营利组织，也做得非常成功。现在他又创建了一个组织，专门指导社会创业者在经营原有业务的同时，如何管理自己另外创办的非营利机构。</p><p>管理好自己后半生的人可能总是少数。多数人可能“一干到底”，数着年头一年一年过去，直至退休。但是，正是这些少数人，这些把漫长的工作寿命看做是自己和社会之机会的男男女女，才会成为领袖和模范。</p><p>管理好后半生有一个先决条件：你必须早在你进入后半生之前就开始行动。当30年前人们首次认识到工作寿命正在迅速延长时，许多观察家（包括我自己）认为，退休人员会越来越多地成为非营利机构的志愿者。可是，这种情况并没有发生。一个人如果不在40岁之前就开始做志愿者，那他60岁之后也不会去做志愿者。</p><p>同样，我认识的所有社会创业者，都是早在他们原有的事业达到顶峰之前就开始从事他们的第二事业。请看一名成功律师的例子。这位律师是一家大公司的法律顾问，他同时在自己所在的州开办了模特培训学校。早在他 35岁左右的时候，他就开始志愿为学校提供法律咨询。40岁时被推选为一家学校的董事会成员。50岁时，他积累起了一笔财富，办起了自己的企业——建立并经营模特培训学校。然而此时，他依旧在那家他年轻时参与创建的公司里担任首席法律顾问，而且几乎是全职工作。</p><p>发展第二兴趣（而且是趁早发展）还有一个原因：任何人都不能指望在生活或工作中很长时间都不遭遇严重挫折。有一位很能干的工程师在45岁时错过了晋升的机会。另一位也很能干的普通学院的教授在42岁时认识到，即使她完全具备担任教授的资格，她永远也不会在一所有名的大学里获得教授职位。还有一位则是在家庭生活里出现了悲剧：婚姻破裂或者痛失子女。在这样的时刻，第二兴趣——不仅仅是业余爱好——可能发挥重要作用。例如，这位工程师现在知道他在工作上并不十分成功。但是，在公司以外的活动中，例如负责教会资金的管理，他是成功的。一个人可能家庭破碎，但是他能在第二兴趣的活动中发现还有社区这个大“家庭”。</p><p>在一个崇尚成功的社会里，拥有各种选择变得越来越重要。从历史上来看，却没有“成功”一说。绝大多数人只期望坚守“适当的位置”。唯一的流动性是向下的流动性。然而，在知识社会里，我们期望每一个人都能取得成功。这显然是不可能的。对许多人来说，能避免失败就行。可是有成功的地方，就会有失败。因此，有一个能够让人们做出贡献、发挥影响力或成为“大人物”的领域，这不仅对个人十分重要，对个人的家庭也同样重要。这意味着人们需要找到一个能够有机会成为领袖、受到尊重、取得成功的第二领域——可能是第二份职业，也可能是平行的职业或社会创业。</p><p>自我管理中面临的挑战看上去比较明显，甚至非常基本，其答案可能不言自明，甚至近乎幼稚。但是，自我管理需要个人，尤其是知识工作者，做出以前从未做过的事情。实际上，自我管理需要每一个知识工作者在思想和行动上都要成为自己的首席执行官。更进一步来看，这样的转变——从一切听从别人吩咐的体力劳动者到不得不自我管理的知识工作者——也使得社会结构发生了深刻变化。历史上每一个社会，甚至是个人主义倾向最强的社会，都认为两件事情理所当然（即使只是下意识的）：第一，组织比员工更长寿；第二，大多数人从不挪地方。</p><p>如今，情况恰恰相反。知识工作者的寿命超过了组织寿命，而且他们来去自如。于是，人们对自我管理的需要在人类事务中掀起了一场革命。</p>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深思 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三三两两</title>
      <link href="/2016/07/27/%E4%B8%89%E4%B8%89%E4%B8%A4%E4%B8%A4/"/>
      <url>/2016/07/27/%E4%B8%89%E4%B8%89%E4%B8%A4%E4%B8%A4/</url>
      
        <content type="html"><![CDATA[<center>纷纷扰扰 时间还早 你未注意到<br>眼神一触到她 总会多个几秒<br>我已明了 卑微多高 骄傲多渺小<br>剧情俗套无聊 还没开始就哀悼<br>别再让我帮你挑选 百天礼物纪念<br>这不胜其烦 更会让我难堪 一切与我无关<br>别再让我陪你一同 准备所谓浪漫<br>暗自盘算 掩藏反感 我怕被拆穿<br>三个说笑 两个玩闹 一人受煎熬<br>疼痛蜿蜒缠绕 爬上眼角眉梢<br>装不知道 说得轻巧 谁能做得到<br>心跳有多聒噪 真实就有多可笑<br>别再问我她怎样了 生你的气了没<br>这是错是对 或是给你安慰 自问孰是孰非<br>别再问我她还好么 为何短信不回<br>内心鬼祟 不愿理会 我什么滋味<br>Back to the days only you and me<br>I thought maybe just the right time that I need to leave<br>You say you want my help, so what do you need?<br>That’s all really not I want, and what do you mean?<br>Once or twice, I can try to keep quiet.<br>But if you do it all the time, you might ruin my life.<br>I can’t stand on her left, with your arm around her waist.<br>Leave you might be right, I felt too much pain.<br>别再问我她怎样了 生你的气了没<br>这是错是对 或是给你安慰 自问孰是孰非<br>别再问我她还好么 为何短信不回<br>内心鬼祟 不愿理会 我什么滋味</center>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱很简单-陶喆</title>
      <link href="/2016/07/27/%E7%88%B1%E5%BE%88%E7%AE%80%E5%8D%95/"/>
      <url>/2016/07/27/%E7%88%B1%E5%BE%88%E7%AE%80%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<center>忘了是怎么开始<br><br>也许就是对你<br><br>有一种感觉<br><br>忽然间发现自己<br><br>已深深爱上你<br><br>真的很简单<br><br>爱得地暗天黑都已无所谓<br><br>是是非非无法决择<br><br>没有后悔为爱日夜去跟随<br><br>那个疯狂的人是我<br><br>喔……<br><br>i love you<br><br>无法不爱着你<br><br>说你也爱我<br><br>i love you<br><br>永远不愿意<br><br>baby<br><br>失去你<br><br>不可能更快乐<br><br>只要能在一起<br><br>做什么都可以<br><br>虽然世界变个不停<br><br>用最真诚的心<br><br>让爱变得简单<br><br>爱得地暗天黑都已无所谓<br><br>是是非非无法决择<br><br>没有后悔为爱日夜去跟随<br><br>那个疯狂的人是我<br><br>喔……<br><br>i love you<br><br>我一直在这里<br><br>一直在爱你<br><br>i love you<br><br>永远都不放弃<br><br>这爱你的权利<br><br>如果你还有一些困惑<br><br>请贴着我的心倾听<br><br>听我说着爱你<br><br>yes i do<br><br>i love you<br><br></center>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 歌词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一言一世界</title>
      <link href="/2016/07/27/%E4%B8%80%E8%A8%80%E4%B8%80%E4%B8%96%E7%95%8C/"/>
      <url>/2016/07/27/%E4%B8%80%E8%A8%80%E4%B8%80%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>每一个不曾起舞的日子，都是对生命的辜负。——尼采</p><p>我是你路上最后的一个过客，最后的一个春天，最后的一场雪，最后的一次求生的战争。——保尔·艾吕雅（很纯粹的诗人，这是他写给前妻的诗。）</p><p>凌晨四点钟，看到海棠花未眠。——川端康成（中学时的课文，现在读来依然很美。）</p><p>哪里会有人喜欢孤独，不过是不喜欢失望。——村上春树（这是村上春树的作品里，我第二喜欢的句子，第一嘛，你们懂的。）</p><p>你最可爱，我说时来不及思索，但思索之后，还是这样说。——普希金（非常朴素的情话，细思颇觉有味。）</p><p>为你，千千万万遍。——卡勒德·胡赛尼（很真挚，哈桑确实是这么对待阿米尔的。）</p><p>我只是个戏子，在别人的故事里，流着自己的泪。——席慕蓉（席慕蓉好诗不少，散文也值得一看。）</p><p>不多不多，以后还可以少吃一点。——三毛（缘于三毛和荷西的一次谈话，我认为，这算是三毛说过最动人的话了。）</p><p>你记得也好，最好你忘掉，在这交会时互放的光亮。——徐志摩</p><p>你，一会看我，一会看云；我觉得，你看我时很远，你看云时很近。——顾城（草在结它的种子/风在摇它的叶子 我们站着，不说话 /就十分美好）</p><p>一个人有两个我，一个在黑暗中醒着，一个在光明中睡着。——纪伯伦（纪伯伦很多哲理诗都很有韵味，经得起反复咀嚼。）</p><p>若我会见到你，事隔经年。我如何向你招呼，以眼泪，以沉默。——拜伦（下面知友提到的另一版本：若我遇见你，事隔经年，我将如何致你，以眼泪，以沉默。）</p><p>枕上诗书闲处好，门前风景雨来佳。——李清照（倒是蛮想知道有多少人向往这种生活。）</p><p>纵豆蔻词工，青楼梦好，难赋深情。——姜夔（想起高中时，年过六旬的语文老师苦口婆心叮嘱我们一定要会写“夔”字。）</p><p>野兽需要窝，朝圣人需要路，死人需要灵柩。人人有自己需要的物。女人需要说谎，沙皇需要统治，我需要颂扬——你的名字。——茨维塔耶娃（哼哼，让你们再说名人名言。我知道很多人都喜欢她的《我想和你一起生活》，但是太长了，答案全是手打，所以我就偷个懒，你们不许打我。）作为补偿，再贴一句：三十年在一起，比爱情更清澈。我熟悉你的每一道纹理，你了解我的诗行。</p><p>如果你认识从前的我，那么你就会原谅现在的我。——张爱玲（出自倾城之恋，第一次在图书馆里读到时，感触颇深，是从前的你让你演变成如今的你。）</p><p>令她反感的，远不是世界的丑陋，而是世界所戴的漂亮面具。——米兰·昆德拉</p><p>我遇见你，我记得你，这座城市天生就适合恋爱，你天生就适合我的灵魂——杜拉斯（好傲娇，姑娘们，心动了吗，快去他的城市吧，传销在等你。）</p><p>我回到了我的城市，对它如此熟悉，像眼泪、血脉、儿童肿胀的腺体。——曼德尔施塔姆</p><p>一个人只拥有此生此世是不够的，他还应该拥有诗意的世界。——王小波</p><p>爱自己是终生浪漫的开始。——王尔德</p><p>眼睛为她下着雨，心却为她打着伞，这就是爱情。——泰戈尔</p><p>我去旅行，是因为我决定了要去，并不是因为对风景的兴趣。——加西亚·马尔克斯（霍乱时期的爱情，读过的人应该很多，里面佳句不少。）</p><p>真爱的第一个征兆，在男孩身上是胆怯，在女孩身上是大胆。——雨果</p><p>年轻时，我们彼此相爱却浑然不知。——叶芝（当你老了，就不列了。）</p><p>我是个百依百顺的孩子，至死不变，但只顺从我自己。——萨特</p><p>世界上最大的折磨也莫过于在爱的同时又带着藐视了。——毛姆</p><p>随着时光流逝，我慢慢地明白了，只有存在的东西才会消失，不管是城市，爱情，还是父母。——伊塔洛·卡尔维诺</p><p>我用什么才能留住你？我给你贫穷的街道、绝望的日落、破败郊区的月亮。我给你一个久久地望着孤月的人的悲哀。——博尔赫斯</p><p>此刻有谁在世上某处哭， 无缘无故在世上哭， 在哭我。<br>此刻有谁在夜间某处笑， 无缘无故在夜间笑， 在笑我。<br>此刻有谁在世上某处走， 无缘无故在世上走， 走向我。<br>此刻有谁在世上某处死， 无缘无故在世上死， 望着我。 ——里尔克（秋日，就不列了。）</p><p>当一个人不能拥有的时候，他唯一能做的便是不要忘记。——普鲁斯特（很经典的回忆录，但要是没有足够的耐心，还是不读的好，过于冗长了。）</p><p>这个世界上没有什么东西比得上孩子悄悄所怀的爱情。——斯蒂芬·茨威格</p><p>这世上真话本就不多，一位女子的脸红胜过一大段对白。——老舍（各位知友，大胆化用吧。）</p><p>我不再爱她，这是确定的，但我也许爱她，爱情太短，而遗忘太长。——聂鲁达（我喜欢你是寂静的，就不列了。）</p><p>追逐影子的人，自己就是影子。——荷马</p><p>洛丽塔，我生命之光，我欲念之火，我的罪恶，我的灵魂。——纳博科夫（肉麻至极，浪漫至极，痴情至极。）</p><p>我不够富，不能像我希望的那样爱你；我不够穷，不能像你希望的那样被你爱，让我们彼此忘却——你是忘却一个对你说来相当冷酷的姓名，我是忘却一种我供养不起的幸福。——小仲马（一生一部茶花女，足够了。）</p><p>要是爱你爱的少些，话就可以说的多些了。——简·奥斯汀</p><p>我永恒的灵魂，注视着你的心，纵然黑夜孤寂，白昼如焚。——兰波（魏尔伦，肥皂掉了。）</p><p>不惋惜，不呼唤，我也不啼哭。一切将逝去，如苹果花丛的薄雾。金黄的落叶堆满心间，我已不再是青春少年。——叶赛宁</p><p>岁月不饶人，我亦未曾饶过岁月。——木心（从前慢，就不列了。）</p><p>你千万别跟任何人谈任何事情。你只要一谈起，就会想念起每一个人来。——塞林格</p><p>造一个草原要一株三叶草加一只蜜蜂。一株三叶草，一只蜂，再加一个梦。要是蜜蜂少，光靠梦也行。——狄金森</p><p>我想要在茅亭里看雨、假山边看蚂蚁，看蝴蝶恋爱，看蜘蛛结网，看水，看船，看云，看瀑布，看宋清如甜甜地睡觉。——朱生豪</p><p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还被幸福所伤。——太宰治</p><p>我向旧日的恋人道歉，因为我对新人如同初恋。——辛波丝卡（这句话太有实践价值了，你们还不赶紧去用。）</p><p>从卖气球的人那里，每个孩子牵走一个心愿。——北岛（我又来推荐北岛的散文集了。）</p><p>一个女子在诗人的诗中，永远不会老去，但诗人他自己却老去了。——沈从文</p><p>你不是爱情的终点，只是爱情的原动力。我将这爱情献给路旁的花朵，献给玻璃酒杯里摇晃着的晶亮阳光，献给教堂的红色圆顶。因为你，我爱上了这个世界。——黑塞（哼哼哼，谁还说偏题。）</p><p>最要紧的是，我们首先应该善良，其次要诚实，再其次是以后永远不要相互遗忘。——陀思妥耶夫斯基</p><p>决定我们成为什么样人的，不是我们的能力，而是我们的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 词句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊字符</title>
      <link href="/2016/07/27/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
      <url>/2016/07/27/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>❉ ✲☣ ☢ ☠  ┲ ❣ ✚ ✪ ✣ ✤ ✥ ✦ ❥ ❦ ❧ ✄ ☪ ❃ ❂ ❁ ❀☭ ♦ ◊  ♠ ♣ •● ❤ ●•۰ ☼ ♧♡♂♀♠♣♥❤☜☞☎☏⊙◎ ☺☻☼▧▨♨◐◑↔↕▪ ? ▣▤▥ ▦▩◘ ◈◇♬♪♩♭♪の★☆→Ю〓§♤♥▶¤๑⊹⊱⋛⋌⋚⊰⊹≈ ๑۩۩.. ..۩۩๑ ๑۩۞۩๑  ❈ ✿ ✲ ❈ ➹ ~.~ ◕‿-｡ ☀☂☁【】┱<br> ღ ▶ ▷ ◀ ◁ ☀ ☁ ☂ ☃ ☄ ★ ☆ ☇ ☈ ⊙ ☊ ☋ ☌ ☍ⓛⓞⓥⓔ ╬ 『 』∴ ☀ .｡◕‿◕｡ ♫ ♬ ♩ ♭ ♪ ☆ ∷ ﹌ の ★ ◎ ▶☺ ☻ ► ◄ ▧ ▨ ♨ ◐ ◑ ↔ ↕↘ ☼ ? ▄ █ ▌▬ ♦ ◊ ▬ ♦ ◊ ◦ ☼ ♪ の ☆→ ♧ ぃ ￡ ❤✎ ✟ஐ   </p><p>♡.1　⊙●○①?◎Θ⊙¤㊣★☆♀◆◇◣◢◥▲▼△▽⊿◤ ◥　　　　<br>♡.2　▆ ▇ █ █ ■ ▓ 回 □ 〓≡ ╝╚╔ ╗╬ ═ ╓ ╩ ┠ ┨┯ ┷┏<br>♡.3　┓┗ ┛┳⊥『』┌ ┐└ ┘∟「」↑↓→←↘↙♀♂┇┅ ﹉﹊﹍﹎╭<br>♡.4　╮╰ ╯ <em>^_^</em> ^<em>^ ^-^ ^_^ ^（^ ∵∴‖｜ ｜︴﹏﹋﹌（）〔〕<br>♡.5　【】〖〗＠：！/ “ _ &lt; &gt; `,·。≈{}~ ～() _ -『』√ $ @ </em> &amp; # ※<br>♡.6　卐 々∞Ψ ∪∩∈∏ の ℡ ぁ §∮”〃ミ灬ξ№∑⌒ξζω＊????ㄨ ≮≯<br>♡.7　－×÷＋－±／＝∫∮∝ ∞ ∧∨ ∑ ∏ ‖∠ ≌ ∽ ≤ ≥ ≈＜＞じ<br>♡.8　☆veve↑↓⊙●★☆■♀『』◆◣◥▲Ψ ※◤ ◥ →№←㊣∑⌒〖〗＠<br>♡.9　ξζω□∮〓※∴ぷ∏卐【】△√ ∩¤々♀♂∞①ㄨ≡↘↙▂<br>♡.10　▂ ▃ ▄ ▅ ▆ ▇ █┗┛╰☆╮ ≠ ▂ ▃ ▄ ▅</p>]]></content>
      
      
      <categories>
          
          <category> 工具书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>书录</title>
      <link href="/2016/07/27/%E8%AF%BB%E4%B9%A6/"/>
      <url>/2016/07/27/%E8%AF%BB%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<p>记录一下看过的书。</p>]]></content>
      
      
      <categories>
          
          <category> 小世界 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 万卷书 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
